<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Workflow Editor - Calendarify</title>
  <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined" rel="stylesheet" />
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #1A2E29;
      color: #E0E0E0;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    .workflow-editor {
      display: flex;
      height: 100vh;
      width: 100vw;
    }

    .toolbar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      background: #1E3A34;
      border-bottom: 1px solid #2C4A43;
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
      justify-content: flex-start;
    }

    .workflow-name-input {
      background: #1E3A34 !important;
      border: 1px solid #2C4A43 !important;
      border-radius: 0.5rem;
      padding: 0.6rem 0.9rem;
      color: #E0E0E0 !important;
      width: 280px;
      max-width: 360px;
      flex: 0 0 auto;
      font-size: 0.875rem;
      transition: all 0.2s;
    }
    
    .workflow-name-input:focus {
      outline: none;
      border-color: #34D399;
      box-shadow: 0 0 0 3px rgba(52, 211, 153, 0.1);
    }
    
    .workflow-name-input::placeholder {
      color: #A3B3AF;
    }

    .save-btn {
      background: #34D399;
      color: #ffffff;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      font-weight: 600;
      border: none;
      cursor: pointer;
      transition: all 0.2s;
    }

    .save-btn:hover {
      background: #10b981;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(52, 211, 153, 0.3);
    }

    .context-btn {
      background: #111827;
      color: #E0E0E0;
      padding: 0.5rem 0.875rem;
      border-radius: 0.5rem;
      font-weight: 500;
      border: 1px solid #374151;
      cursor: pointer;
      transition: all 0.2s;
    }

    .context-btn:hover {
      background: #1f2937;
      border-color: #4b5563;
    }

    /* Compact branch switcher controls */
    #draft-branch-switcher { gap: 6px; }
    #draft-branch-switcher .context-btn {
      padding: 2px 8px;
      font-size: 0.8rem;
      line-height: 1;
      height: 28px;
      white-space: nowrap;
    }
    #draft-branch-switcher select {
      height: 28px;
      padding: 0 6px;
      font-size: 0.85rem;
      white-space: nowrap;
      max-width: 220px;
    }

    .toolbar-group {
      display: flex;
      gap: .5rem;
      align-items: center;
      flex: 0 1 auto;
      flex-wrap: wrap;
    }

    @media (max-width: 900px) {
      .workflow-name-input { flex-basis: 100%; width: 100%; max-width: 100%; }
      .toolbar { gap: .5rem; }
      .save-btn, .context-btn { padding: 0.45rem 0.75rem; }
      #draft-branch-switcher .context-btn { padding: 2px 6px; font-size: 0.75rem; }
      #draft-branch-switcher select { max-width: 240px; }
    }

    @media (max-width: 600px) {
      .workflow-name-input { min-width: 140px; }
      .toolbar { padding: 0.5rem 0.75rem; }
      .save-btn, .context-btn { font-size: 0.85rem; }
      #draft-branch-switcher .context-btn { padding: 1px 6px; font-size: 0.7rem; }
      #draft-branch-switcher select { max-width: 150px; }
    }

    .flowchart-canvas {
      flex: 1;
      background: #1a1a1a;
      position: relative;
      overflow: auto;
      cursor: grab;
      margin-top: 96px;
      scrollbar-width: thin;
      scrollbar-color: #374151 #1a1a1a;
      /* add room for zoom controls */
      padding-bottom: 48px;
    }
    
    .flowchart-canvas::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    
    .flowchart-canvas::-webkit-scrollbar-track {
      background: #1a1a1a;
    }
    
    .flowchart-canvas::-webkit-scrollbar-thumb {
      background: #374151;
      border-radius: 4px;
    }
    
    .flowchart-canvas::-webkit-scrollbar-thumb:hover {
      background: #34D399;
    }

    .flowchart-canvas:active {
      cursor: grabbing;
    }

    .flowchart-container {
      min-width: 100%;
      min-height: 100%;
      padding: 2rem;
      position: relative;
    }

    .flowchart-node {
      position: absolute;
      background: #1E3A34;
      border: 2px solid #2C4A43;
      border-radius: 0.75rem;
      padding: 1rem;
      width: 320px;
      box-sizing: border-box;
      cursor: pointer;
      transition: box-shadow 0.2s, border-color 0.2s;
      z-index: 10;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);
    }

    .flowchart-node:hover {
      border-color: #34D399;
      box-shadow: 0 10px 15px -3px rgba(52, 211, 153, 0.3), 0 4px 6px -2px rgba(52, 211, 153, 0.2);
    }

    .flowchart-node.trigger {
      background: linear-gradient(135deg, #1E3A34 0%, #19342e 100%);
      border-color: #34D399;
      border-width: 3px;
    }
    
    .flowchart-node.trigger::after {
      content: 'Click to configure';
      position: absolute;
      bottom: -25px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.75rem;
      color: #34D399;
      font-weight: 500;
      white-space: nowrap;
    }
    
    .flowchart-node.trigger.configured::after {
      display: none;
    }

    .flowchart-node.action {
      background: linear-gradient(135deg, #1E3A34 0%, #223c36 100%);
      border-color: #2C4A43;
    }

    .flowchart-node.selected {
      border-color: #34D399;
      box-shadow: 0 0 25px rgba(52, 211, 153, 0.5);
    }

    .node-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
      position: relative;
    }
    
    .node-actions {
      display: flex;
      gap: 0.25rem;
      margin-left: auto;
    }
    
    .node-action-btn {
      background: none;
      border: none;
      color: #A3B3AF;
      cursor: pointer;
      padding: 0.25rem;
      border-radius: 0.25rem;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .node-action-btn:hover {
      background: rgba(52, 211, 153, 0.1);
      color: #34D399;
    }
    
    .node-action-btn .material-icons-outlined {
      font-size: 1rem;
    }

    .node-icon {
      color: #34D399;
      font-size: 1.25rem;
    }

    .node-title {
      font-weight: 600;
      color: #E0E0E0;
      font-size: 0.9rem;
    }

    .node-content {
      color: #A3B3AF;
      font-size: 0.8rem;
      line-height: 1.4;
    }

    .connection-line {
      position: absolute;
      background: #2C4A43;
      z-index: 5;
      height: 2px;
      transform-origin: 0 0;
    }

    .connection-line:hover {
      background: #34D399;
      box-shadow: 0 0 10px rgba(52, 211, 153, 0.5);
    }

    .add-action-orb {
      position: absolute;
      width: 40px;
      height: 40px;
      background: #34D399;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 15;
      box-shadow: 0 4px 12px rgba(52, 211, 153, 0.3);
    }

    .add-action-orb:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 20px rgba(52, 211, 153, 0.5);
    }

    .add-action-orb .material-icons-outlined {
      color: #1A2E29;
      font-size: 1.25rem;
    }

    .insert-action-orb {
      position: absolute;
      width: 32px;
      height: 32px;
      background: linear-gradient(135deg, #34D399 0%, #10B981 100%);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 25;
      box-shadow: 0 3px 8px rgba(52, 211, 153, 0.3);
      border: 2px solid rgba(255, 255, 255, 0.1);
    }

    .insert-action-orb:hover {
      transform: scale(1.1);
      box-shadow: 0 4px 12px rgba(52, 211, 153, 0.5);
    }

    .insert-action-orb .material-icons-outlined {
      color: #1A2E29;
      font-size: 1rem;
    }

    .modal-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .workflow-loading-screen {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #1a1a1a;
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1rem;
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid #374151;
      border-top: 3px solid #34D399;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .loading-text {
      color: #A3B3AF;
      font-size: 0.875rem;
      font-weight: 500;
    }

    .modal {
      background: #374151;
      border: 1px solid #4b5563;
      border-radius: 0.75rem;
      padding: 1.5rem;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
    }

    .modal-header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid #4b5563;
    }

    .modal-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: #E0E0E0;
    }

    .modal-close {
      margin-left: auto;
      background: none;
      border: none;
      color: #A3B3AF;
      cursor: pointer;
      padding: 0.25rem;
      border-radius: 0.25rem;
      transition: all 0.2s;
    }

    .modal-close:hover {
      color: #E0E0E0;
      background: #19342e;
    }

    .form-group {
      margin-bottom: 1rem;
    }

    .form-label {
      display: block;
      color: #A3B3AF;
      font-size: 0.875rem;
      margin-bottom: 0.5rem;
    }

    .form-select {
      width: 100%;
      background: #1E3A34 !important;
      border: 1px solid #2C4A43 !important;
      border-radius: 0.5rem;
      padding: 0.75rem;
      color: #E0E0E0 !important;
      font-size: 0.875rem;
      transition: all 0.2s;
    }

    .form-select:focus {
      outline: none;
      border-color: #34D399;
      box-shadow: 0 0 0 3px rgba(52, 211, 153, 0.1);
    }
    
    .form-select option {
      background: #1E3A34;
      color: #E0E0E0;
    }
    
    /* Ensure all form elements use dark theme */
    select.form-select {
      background: #1E3A34 !important;
      color: #E0E0E0 !important;
    }
    
    select.form-select option {
      background: #1E3A34 !important;
      color: #E0E0E0 !important;
    }
    
    /* Override browser defaults for select elements */
    select {
      background: #1E3A34 !important;
      color: #E0E0E0 !important;
    }
    
    select option {
      background: #1E3A34 !important;
      color: #E0E0E0 !important;
    }

    .multi-select {
      position: relative;
      width: 100%;
    }

    .multi-select-button {
      background: #1E3A34;
      border: 1px solid #2C4A43;
      border-radius: 0.5rem;
      padding: 0.75rem;
      color: #E0E0E0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      cursor: pointer;
      transition: all 0.2s;
    }

    .multi-select-button:hover {
      border-color: #34D399;
      background: #2C4A43;
    }

    .multi-select-options {
      position: absolute;
      left: 0;
      top: 100%;
      margin-top: 0.25rem;
      width: 100%;
      background: #1E3A34;
      border: 1px solid #2C4A43;
      border-radius: 0.5rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.2);
      z-index: 50;
      max-height: 200px;
      overflow-y: auto;
      display: none;
      padding: 0.5rem 0;
    }

    .multi-select-options.show {
      display: block;
    }

    .multi-select-option {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem;
      color: #E0E0E0;
      cursor: pointer;
      transition: all 0.2s;
      border-radius: 0.25rem;
      margin: 0 0.5rem;
    }

    .multi-select-option:hover {
      background: #2C4A43;
    }

    .multi-select-option input[type="checkbox"] {
      width: 1rem;
      height: 1rem;
      accent-color: #34D399;
    }

    .select-all-btn {
      background: #34D399;
      color: #ffffff;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      font-size: 0.875rem;
      font-weight: 500;
      border: none;
      cursor: pointer;
      transition: all 0.2s;
      margin: 0.5rem;
    }

    .select-all-btn:hover {
      background: #10b981;
      transform: translateY(-1px);
    }

    .modal-actions {
      display: flex;
      gap: 1rem;
      justify-content: flex-end;
      margin-top: 2rem;
      padding-top: 1rem;
      border-top: 1px solid #4b5563;
    }

    .btn-secondary {
      background: #6b7280;
      color: #E0E0E0;
      padding: 0.75rem 1.5rem;
      border-radius: 0.5rem;
      font-weight: 500;
      border: 1px solid #6b7280;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-secondary:hover {
      background: #4b5563;
      color: #E0E0E0;
    }

    .btn-primary {
      background: #34D399;
      color: #ffffff;
      padding: 0.75rem 1.5rem;
      border-radius: 0.5rem;
      font-weight: 600;
      border: none;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-primary:hover {
      background: #10b981;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(52, 211, 153, 0.3);
    }

    .btn-primary:disabled {
      background: #94a3b8;
      cursor: not-allowed;
      opacity: 0.6;
    }

    .coming-soon {
      opacity: 0.5;
      
      cursor: not-allowed;
    }

    .coming-soon .form-select {
      cursor: not-allowed;
    }

    .coming-soon-badge {
      background: #f59e0b;
      color: white;
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.75rem;
      margin-left: 0.5rem;
      font-weight: 500;
    }
    /* Notification styles */
    .notification {
      position: fixed;
      top: 1rem;
      right: 1rem;
      z-index: 9999;
      padding: 1rem;
      border-radius: 0.5rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
      min-width: 300px;
      transform: translateX(100%);
      transition: transform 0.3s ease-in-out;
    }

    .notification.show {
      transform: translateX(0);
    }

    .notification.success {
      background: #34D399;
      color: white;
    }

    .notification.error {
      background: #EF4444;
      color: white;
    }
    /* Draft name modal */
    #draft-modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 1000; }
    #draft-modal { width: 420px; max-width: 90vw; background: #0b1715; border: 1px solid #2C4A43; border-radius: 12px; padding: 16px; color: #E0E0E0; box-shadow: 0 10px 30px rgba(0,0,0,0.35); }
    #draft-modal h3 { margin: 0 0 10px 0; font-size: 1rem; color: #E0E0E0; }
    #draft-modal p { margin: 0 0 12px 0; font-size: .9rem; color: #9EB7A8; }
    #draft-name-input { width: 100%; box-sizing: border-box; padding: 10px 12px; border-radius: 8px; border: 1px solid #2C4A43; background: #1E3A34; color: #E0E0E0; }
    #draft-modal-actions { margin-top: 14px; display: flex; gap: 8px; justify-content: space-between; align-items: center; }
    .btn-secondary { background: #1c2b28; color: #E0E0E0; border: 1px solid #2C4A43; border-radius: 8px; padding: 8px 12px; cursor: pointer; }
    .btn-primary { background: #34D399; color: #0b1715; border: none; border-radius: 8px; padding: 8px 12px; font-weight: 700; cursor: pointer; }
  </style>
</head>
<body>
  <div class="workflow-editor">
      <div id="draft-modal-overlay">
        <div id="draft-modal">
          <h3>Create draft branch</h3>
          <p>Name your draft branch. You can rename it later.</p>
          <input id="draft-name-input" placeholder="e.g., Experiment A" />
          <div id="draft-modal-actions">
            <div style="display:flex;gap:8px; margin-left:auto;">
              <button id="draft-cancel" class="btn-secondary">Cancel</button>
              <button id="draft-create" class="btn-primary">Create</button>
            </div>
          </div>
        </div>
      </div>
    <!-- Toolbar -->
    <div class="toolbar">
      <input type="text" id="workflow-name" class="workflow-name-input" placeholder="Enter workflow name...">
      <button id="exit-to-dashboard-top" class="context-btn" style="margin-left:8px">Exit to Dashboard</button>
      <div class="toolbar-group">
        <div id="draft-branch-switcher" style="display:flex;align-items:center;gap:.6rem;background:#0b1715;border:1px solid #2C4A43;border-radius:8px;padding:6px 10px;">
          <span class="material-icons-outlined" style="font-size:18px;color:#A3B3AF">call_split</span>
          <div id="branch-dropdown" style="position:relative;display:flex;align-items:center;gap:8px;">
            <button id="branch-trigger" class="context-btn" style="height:32px;padding:4px 10px;white-space:nowrap;display:flex;align-items:center;gap:6px;max-width:480px;overflow:hidden;text-overflow:ellipsis">
              <span class="material-icons-outlined" style="font-size:16px;">arrow_drop_down</span>
              <span id="branch-current-label">Main</span>
            </button>
            <div id="branch-menu" style="position:absolute;top:38px;left:0;background:#0b1715;border:1px solid #2C4A43;border-radius:10px;display:none;z-index:1000;min-width:420px;box-shadow:0 12px 28px rgba(0,0,0,0.45);padding:8px;max-width:80vw">
              <div class="branch-item" data-branch="main" style="display:flex;align-items:center;justify-content:space-between;gap:8px;padding:8px 10px;border-radius:8px;cursor:pointer;">
                <span>Main</span>
              </div>
              <div style="height:1px;background:#223A35;margin:6px 0;"></div>
              <div id="branch-items" style="display:flex;flex-direction:column;gap:6px"></div>
            </div>
          </div>
          <button class="context-btn" id="create-branch-btn">New Draft</button>
          <button class="context-btn" id="apply-branch-to-main-btn" title="Apply current draft to Main">Apply to Main</button>
        </div>
        <a href="/editor/guide" target="_blank" class="save-btn" style="background:#12221E;border:1px solid #2C4A43;color:#E0E0E0;text-decoration:none;display:inline-flex;align-items:center;gap:.35rem">
          <span class="material-icons-outlined" style="font-size:18px;color:#A3B3AF">menu_book</span>
          Guide
        </a>
        <!-- Save removed; using Apply to Main as the primary action -->
      </div>
      <button id="open-context" class="context-btn" onclick="openContextModal()">Context</button>
      <button id="open-errors" class="context-btn" onclick="toggleErrorsPanel()">Errors</button>
      <button id="open-runs" class="context-btn" onclick="toggleRunsPanel()">Runs</button>
      <button id="debug-layout" class="context-btn" title="Log layout debug">Debug</button>
    </div>

    <!-- Flowchart Canvas -->
    <div class="flowchart-canvas" id="flowchart-canvas">
      <div class="workflow-loading-screen" id="workflow-loading-screen">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading workflow...</div>
        </div>
      <div class="flowchart-container" id="flowchart-container">
        <!-- Trigger node will be added here -->
      </div>
      <!-- Zoom controls -->
      <div id="zoom-controls" style="position:absolute; left:12px; bottom:12px; display:flex; gap:8px; z-index:200;">
        <button id="zoom-out" class="context-btn" title="Zoom out" style="padding:6px 10px">-</button>
        <div id="zoom-level" style="color:#E0E0E0; align-self:center; min-width:54px; text-align:center;">100%</div>
        <button id="zoom-in" class="context-btn" title="Zoom in" style="padding:6px 10px">+</button>
        <button id="zoom-reset" class="context-btn" title="Reset" style="padding:6px 10px">Reset</button>
      </div>
      
      <!-- Errors Drawer -->
      <div id="errors-drawer" style="position:absolute; right:0; top:0; bottom:0; width:420px; background:#0b1715; border-left:1px solid #2C4A43; display:none; z-index:200; padding:1rem; overflow:auto;">
        <div style="display:flex;align-items:center;gap:.5rem; margin-bottom:.75rem;">
          <span class="material-icons-outlined" style="color:#F87171">error</span>
          <div style="font-weight:600;color:#E0E0E0">Latest Workflow Errors</div>
          <div style="margin-left:auto; display:flex; gap:.5rem;">
            <button class="context-btn" onclick="refreshErrors()">Refresh</button>
            <button class="context-btn" onclick="toggleErrorsPanel()">Close</button>
          </div>
        </div>
        <div id="errors-list" style="display:flex; flex-direction:column; gap:.75rem;"></div>
      </div>
      
      <!-- Runs Drawer -->
      <div id="runs-drawer" style="position:absolute; right:0; top:0; bottom:0; width:480px; background:#0b1715; border-left:1px solid #2C4A43; display:none; z-index:200; padding:1rem; overflow:auto;">
        <div style="display:flex;align-items:center;gap:.5rem; margin-bottom:.75rem;">
          <span class="material-icons-outlined" style="color:#60A5FA">timeline</span>
          <div style="font-weight:600;color:#E0E0E0">Workflow Runs</div>
          <div style="margin-left:auto; display:flex; gap:.5rem;">
            <button class="context-btn" onclick="refreshRuns()">Refresh</button>
            <button class="context-btn" onclick="toggleRunsPanel()">Close</button>
          </div>
        </div>
        <div id="runs-active" style="margin-bottom:1rem;"></div>
        <div id="runs-history"></div>
        <div id="run-details" style="margin-top:1rem; display:none;"></div>
      </div>
    </div>
  </div>

  <!-- Confirm Modal (themed) -->
  <div id="confirm-modal" class="modal-backdrop hidden">
    <div class="modal" style="background:#0b1715;border:1px solid #2C4A43;color:#E0E0E0">
      <div class="modal-header">
        <span class="material-icons-outlined node-icon">help_outline</span>
        <h3 class="modal-title" id="confirm-title">Confirm</h3>
        <button class="modal-close" onclick="(function(){document.getElementById('confirm-modal').classList.add('hidden')})()">
          <span class="material-icons-outlined">close</span>
        </button>
      </div>
      <div class="form-group" style="padding: 0 .5rem 0 .5rem">
        <div id="confirm-message" style="white-space:pre-wrap; color:#CFE7E1"></div>
      </div>
      <div class="modal-actions">
        <button class="btn-secondary" id="confirm-cancel">Cancel</button>
        <button class="btn-primary" id="confirm-ok">Confirm</button>
      </div>
    </div>
  </div>

  <!-- Prompt Modal (themed) -->
  <div id="prompt-modal" class="modal-backdrop hidden">
    <div class="modal" style="background:#0b1715;border:1px solid #2C4A43;color:#E0E0E0">
      <div class="modal-header">
        <span class="material-icons-outlined node-icon">edit</span>
        <h3 class="modal-title" id="prompt-title">Rename</h3>
        <button class="modal-close" onclick="(function(){document.getElementById('prompt-modal').classList.add('hidden')})()">
          <span class="material-icons-outlined">close</span>
        </button>
      </div>
      <div class="form-group">
        <label class="form-label" id="prompt-label">New name</label>
        <input type="text" id="prompt-input" class="form-input" style="background:#0b1715;border:1px solid #2C4A43;color:#E0E0E0" />
      </div>
      <div class="modal-actions">
        <button class="btn-secondary" id="prompt-cancel">Cancel</button>
        <button class="btn-primary" id="prompt-ok">Save</button>
      </div>
    </div>
  </div>

  <!-- Trigger Modal -->
  <div id="trigger-modal" class="modal-backdrop hidden">
    <div class="modal">
      <div class="modal-header">
        <span class="material-icons-outlined node-icon">play_circle</span>
        <h3 class="modal-title">Configure Trigger</h3>
        <button class="modal-close" onclick="closeTriggerModal()">
          <span class="material-icons-outlined">close</span>
        </button>
      </div>
      
      <div class="form-group">
        <label class="form-label">Trigger Type</label>
        <select id="trigger-select" class="form-select">
          <option value="Meeting Scheduled">Meeting Scheduled</option>
          <option value="Tag Added">Tag Added</option>
          <option value="Attendee Rescheduled" disabled class="coming-soon">Attendee Rescheduled <span class="coming-soon-badge">Coming Soon</span></option>
          <option value="Host Rescheduled" disabled class="coming-soon">Host Rescheduled <span class="coming-soon-badge">Coming Soon</span></option>
          <option value="Attendee Canceled" disabled class="coming-soon">Attendee Canceled <span class="coming-soon-badge">Coming Soon</span></option>
          <option value="Host Canceled" disabled class="coming-soon">Host Canceled <span class="coming-soon-badge">Coming Soon</span></option>
          <option value="Meeting Ended" disabled class="coming-soon">Meeting Ended <span class="coming-soon-badge">Coming Soon</span></option>
        </select>
      </div>

      <div id="trigger-properties"></div>

      <div class="modal-actions">
        <button class="btn-secondary" onclick="closeTriggerModal()">Cancel</button>
        <button class="btn-primary" onclick="saveTrigger()">Save Trigger</button>
      </div>
    </div>
  </div>

  <!-- Action Modal -->
  <div id="action-modal" class="modal-backdrop hidden">
    <div class="modal">
      <div class="modal-header">
        <span class="material-icons-outlined node-icon">settings</span>
        <h3 class="modal-title">Add Action</h3>
        <button class="modal-close" onclick="closeActionModal()">
          <span class="material-icons-outlined">close</span>
        </button>
      </div>
      
      <div class="form-group">
        <label class="form-label">Action Type</label>
        <select id="action-select" class="form-select">
          <option value="Add Tag">Add Tag</option>
          <option value="Send Email">Send Email</option>
          <option value="If">If</option>
          <option value="Create Meeting" disabled class="coming-soon">Create Meeting <span class="coming-soon-badge">Coming Soon</span></option>
        </select>
      </div>

      <div id="action-properties"></div>

      <div class="modal-actions">
        <button class="btn-secondary" onclick="closeActionModal()">Cancel</button>
        <button class="btn-primary" onclick="saveAction()" id="action-save-btn">Add Action</button>
      </div>
    </div>
  </div>

  <!-- Context Modal -->
  <div id="context-modal" class="modal-backdrop hidden">
    <div class="modal" style="max-width: 760px; width: 95%">
      <div class="modal-header">
        <span class="material-icons-outlined node-icon">integration_instructions</span>
        <h3 class="modal-title">Execution Context</h3>
        <button class="modal-close" onclick="closeContextModal()">
          <span class="material-icons-outlined">close</span>
        </button>
      </div>

      <div class="form-group">
        <label class="form-label">Attach full contact/booking context to workflow runs</label>
        <label style="display:flex;align-items:center;gap:.5rem;color:#E0E0E0">
          <input type="checkbox" id="context-attach-full" />
          <span>Enable full context (contact + booking)</span>
        </label>
      </div>

      <div class="form-group">
        <label class="form-label">Schema Preview</label>
        <pre id="context-schema" style="background:#111827;border:1px solid #374151;border-radius:.5rem;padding:1rem;white-space:pre-wrap;max-height:240px;overflow:auto;color:#d1d5db"></pre>
        <div style="margin-top:.5rem;display:flex;gap:.5rem">
          <button class="context-btn" onclick="copyContextSchema()">Copy Schema</button>
          <span id="context-schema-copy-status" style="color:#A3B3AF"></span>
        </div>
      </div>

      <div class="form-group">
        <label class="form-label">Optional Sample Payload (JSON)</label>
        <textarea id="context-sample"
          placeholder='{"contact": {"id":"..."}, "booking": {"id":"..."}}'
          style="width:100%;min-height:140px;background:#111827;border:1px solid #374151;border-radius:.5rem;padding:.75rem;color:#E0E0E0;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace"></textarea>
        <div style="margin-top:.25rem;color:#9ca3af;font-size:.85rem">Saved with the workflow for testing and future evaluation. Optional.</div>
      </div>

      <div class="modal-actions">
        <button class="btn-secondary" onclick="closeContextModal()">Cancel</button>
        <button class="btn-primary" onclick="saveContextSpec()">Save Context</button>
      </div>
    </div>
  </div>

  <script defer>
    // Constants and utilities
    const API_URL = 'http://localhost:3001/api';
    const NODE_WIDTH = 320;          // px, matches .flowchart-node width
    const VERTICAL_SPACING = 120;    // px vertical spacing between nodes
    const ORB_SIZE = 40;             // px, action orb size
    const INSERT_ORB_SIZE = 32;      // px, insert orb size
    const DEBUG_LINE_PATHS = false;  // reduce noise; enable on demand

    // Context spec (versioned) persisted with workflows for future engine use
    let contextSpec = null;

    function getDefaultContextSchema() {
      return {
        contact: {
          id: 'string',
          firstName: 'string',
          lastName: 'string',
          fullName: 'string',
          email: 'string',
          phone: 'string',
          timezone: 'string',
          locale: 'string',
          tags: ['string'],
          company: 'string',
          title: 'string',
          notes: 'string',
          createdAt: 'string',
          updatedAt: 'string',
          customFields: 'object'
        },
        booking: {
          id: 'string',
          title: 'string',
          status: 'string',
          eventType: 'string',
          startTime: 'string',
          endTime: 'string',
          durationMinutes: 'number',
          timezone: 'string',
          location: 'string',
          meetingLink: 'string',
          attendees: [
            {
              name: 'string',
              email: 'string',
              role: 'string'
            }
          ],
          rescheduleCount: 'number',
          answers: 'object',
          metadata: 'object',
          createdAt: 'string',
          updatedAt: 'string'
        }
      };
    }

    function getDefaultContextSpec() {
      return {
        version: 1,
        attachFullContext: true,
        scope: 'full', // future: 'subset'
        schema: getDefaultContextSchema(),
        sample: null
      };
    }
    
    // Client does not manage tokens; backend authenticates via HttpOnly cookies
    function getAnyToken() { return null; }
    
    // Centralized unauthorized handling: clear tokens and redirect to login
    function handleUnauthorizedRedirect() {
      const url = new URL(window.location.origin + '/log-in');
      url.searchParams.set('notification', 'Session expired, please log in');
      window.location.href = url.toString();
    }
    
    // Global fetch wrapper: inject Authorization header and auto-redirect on 401
    (function installAuthFetchWrapper(){
      try {
        if (window.__authFetchInstalled) return; // idempotent
        const originalFetch = window.fetch.bind(window);
        window.fetch = async (input, init = {}) => {
          try {
            const headers = new Headers(init.headers || {});
            // Always rely on cookie-based auth; no local storage/token reads
            init = Object.assign({}, init, { headers, credentials: 'include' });
          } catch {}
          const res = await originalFetch(input, init);
          if (res && res.status === 401) {
            // Proactively redirect to login on unauthorized
            handleUnauthorizedRedirect();
          }
          return res;
        };
        window.__authFetchInstalled = true;
      } catch {}
    })();
    
    // Get workflow ID from URL parameters instead of localStorage
    function getCurrentWorkflowId() {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get('workflow') || null;
    }
    
    // Note: No local storage usage for editor state unless absolutely necessary
    
    // Set workflow ID in URL instead of localStorage
    function setCurrentWorkflowId(workflowId) {
      const url = new URL(window.location);
      if (workflowId) {
        url.searchParams.set('workflow', workflowId);
      } else {
        url.searchParams.delete('workflow');
      }
      window.history.replaceState({}, '', url);
    }
    
    // Get current branch from URL parameters instead of localStorage
    function getCurrentBranch() {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get('branch') || 'main';
    }
    
    // Set current branch in URL instead of localStorage
    function setCurrentBranch(branch) {
      const url = new URL(window.location);
      if (branch && branch !== 'main') {
        url.searchParams.set('branch', branch);
      } else {
        url.searchParams.delete('branch');
      }
      window.history.replaceState({}, '', url);
    }
    
    // Order tracking
    if (typeof window.__DEBUG_ORDERS__ === 'undefined') window.__DEBUG_ORDERS__ = true;
    let orderCounter = 0;
    function logOrder(event) {
      if (!window.__DEBUG_ORDERS__) return;
      const t = (typeof performance !== 'undefined' && performance.now) ? performance.now().toFixed(1) : Date.now();
      console.log(`[ORDER-${++orderCounter}] t=${t} ${event}`);
    }

    // Global variables
    let currentWorkflow = null;
    let currentNodeId = 0;
    let availableNodeIds = new Set();
    let nodes = [];
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let canvasOffset = { x: 0, y: 0 };
    let selectedNode = null;
    let didFirstPanRefresh = false;
    let isLoadingWorkflow = false;
    let currentLoadSteps = null;
    // Gate to prevent mid-stream rebuilds while bulk-applying snapshots/loads
    let suspendRebuild = false;
    // Production-grade Connection and Orb Management System
    const WorkflowManager = {
      connections: new Map(), // connectionId -> connection object
      orbs: new Map(), // nodeId -> orb element
      insertOrbs: new Map(), // connectionId -> insert orb element
      connectionCounter: 0,
      svg: null,
      // Helper: create midpoint insert orbs for all valid connections
      addInsertOrbsForConnections() {
        logOrder('WorkflowManager.addInsertOrbsForConnections begin');
        try {
          for (const connection of this.connections.values()) {
            const fromNode = connection.from;
            const toNode = connection.to;
            // Determine types
            const fromType = (fromNode.__nodeData && fromNode.__nodeData.data?.type) || nodes.find(n=>n.element===fromNode)?.data?.type || '';
            const toType = (toNode.__nodeData && toNode.__nodeData.data?.type) || nodes.find(n=>n.element===toNode)?.data?.type || '';
            // Never show an insert orb on the connections from IF to its True/False headers
            if (fromType === 'If' && (toType === 'True' || toType === 'False')) continue;
            // Allow midpoint orbs on True/False header → first action links (still blocked on IF→headers)
            // Skip orbs on If->True/False when a join node already exists for this IF
            try {
              const fromData = nodes.find(n => n.element === fromNode)?.data || {};
              const toData = nodes.find(n => n.element === toNode)?.data || {};
              const ifId = (fromType === 'If' && (toType === 'True' || toType === 'False'))
                ? (fromData.properties?.ifId)
                : ((toType === 'If' && (fromType === 'True' || fromType === 'False')) ? (toData.properties?.ifId) : null);
              if (ifId) {
                const hasJoin = nodes.some(n => n.data && n.data.properties && n.data.properties.joinForIfId === ifId);
                if (hasJoin) continue;
              }
              // Also never put midpoint orbs on connections leading into a join node
              if (toData && toData.properties && toData.properties.joinForIfId) continue;
            } catch {}
            // Otherwise add midpoint insert orb
            this.createInsertOrb(connection);
            // Additionally, for connections into a join, add a source-anchored orb right under the source node
            try {
              const toData = nodes.find(n => n.element === toNode)?.data || {};
              const isJoinTarget = !!(toData && toData.properties && toData.properties.joinForIfId) || (this.toNodeIsImplicitJoin && this.toNodeIsImplicitJoin(connection));
              if (isJoinTarget) this.createSourceInsertOrb(connection);
            } catch {}
          }
        } catch (e) { console.warn('addInsertOrbsForConnections failed:', e); }
        logOrder('WorkflowManager.addInsertOrbsForConnections end');
      },

      
      // Initialize the system
      init() {
        this.connections.clear();
        this.orbs.clear();
        this.insertOrbs.clear();
        this.connectionCounter = 0;
        // Ensure an SVG overlay exists for pretty paths
        let svg = container.querySelector('#connections-svg');
        if (!svg) {
          svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          svg.setAttribute('id', 'connections-svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
          svg.style.position = 'absolute';
          svg.style.left = '0';
          svg.style.top = '0';
          svg.style.pointerEvents = 'none';
          svg.style.zIndex = '4';
          container.appendChild(svg);
        }
        this.svg = svg;
        logOrder('WorkflowManager.init');
      },
      
      // Create a connection between two nodes
      createConnection(fromNode, toNode, createInsertOrb = true) {
        logOrder(`WorkflowManager.createConnection start ${fromNode?.id} -> ${toNode?.id}`);
        if (!this.isValidConnection(fromNode, toNode)) {
          logOrder(`WorkflowManager.createConnection invalid: ${fromNode?.id} -> ${toNode?.id}`);
          return null;
        }
        
        const connectionId = `conn-${++this.connectionCounter}`;
        
        // Remove any existing connection between these nodes
        this.removeConnectionBetween(fromNode, toNode);
        
        const line = this.createConnectionLine(connectionId);
        const connection = {
          id: connectionId,
          from: fromNode,
          to: toNode,
          line: line,
          created: Date.now()
        };
        
        this.connections.set(connectionId, connection);
        this.updateConnectionPosition(connection);
        
        // Make the line visible after positioning
        connection.line.style.opacity = '1';
        
        // Create insert orb in the middle of the connection (only if requested)
        if (createInsertOrb) {
          // Skip adding insert orbs on any connection that involves an If node
          const fromType = (fromNode.__nodeData && fromNode.__nodeData.data?.type) || nodes.find(n=>n.element===fromNode)?.data?.type || '';
          const toType = (toNode.__nodeData && toNode.__nodeData.data?.type) || nodes.find(n=>n.element===toNode)?.data?.type || '';
          if (!(fromType === 'If' || toType === 'If')) {
            this.createInsertOrb(connection);
          }
        }
        
        logOrder(`WorkflowManager.createConnection end id=${connectionId}`);
        return connection;
      },
      
      // Create the visual connection line element
      createConnectionLine(id) {
        // Use SVG path for smoother, orthogonal lines with rounded corners
        if (!this.svg) this.init();
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('id', id);
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke', '#34D399');
        path.setAttribute('stroke-width', '3');
        path.setAttribute('stroke-linecap', 'round');
        path.setAttribute('stroke-linejoin', 'round');
        path.style.opacity = '0';
        this.svg.appendChild(path);
        requestAnimationFrame(() => { path.style.opacity = '1'; });
        return path;
      },
      
      // Create insert orb in the middle of a connection (idempotent)
      createInsertOrb(connection) {
        if (!connection || !connection.from || !connection.to) {
          return;
        }
        
        // Remove any existing orb for this connection to avoid duplicates
        try {
          const existing = this.insertOrbs.get(connection.id);
          if (existing && existing.parentNode) existing.parentNode.removeChild(existing);
          this.insertOrbs.delete(connection.id);
        } catch {}
        
        const insertOrb = document.createElement('div');
        insertOrb.className = 'insert-action-orb';
        insertOrb.dataset.connectionId = connection.id;
        insertOrb.style.cssText = `
          position: absolute;
          width: 32px;
          height: 32px;
          background: linear-gradient(135deg, #34D399 0%, #10B981 100%);
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          z-index: 25;
          opacity: 0;
          transform: translate(-50%, -50%) scale(0.8);
          transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
          box-shadow: 0 3px 8px rgba(52, 211, 153, 0.3);
          border: 2px solid rgba(255, 255, 255, 0.1);
        `;
        
        insertOrb.innerHTML = `
          <span class="material-icons-outlined" style="color: #1A2E29; font-size: 1rem;">add</span>
        `;
        
        // Add click handler
        insertOrb.addEventListener('click', (e) => {
          e.stopPropagation();
          this.handleInsertOrbClick(connection);
        });
        
        // Add hover effects
        insertOrb.addEventListener('mouseenter', () => {
          insertOrb.style.transform = 'translate(-50%, -50%) scale(1.1)';
          insertOrb.style.boxShadow = '0 4px 12px rgba(52, 211, 153, 0.5)';
        });
        
        insertOrb.addEventListener('mouseleave', () => {
          insertOrb.style.transform = 'translate(-50%, -50%) scale(1)';
          insertOrb.style.boxShadow = '0 3px 8px rgba(52, 211, 153, 0.3)';
        });
        
        container.appendChild(insertOrb);
        this.insertOrbs.set(connection.id, insertOrb);
        
        // Position the insert orb
        this.updateInsertOrbPosition(connection);
        // Also ensure a source-anchored orb exists and is positioned for join connections
        try { this.createSourceInsertOrb(connection); this.updateSourceInsertOrbPosition(connection); } catch {}
        
        // Animate in (preserve centering transform)
        requestAnimationFrame(() => {
          insertOrb.style.opacity = '1';
          insertOrb.style.transform = 'translate(-50%, -50%) scale(1)';
        });
        
      },
      
      // Remove any orbs whose connection no longer exists
      cleanupStaleInsertOrbs() {
        logOrder('WorkflowManager.cleanupStaleInsertOrbs begin');
        try {
          const validIds = new Set(Array.from(this.connections.keys()));
          // Remove DOM nodes not tied to an active connection
          const all = container.querySelectorAll('.insert-action-orb');
          all.forEach((el) => {
            const cid = el?.dataset?.connectionId;
            if (!cid || !validIds.has(cid)) {
              try { el.remove(); } catch {}
            }
          });
          // Also prune internal map
          for (const [cid, el] of this.insertOrbs.entries()) {
            if (!validIds.has(cid)) {
              try { if (el && el.parentNode) el.parentNode.removeChild(el); } catch {}
              this.insertOrbs.delete(cid);
            }
          }
        } catch {}
        logOrder('WorkflowManager.cleanupStaleInsertOrbs end');
      },
      
      // Update insert orb position
      updateInsertOrbPosition(connection) {
        const insertOrb = this.insertOrbs.get(connection.id);
        if (!insertOrb || !connection.from || !connection.to) {
          return;
        }
        
        try {
          // Midpoint orbs are allowed on If-related connections until a join node exists.
          // addInsertOrbsForConnections() already suppresses orbs when a join is present.

          const fromRect = connection.from.getBoundingClientRect();
          const toRect = connection.to.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          
          if (!fromRect || !toRect || !containerRect) {
            return;
          }
          
          // Calculate middle point of the connection (container-local, accounting for scale)
          let _scale = 1;
          try { const m = (container.style.transform || '').match(/scale\(([-\d.]+)\)/); if (m) _scale = parseFloat(m[1]) || 1; } catch {}
          const toLocalX = (vx) => (vx - containerRect.left) / _scale;
          const toLocalY = (vy) => (vy - containerRect.top) / _scale;
          const fromX = toLocalX(fromRect.left + fromRect.width / 2);
          const fromY = toLocalY(fromRect.bottom);
          const toX = toLocalX(toRect.left + toRect.width / 2);
          const toY = toLocalY(toRect.top);
          
          // Check if this is a True/False to join connection
          const fromData = connection.from.__nodeData || nodes.find(n => n.element === connection.from)?.data;
          const toData = connection.to.__nodeData || nodes.find(n => n.element === connection.to)?.data;
          const fromType = fromData?.type || '';
          const toType = toData?.type || '';
          
          let middleX, middleY;
          
          if ((fromType === 'True' || fromType === 'False') && this.toNodeHasJoin(toType, connection)) {
            // For True/False to join connections, position orb on the vertical line segment
            const verticalDistance = Math.abs(toY - fromY);
            const minDrop = 120; // doubled to match connection path
            const maxDrop = 240; // doubled to match connection path
            const midY = fromY + Math.min(Math.max(verticalDistance * 0.4, minDrop), maxDrop);
            const orbY = fromY + (midY - fromY) / 2;
            middleX = fromX; // Keep orb on the vertical line
            middleY = orbY;
          } else if (this.toNodeIsImplicitJoin(connection)) {
            // For implicit join connections, position orb on the vertical line segment
            const verticalDistance = Math.abs(toY - fromY);
            const minDrop = 120; // doubled to match connection path
            const maxDrop = 240; // doubled to match connection path
            const midY = fromY + Math.min(Math.max(verticalDistance * 0.4, minDrop), maxDrop);
            const orbY = fromY + (midY - fromY) / 2;
            middleX = fromX; // Keep orb on the vertical line
            middleY = orbY;
          } else {
            // For regular connections, use geometric midpoint
            middleX = (fromX + toX) / 2;
            middleY = (fromY + toY) / 2;
          }
          
          // Lock to calculated position
          insertOrb.style.left = `${middleX}px`;
          insertOrb.style.top = `${middleY}px`;
          insertOrb.style.transform = 'translate(-50%, -50%)';
          
        } catch (error) {
          console.error('Error updating insert orb position:', error);
        }
      },
      
      // Handle insert orb click
      handleInsertOrbClick(connection) {
        // Store the connection info for insertion
        window.insertConnection = connection;
        openActionModal('insert');
      },
      
      // Update connection position
      updateConnectionPosition(connection) {
        if (!connection || !connection.line || !connection.from || !connection.to) {
          return;
        }
        
        try {
          logOrder(`updateConnectionPosition start from=${connection.from?.id} to=${connection.to?.id}`);
          const fromRect = connection.from.getBoundingClientRect();
          const toRect = connection.to.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          
          if (!fromRect || !toRect || !containerRect) {
            return;
          }
          
          // Calculate anchor points: center bottom of from, center top of to
          const fromX = Math.round(fromRect.left - containerRect.left + fromRect.width / 2);
          const fromY = Math.round(fromRect.bottom - containerRect.top - 1);
          const toX = Math.round(toRect.left - containerRect.left + toRect.width / 2);
          const toY = Math.round(toRect.top - containerRect.top + 1);

          // Determine orthogonal path for branch headers; smooth curve for others
          const fromType = (connection.from.__nodeData && connection.from.__nodeData.data?.type) || nodes.find(n=>n.element===connection.from)?.data?.type || '';
          const toType = (connection.to.__nodeData && connection.to.__nodeData.data?.type) || nodes.find(n=>n.element===connection.to)?.data?.type || '';
          
          if (DEBUG_LINE_PATHS) {
            console.log(`Connection types: fromType=${fromType}, toType=${toType}`);
          }

          // Attach node data refs to DOM once for quicker lookup
          connection.from.__nodeData = nodes.find(n => n.element === connection.from) || connection.from.__nodeData || null;
          connection.to.__nodeData = nodes.find(n => n.element === connection.to) || connection.to.__nodeData || null;

          let d = '';
          const vDrop = 30; // vertical drop from source (default)
          const r = 12; // corner radius
          
          // Handle True/False to join connections first (specific case); also treat implicit joins as joins
          if ((fromType === 'True' || fromType === 'False') && this.toNodeHasJoin(toType, connection)) {
            // Compute a common turn-in level (midY) for all inbound connections to this join target
            const minDrop = 120;
            let midY;
            try {
              const inbound = Array.from(WorkflowManager.connections.values()).filter(c => c && c.to === connection.to);
              if (inbound.length >= 2) {
                let maxFromY = fromY;
                for (const c of inbound) {
                  if (!c.from) continue;
                  const fr = c.from.getBoundingClientRect();
                  if (!fr) continue;
                  const fy = Math.round(fr.bottom - containerRect.top - 1);
                  if (fy > maxFromY) maxFromY = fy;
                }
                midY = Math.min(toY - 12 - 10, maxFromY + minDrop);
              } else {
                const verticalDistance = Math.abs(toY - fromY);
                const maxDrop = 240;
                midY = fromY + Math.min(Math.max(verticalDistance * 0.4, minDrop), maxDrop);
              }
            } catch {
              const verticalDistance = Math.abs(toY - fromY);
              const maxDrop = 240;
              midY = fromY + Math.min(Math.max(verticalDistance * 0.4, minDrop), maxDrop);
            }
            const dir = (toX >= fromX) ? 1 : -1;
            d = `M ${fromX} ${fromY}`;
            d += ` L ${fromX} ${midY - r}`;
            d += ` Q ${fromX} ${midY} ${fromX + dir * r} ${midY}`;
            d += ` L ${toX - dir * r} ${midY}`;
            d += ` Q ${toX} ${midY} ${toX} ${midY + r}`;
            d += ` L ${toX} ${toY}`;
            
            // Note: Orbs are created once when connection is first made, not on every update
            // Ensure DOM path reflects rounded corners
            connection.line.setAttribute('stroke-linecap', 'round');
            connection.line.setAttribute('stroke-linejoin', 'round');
          } else if (this.toNodeIsImplicitJoin(connection)) {
            // Handle branch actions to implicit join node with aligned turn-in level
            const minDrop = 120;
            let midY;
            try {
              const inbound = Array.from(WorkflowManager.connections.values()).filter(c => c && c.to === connection.to);
              if (inbound.length >= 2) {
                let maxFromY = fromY;
                for (const c of inbound) {
                  if (!c.from) continue;
                  const fr = c.from.getBoundingClientRect();
                  if (!fr) continue;
                  const fy = Math.round(fr.bottom - containerRect.top - 1);
                  if (fy > maxFromY) maxFromY = fy;
                }
                midY = Math.min(toY - 12 - 10, maxFromY + minDrop);
              } else {
                const verticalDistance = Math.abs(toY - fromY);
                const maxDrop = 240;
                midY = fromY + Math.min(Math.max(verticalDistance * 0.4, minDrop), maxDrop);
              }
            } catch {
              const verticalDistance = Math.abs(toY - fromY);
              const maxDrop = 240;
              midY = fromY + Math.min(Math.max(verticalDistance * 0.4, minDrop), maxDrop);
            }
            const dir = (toX >= fromX) ? 1 : -1;
            d = `M ${fromX} ${fromY}`;
            d += ` L ${fromX} ${midY - r}`;
            d += ` Q ${fromX} ${midY} ${fromX + dir * r} ${midY}`;
            d += ` L ${toX - dir * r} ${midY}`;
            d += ` Q ${toX} ${midY} ${toX} ${midY + r}`;
            d += ` L ${toX} ${toY}`;
            
            // Note: Orbs are created once when connection is first made, not on every update
            connection.line.setAttribute('stroke-linecap', 'round');
            connection.line.setAttribute('stroke-linejoin', 'round');
          } else if (this.toNodeHasJoin(toType, connection)) {
            // For other join targets, drop further and shorten approach more to center visually
            const vDropJoin = 28; // halved to account for longer lines with orbs
            const approachShorten = 14;
            const midY = fromY + vDropJoin;
            const dir = (toX >= fromX) ? 1 : -1;
            d += `M ${fromX} ${fromY}`;
            d += ` L ${fromX} ${midY - r}`;
            d += ` Q ${fromX} ${midY} ${fromX + dir * r} ${midY}`;
            d += ` L ${toX - dir * (r + approachShorten)} ${midY}`;
            d += ` Q ${toX} ${midY} ${toX} ${midY + r}`;
            d += ` L ${toX} ${toY}`;
            // Ensure DOM path reflects rounded corners
            connection.line.setAttribute('stroke-linecap', 'round');
            connection.line.setAttribute('stroke-linejoin', 'round');
          } else if (fromType === 'If' && (toType === 'True' || toType === 'False')) {
            const midY = fromY + vDrop;
            // Horizontal toward destination x
            const hx1 = fromX;
            const hy1 = midY;
            const hx2 = toX;
            const hy2 = midY;
            // Build path with rounded corners using quadratic curves
            // Start
            d += `M ${fromX} ${fromY}`;
            // Vertical down to just before corner
            d += ` L ${fromX} ${hy1 - r}`;
            // Corner: down->right (or down->left)
            const dir = (toX >= fromX) ? 1 : -1;
            d += ` Q ${fromX} ${hy1} ${fromX + dir * r} ${hy1}`;
            // Horizontal toward near the destination x
            d += ` L ${hx2 - dir * r} ${hy2}`;
            // Corner: right/left -> down
            d += ` Q ${hx2} ${hy2} ${hx2} ${hy2 + r}`;
            // Vertical down to target
            d += ` L ${toX} ${toY}`;
          } else if ((fromType === 'True' || fromType === 'False')) {
              if (!(toType === 'True' || toType === 'False')) {
              // From branch header to first branch node: orthogonal with side offset to avoid vertical-only
              const side = (fromType === 'True') ? -1 : 1; // push outward from center
              const hOffset = 40;
              const midY = fromY + 36;
              const hx1 = fromX + side * hOffset;
              const hx2 = Math.abs(toX - fromX) < 2 ? (toX - side * hOffset) : toX;
              d = `M ${fromX} ${fromY}`;
              d += ` L ${fromX} ${midY - r}`;
              d += ` Q ${fromX} ${midY} ${hx1} ${midY}`;
              d += ` L ${hx2} ${midY}`;
              d += ` Q ${toX} ${midY} ${toX} ${midY + r}`;
              d += ` L ${toX} ${toY}`;
            } else {
              // Fallback generic curve
              const mx = Math.round((fromX + toX) / 2);
              d = `M ${fromX} ${fromY} C ${mx} ${fromY}, ${mx} ${toY}, ${toX} ${toY}`;
            }
          } else {
            // Generic vertical line for non-IF connections to keep visuals stable
            d = `M ${fromX} ${fromY} L ${fromX} ${toY}`;
          }

          connection.line.setAttribute('d', d);
          logOrder(`updateConnectionPosition end from=${connection.from?.id} to=${connection.to?.id}`);
          connection.line.style.display = 'block';
          if (DEBUG_LINE_PATHS) {
            const fromId = connection.from.id;
            const toId = connection.to.id;
            const hasJoin = this.toNodeHasJoin(toType, connection) || this.toNodeIsImplicitJoin(connection);
            console.log(`Connection ${fromId}->${toId}: fromType=${fromType}, toType=${toType}, hasJoin=${hasJoin}, path=${d}`);
          }

          
          // Update insert orb position
          this.updateInsertOrbPosition(connection);
          // Update source-anchored orb position if present
          try { this.updateSourceInsertOrbPosition(connection); } catch {}
          
        } catch (error) {
          console.error('Error updating connection position:', error);
        }
      },

      // Create a source-anchored insert orb directly under the source node for join connections (idempotent)
      createSourceInsertOrb(connection) {
        try {
          if (!connection || !connection.from || !connection.to) return;
          const toData = (connection.to.__nodeData && connection.to.__nodeData.data) || (nodes.find(n => n.element === connection.to)?.data) || null;
          const isJoinTarget = !!(toData && toData.properties && toData.properties.joinForIfId) || (this.toNodeIsImplicitJoin && this.toNodeIsImplicitJoin(connection));
          if (!isJoinTarget) return;

          const id = connection.id;
          // Remove any existing source orb for this connection to keep idempotent
          try {
            const existing = container.querySelector(`.insert-action-orb[data-connection-id="${id}"][data-role="source"]`);
            if (existing) existing.remove();
          } catch {}

          const orb = document.createElement('div');
          orb.className = 'insert-action-orb';
          orb.dataset.connectionId = id;
          orb.dataset.role = 'source';
          orb.style.position = 'absolute';
          orb.style.width = '32px';
          orb.style.height = '32px';
          orb.style.background = 'linear-gradient(135deg, #34D399 0%, #10B981 100%)';
          orb.style.borderRadius = '50%';
          orb.style.display = 'flex';
          orb.style.alignItems = 'center';
          orb.style.justifyContent = 'center';
          orb.style.cursor = 'pointer';
          orb.style.zIndex = '25';
          orb.style.opacity = '0';
          orb.style.transform = 'translate(-50%, -50%) scale(0.8)';
          orb.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
          orb.style.boxShadow = '0 3px 8px rgba(52, 211, 153, 0.3)';
          orb.style.border = '2px solid rgba(255, 255, 255, 0.1)';
          orb.innerHTML = '<span class="material-icons-outlined" style="color:#1A2E29;font-size:1rem;">add</span>';

          orb.addEventListener('click', (e) => {
            e.stopPropagation();
            try { WorkflowManager.handleInsertOrbClick(connection); } catch {}
          });

          // Hover effects to match midpoint orbs
          orb.addEventListener('mouseenter', () => {
            orb.style.transform = 'translate(-50%, -50%) scale(1.1)';
            orb.style.boxShadow = '0 4px 12px rgba(52, 211, 153, 0.5)';
          });
          orb.addEventListener('mouseleave', () => {
            orb.style.transform = 'translate(-50%, -50%) scale(1)';
            orb.style.boxShadow = '0 3px 8px rgba(52, 211, 153, 0.3)';
          });

          container.appendChild(orb);
          // Position now and fade/scale in next frame
          this.updateSourceInsertOrbPosition(connection);
          requestAnimationFrame(() => { try { orb.style.opacity = '1'; orb.style.transform = 'translate(-50%, -50%) scale(1)'; } catch {} });
        } catch {}
      },

      // Update position for source-anchored insert orb
      updateSourceInsertOrbPosition(connection) {
        try {
          const id = connection?.id;
          if (!id) return;
          const orb = container.querySelector(`.insert-action-orb[data-connection-id="${id}"][data-role="source"]`);
          if (!orb) return;
          const fromRect = connection.from.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          const x = Math.round(fromRect.left - containerRect.left + fromRect.width / 2);
          const y = Math.round(fromRect.bottom - containerRect.top + 24); // 24px below the node bottom
          orb.style.left = `${x}px`;
          orb.style.top = `${y}px`;
          orb.style.transform = 'translate(-50%, -50%)';
        } catch {}
      },

      // helper: detect join target
      toNodeHasJoin(toType, connection) {
        try {
          if (!connection || !connection.to) return false;
          const toData = (connection.to.__nodeData && connection.to.__nodeData.data) || (nodes.find(n => n.element === connection.to)?.data) || null;
          const hasJoin = !!(toData && toData.properties && toData.properties.joinForIfId);
          logOrder(`toNodeHasJoin check to=${connection.to?.id} result=${hasJoin}`);
          if (DEBUG_LINE_PATHS) {
            console.log(`toNodeHasJoin: toData=`, toData, `hasJoin=${hasJoin}`);
          }
          return hasJoin;
        } catch { return false; }
      },

      // helper: detect implicit join target (no explicit joinForIfId, but two inbound lines from
      // true/false branches of the same If). This ensures proper orthogonal routing for visual joins.
      toNodeIsImplicitJoin(connection) {
        try {
          if (!connection || !connection.to) return false;
          const targetEl = connection.to;
          logOrder(`toNodeIsImplicitJoin check start to=${targetEl?.id}`);
          let parentIfIdToBranches = new Map();
          for (const c of this.connections.values()) {
            if (!c || c.to !== targetEl || !c.from) continue;
            const fromData = (c.from.__nodeData && c.from.__nodeData.data) || (nodes.find(n => n.element === c.from)?.data) || null;
            if (!fromData) continue;
            // Branch sources can be True/False headers or any actions with parentIfId+branch
            const fromType = fromData.type || '';
            let parentIfId = null;
            let branch = null;
            if (fromType === 'True' || fromType === 'False') {
              parentIfId = fromData?.properties?.parentIfId || null;
              branch = (fromType === 'True') ? 'true' : 'false';
            } else {
              parentIfId = fromData?.properties?.parentIfId || null;
              branch = fromData?.properties?.branch || null;
            }
            if (!parentIfId || !branch) continue;
            const set = parentIfIdToBranches.get(parentIfId) || new Set();
            set.add(branch);
            parentIfIdToBranches.set(parentIfId, set);
          }
          for (const [pid, branches] of parentIfIdToBranches.entries()) {
            if (branches.has('true') && branches.has('false')) {
              if (DEBUG_LINE_PATHS) {
                console.log('Implicit join detected for target', targetEl?.id, 'parentIfId', pid);
              }
              logOrder(`toNodeIsImplicitJoin true to=${targetEl?.id} ifId=${pid}`);
              return true;
            }
          }
          logOrder(`toNodeIsImplicitJoin false to=${targetEl?.id}`);
          return false;
        } catch { return false; }
      },

      isJoinNode(toEl) {
        try {
          const toData = (toEl && toEl.__nodeData && toEl.__nodeData.data) || (nodes.find(n => n.element === toEl)?.data) || null;
          return !!(toData && toData.properties && toData.properties.joinForIfId);
        } catch { return false; }
      },
      
      // Remove a specific connection
      removeConnection(connectionId) {
        logOrder(`WorkflowManager.removeConnection start id=${connectionId}`);
        const connection = this.connections.get(connectionId);
        if (connection) {
          if (connection.line && connection.line.parentNode) {
            connection.line.style.opacity = '0';
            setTimeout(() => {
              if (connection.line.parentNode) {
                connection.line.remove();
              }
            }, 300);
          }
          
          // Remove insert orb
          const insertOrb = this.insertOrbs.get(connectionId);
          if (insertOrb) {
            insertOrb.style.opacity = '0';
            insertOrb.style.transform = 'scale(0.8)';
            setTimeout(() => {
              if (insertOrb.parentNode) {
                insertOrb.remove();
              }
            }, 300);
            this.insertOrbs.delete(connectionId);
          }
          
          this.connections.delete(connectionId);
        }
        logOrder(`WorkflowManager.removeConnection end id=${connectionId}`);
      },
      
      // Remove connection between two specific nodes
      removeConnectionBetween(fromNode, toNode) {
        for (const [id, connection] of this.connections) {
          if ((connection.from === fromNode && connection.to === toNode) ||
              (connection.from === toNode && connection.to === fromNode)) {
            this.removeConnection(id);
            break;
          }
        }
      },
      
      // Remove all connections involving a node
      removeNodeConnections(node) {
        const connectionsToRemove = [];
        for (const [id, connection] of this.connections) {
          if (connection.from === node || connection.to === node) {
            connectionsToRemove.push(id);
          }
        }
        
        connectionsToRemove.forEach(id => this.removeConnection(id));
      },
      
      // Update all connection positions
      updateAllConnections() {
        logOrder(`WorkflowManager.updateAllConnections begin count=${this.connections.size}`);
        for (const connection of this.connections.values()) {
          this.updateConnectionPosition(connection);
        }
        logOrder('WorkflowManager.updateAllConnections end');
      },
      
      // Validate if a connection is valid
      isValidConnection(fromNode, toNode) {
        if (!fromNode || !toNode) return false;
        if (!fromNode.parentNode || !toNode.parentNode) return false;
        if (fromNode === toNode) return false;
        
        // Check if connection already exists
        for (const connection of this.connections.values()) {
          if ((connection.from === fromNode && connection.to === toNode) ||
              (connection.from === toNode && connection.to === fromNode)) {
            return false;
          }
        }
        
        return true;
      },
      
      // Get connections for a specific node
      getNodeConnections(node) {
        const nodeConnections = [];
        for (const connection of this.connections.values()) {
          if (connection.from === node || connection.to === node) {
            nodeConnections.push(connection);
          }
        }
        return nodeConnections;
      },
      
      // Clean up all connections
      cleanup() {
        for (const connection of this.connections.values()) {
          if (connection.line && connection.line.parentNode) {
            connection.line.remove();
          }
        }
        
        for (const insertOrb of this.insertOrbs.values()) {
          if (insertOrb.parentNode) {
            insertOrb.remove();
          }
        }
        
        this.connections.clear();
        this.insertOrbs.clear();
        // Clear SVG paths
        if (this.svg) {
          while (this.svg.firstChild) this.svg.removeChild(this.svg.firstChild);
        }
      }
    };
    // Production-grade Action Orb Management System
    const OrbManager = {
      orbs: new Map(), // key -> orb element; keys for regular: `${nodeId}:${position}`, for midpoints: `orb-${from}-${to}`
      debug: false,
      _rafPending: false,
      
      // Initialize the orb system
      init() {
        this.orbs.clear();
      },
      
      // Add an orb to a node
      addOrb(node, position = 'bottom') {
        logOrder(`OrbManager.addOrb start - node: ${node.id}, position: ${position}`);
        if (!this.isValidNode(node)) {
          logOrder(`OrbManager.addOrb skip - invalid node: ${node.id}`);
          return null;
        }
        // Never add a bottom orb under an If node
        try {
          const domElement = node.element || node;
          const stepType = (nodes.find(n => n.element === domElement)?.data?.type) || domElement?.dataset?.stepType || '';
          if (stepType === 'If' && position === 'bottom') {
            logOrder(`OrbManager.addOrb skip - If node bottom orb: ${node.id}`);
            return null;
          }
          // Also avoid adding a bottom orb if node currently has outgoing connections
          if (position === 'bottom') {
            try {
              for (const c of WorkflowManager.connections.values()) {
                if (c && c.from === domElement) {
                  logOrder(`OrbManager.addOrb skip - node has outgoing: ${node.id}`);
                  return null;
                }
              }
            } catch {}
          }
        } catch {}
        
        // Remove existing orb at same position if present
        const key = `${node.id}:${position}`;
        this.removeOrbById(key);
        logOrder(`OrbManager.addOrb create orb: ${key}`);
        
        const orb = this.createOrbElement(node.id, position);
        this.orbs.set(key, orb);
        
        // Pass the DOM element to positionOrb (handle both node objects and DOM elements)
        const domElement = node.element || node;
        this.positionOrb(orb, domElement, position);
        container.appendChild(orb);
        
        logOrder(`OrbManager.addOrb complete: ${node.id} ${position}`);
        return orb;
      },
      
      // Add orb at the exact midpoint between two nodes
      addOrbAtMidpoint(fromNode, toNode) {
        if (!this.isValidNode(fromNode) || !this.isValidNode(toNode)) {
          logOrder(`OrbManager.addOrbAtMidpoint skip - invalid nodes: ${fromNode?.id} -> ${toNode?.id}`);
          return null;
        }
        
        const orbId = `orb-${fromNode.id}-${toNode.id}`;
        logOrder(`OrbManager.addOrbAtMidpoint create: ${fromNode.id} -> ${toNode.id}`);
        
        // Remove existing orb if it exists
        this.removeOrbById(orbId);
        
        const orb = this.createOrbElement(orbId, 'midpoint');
        this.orbs.set(orbId, orb);
        
        // Pass the DOM elements to positionOrbAtMidpoint (handle both node objects and DOM elements)
        const fromDomElement = fromNode.element || fromNode;
        const toDomElement = toNode.element || toNode;
        this.positionOrbAtMidpoint(orb, fromDomElement, toDomElement);
        container.appendChild(orb);
        
        logOrder(`OrbManager.addOrbAtMidpoint complete: ${orbId}`);
        return orb;
      },
      
      // Create the orb element
      createOrbElement(nodeId, position) {
        const orb = document.createElement('div');
        orb.className = 'add-action-orb';
        orb.dataset.nodeId = nodeId;
        orb.dataset.position = position;
        orb.style.cssText = `
          position: absolute;
          width: 40px;
          height: 40px;
          background: linear-gradient(135deg, #34D399 0%, #10B981 100%);
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          z-index: 20;
          opacity: 0;
          transform: scale(1);
          transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
          box-shadow: 0 4px 12px rgba(52, 211, 153, 0.3);
          border: 2px solid rgba(255, 255, 255, 0.1);
        `;
        
        orb.innerHTML = `
          <span class="material-icons-outlined" style="color: #1A2E29; font-size: 1.25rem;">add</span>
        `;
        
        // Add click handler
        orb.addEventListener('click', (e) => {
          e.stopPropagation();
          this.handleOrbClick(nodeId, position);
        });
        
        // Add drag-to-connect functionality only for bottom orbs (big orbs at branch ends)
        if (position === 'bottom') {
          this.addDragToConnect(orb, nodeId, position);
        }
        
        // Determine base transform for positioning
        const baseTransform = (
          position === 'midpoint' ? 'translate(-50%, -50%)' :
          position === 'bottom' ? 'translate(-50%, 0)' :
          position === 'top' ? 'translate(-50%, -100%)' :
          position === 'right' ? 'translate(0, -50%)' :
          position === 'left' ? 'translate(-100%, -50%)' :
          'translate(-50%, 0)'
        );

        // Add hover effects (preserve base transform)
        orb.addEventListener('mouseenter', () => {
          orb.style.transform = `${baseTransform} scale(1.1)`;
          orb.style.boxShadow = '0 6px 20px rgba(52, 211, 153, 0.5)';
        });
        
        orb.addEventListener('mouseleave', () => {
          orb.style.transform = `${baseTransform} scale(1)`;
          orb.style.boxShadow = '0 4px 12px rgba(52, 211, 153, 0.3)';
        });
        
        // Animate in (preserve base transform)
        requestAnimationFrame(() => {
          orb.style.opacity = '1';
          orb.style.transform = `${baseTransform} scale(1)`;
        });
        
        return orb;
      },
      
      // Position the orb relative to its node with robust positioning
      positionOrb(orb, node, position) {
        if (!orb || !node) {
          return;
        }
        
        try {
          // Get node position relative to container (exact same basis as line math)
          const nodeRect = node.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          
          if (!nodeRect || !containerRect) {
            return;
          }
          
          // Calculate relative positions (container-local) matching line computation
          const nodeLeft = Math.round(nodeRect.left - containerRect.left);
          const nodeTop = Math.round(nodeRect.top - containerRect.top);
          const nodeRight = Math.round(nodeRect.right - containerRect.left);
          const nodeBottom = Math.round(nodeRect.bottom - containerRect.top);
          const nodeWidth = nodeRect.width;
          const nodeHeight = nodeRect.height;
          
          // Calculate position based on placement (in local space)
          let left, top, transform;
          
          switch (position) {
            case 'bottom':
              // Exact center horizontally under the node (identical to line start X)
              left = Math.round(nodeLeft + (nodeWidth / 2));
              top = Math.round(nodeBottom + 20); // spacing below node
              transform = 'translate(-50%, 0)';
              break;
              
            case 'top':
              // True center horizontally above the node; position baseline at nodeTop-20 and lift by 100%
              left = Math.round(nodeLeft + (nodeWidth / 2));
              top = Math.round(nodeTop - 20);
              transform = 'translate(-50%, -100%)';
              break;
              
            case 'right':
              // Center vertically, place to the right with proper spacing
              left = Math.round(nodeRight + 20);
              top = Math.round(nodeTop + (nodeHeight / 2));
              transform = 'translate(0, -50%)';
              break;
              
            case 'left':
              // Center vertically, place to the left with proper spacing
              left = Math.round(nodeLeft - 20);
              top = Math.round(nodeTop + (nodeHeight / 2));
              transform = 'translate(-100%, -50%)';
              break;
              
            default:
              console.warn('OrbManager.positionOrb: Unknown position:', position);
              // Default to bottom
              left = Math.round(nodeLeft + (nodeWidth / 2));
              top = Math.round(nodeBottom + 20);
              transform = 'translate(-50%, 0)';
          }
          
          // Ensure orb stays within container bounds (with padding) in the same coordinate space
          const containerPadding = 20;
          const maxLeft = containerRect.width - containerPadding;
          const maxTop = containerRect.height - containerPadding;
          
          left = Math.max(containerPadding, Math.min(Math.round(left), maxLeft));
          top = Math.max(containerPadding, Math.min(Math.round(top), maxTop));
          
          // Apply positioning
          orb.style.left = `${left}px`;
          orb.style.top = `${top}px`;
          if (transform) orb.style.transform = transform;
          
          
        } catch (error) {
          // Fallback positioning
          orb.style.left = '50%';
          orb.style.top = '50%';
          orb.style.transform = 'translate(-50%, -50%)';
        }
      },
      
      // Position orb at the exact midpoint of the connection line
      positionOrbAtMidpoint(orb, fromNode, toNode) {
        if (!orb || !fromNode || !toNode) {
          return;
        }
        
        try {
          // Get node positions relative to container (same logic as connection lines), in local space
          const fromRect = fromNode.getBoundingClientRect();
          const toRect = toNode.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          let _scale = 1;
          try { const m = (container.style.transform || '').match(/scale\(([-\d.]+)\)/); if (m) _scale = parseFloat(m[1]) || 1; } catch {}
          const toLocalX = (vx) => (vx - containerRect.left) / _scale;
          const toLocalY = (vy) => (vy - containerRect.top) / _scale;
          
          if (!fromRect || !toRect || !containerRect) {
            return;
          }
          
          // Calculate connection points (exactly like connection lines) in local space
          const fromX = Math.round(toLocalX(fromRect.left + fromRect.width / 2));
          const fromY = Math.round(toLocalY(fromRect.bottom) - 1);
          const toX = Math.round(toLocalX(toRect.left + toRect.width / 2));
          const toY = Math.round(toLocalY(toRect.top) + 1);
          
          // Calculate midpoint of the connection line
          const midpointX = (fromX + toX) / 2;
          const midpointY = (fromY + toY) / 2;
          
          // Position orb at midpoint (centered on the connection line)
          orb.style.left = `${midpointX}px`;
          orb.style.top = `${midpointY}px`;
          orb.style.transform = 'translate(-50%, -50%)';
          
          
        } catch (error) {
          // Fallback positioning
          orb.style.left = '50%';
          orb.style.top = '50%';
          orb.style.transform = 'translate(-50%, -50%)';
        }
      },
      
      // Remove orb by ID
      removeOrbById(orbId) {
        const orb = this.orbs.get(orbId);
        if (orb) {
          orb.remove();
          this.orbs.delete(orbId);
        }
      },
      
      // Remove orb from a node
      removeOrbs(node) {
        if (!node) return;
        const keys = [];
        for (const [k, orb] of Array.from(this.orbs.entries())) {
          if (k.startsWith(`${node.id}:`)) {
            keys.push(k);
            if (orb && orb.parentNode) {
              orb.style.opacity = '0';
              orb.style.transform = 'scale(0.8)';
              setTimeout(() => { if (orb.parentNode) orb.remove(); }, 300);
            }
            this.orbs.delete(k);
          }
        }
      },

      // Backward-compatible: remove any orbs associated with a target element or node
      removeOrb(target) {
        if (!target) return;
        const id = (target.id) || (target.element && target.element.id) || null;
        if (!id) return;
        const keys = [];
        for (const [k, orb] of Array.from(this.orbs.entries())) {
          if (k.startsWith(`${id}:`)) {
            keys.push(k);
            try { if (orb && orb.parentNode) orb.remove(); } catch {}
            this.orbs.delete(k);
          }
        }
      },
      
      // Remove all orbs
      removeAllOrbs() {
        for (const orb of this.orbs.values()) {
          if (orb.parentNode) {
            orb.remove();
          }
        }
        this.orbs.clear();
      },
      
      // Update orb positions for all nodes (handled comprehensively below)
      
      // Handle orb click
      handleOrbClick(nodeId, position) {
        // For IF nodes, left orb = true path, right orb = false path
        try {
          const node = nodes.find(n => n.id === nodeId);
          if (node && node.data && node.data.type === 'If' && (position === 'left' || position === 'right')) {
            const prefix = position === 'left' ? 'branch-true-' : 'branch-false-';
            openActionModal(`${prefix}${nodeId}`);
            return;
          }
        } catch {}
        // Default: add after
        openActionModal(`add-after-${nodeId}`);
      },
      
      // Add drag-to-connect functionality to an orb
      addDragToConnect(orb, nodeId, position) {
        let dragStartX = 0;
        let dragStartY = 0;
        // ensure a single shared drag context on the manager
        if (!this.dragContext) this.dragContext = null;
        
        orb.addEventListener('mousedown', (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          // Start from the visual center of the orb
          const orbRect = orb.getBoundingClientRect();
          dragStartX = Math.round(orbRect.left + orbRect.width / 2);
          dragStartY = Math.round(orbRect.top + orbRect.height / 2);
          
          // Find source node
          const sourceNode = nodes.find(n => n.id === nodeId);
          if (!sourceNode) return;
          
          // Create drag line
          const dragLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          dragLine.setAttribute('stroke', '#34D399');
          dragLine.setAttribute('stroke-width', '3');
          dragLine.setAttribute('stroke-dasharray', '5,5');
          dragLine.setAttribute('fill', 'none');
          dragLine.style.pointerEvents = 'none';
          
          if (!WorkflowManager.svg) {
            try { WorkflowManager.init(); } catch {}
          }
          if (WorkflowManager.svg) {
            WorkflowManager.svg.appendChild(dragLine);
          }
          
          // Compute fixed start relative to SVG (or container) to avoid origin jumps
          const baseRect = (WorkflowManager.svg && typeof WorkflowManager.svg.getBoundingClientRect === 'function')
            ? WorkflowManager.svg.getBoundingClientRect()
            : container.getBoundingClientRect();
          const startXRel = dragStartX - baseRect.left;
          const startYRel = dragStartY - baseRect.top;
          
          // Save drag context
          this.dragContext = { sourceNode, dragLine, startXRel, startYRel };

          // Set initial line position at the orb center
          this.updateDragLine(dragStartX, dragStartY);
          
          orb.style.cursor = 'grabbing';
        });
        
        document.addEventListener('mousemove', (e) => {
          const ctx = this.dragContext;
          if (!ctx || !ctx.dragLine) return;
          this.updateDragLine(e.clientX, e.clientY);
        });
        
        document.addEventListener('mouseup', (e) => {
          const ctx = this.dragContext;
          if (!ctx || !ctx.dragLine) return;
          orb.style.cursor = 'pointer';
          
          // Check if there was actual drag movement (not just a click)
          const dragDistance = Math.sqrt(
            Math.pow(e.clientX - dragStartX, 2) + Math.pow(e.clientY - dragStartY, 2)
          );
          
          // Clean up drag line
          if (ctx.dragLine && ctx.dragLine.parentNode) {
            ctx.dragLine.parentNode.removeChild(ctx.dragLine);
          }
          const sourceNodeLocal = ctx.sourceNode;
          this.dragContext = null;
          
          // Only handle as drag if there was significant movement (more than 5 pixels)
          if (dragDistance > 5) {
            // Find drop target
            const dropTarget = this.findDropTarget(e.clientX, e.clientY);
            if (dropTarget && sourceNodeLocal) {
              this.handleOrbDrop(sourceNodeLocal, dropTarget, e.clientX, e.clientY);
            }
          }
        });
      },
      
      // Update drag line position
      updateDragLine(clientX, clientY) {
        const ctx = this.dragContext;
        if (!ctx || !ctx.dragLine || !ctx.sourceNode) return;
        
        try {
          const baseRect = (WorkflowManager.svg && typeof WorkflowManager.svg.getBoundingClientRect === 'function')
            ? WorkflowManager.svg.getBoundingClientRect()
            : container.getBoundingClientRect();
          // Always use fixed start relative to base rect
          const startX = (typeof ctx.startXRel === 'number') ? ctx.startXRel : 0;
          const startY = (typeof ctx.startYRel === 'number') ? ctx.startYRel : 0;
          let endX = clientX - baseRect.left;
          let endY = clientY - baseRect.top;
          // Clamp end within bounds
          const width = Math.max(0, (WorkflowManager.svg?.clientWidth || container.clientWidth || 0));
          const height = Math.max(0, (WorkflowManager.svg?.clientHeight || container.clientHeight || 0));
          if (width && height) {
            endX = Math.max(0, Math.min(endX, width));
            endY = Math.max(0, Math.min(endY, height));
          }
          
          const path = `M ${startX} ${startY} L ${endX} ${endY}`;
          ctx.dragLine.setAttribute('d', path);
        } catch {}
      },
      
      // Find valid drop target at coordinates (only bottom orbs)
      findDropTarget(clientX, clientY) {
        const ctx = this.dragContext;
        const elements = document.elementsFromPoint(clientX, clientY);
        
        for (const element of elements) {
          // Check if it's a bottom orb (big orb at branch end)
          if (element.classList.contains('add-action-orb') && element.dataset.position === 'bottom') {
            const targetNodeId = element.dataset.nodeId;
            const targetNode = nodes.find(n => n.id === targetNodeId);
            if (targetNode && (!ctx || targetNode !== ctx.sourceNode)) {
              return targetNode;
            }
          }
        }
        
        return null;
      },
      
      // Handle orb drop and open action modal
      handleOrbDrop(sourceNode, targetNode, clientX, clientY) {
        try {
          logOrder(`handleOrbDrop called: ${sourceNode?.id} -> ${targetNode?.id}`);
          // Store drag context for insertion
          window.orbDragContext = {
            sourceNode: sourceNode,
            targetNode: targetNode,
            clientX: clientX,
            clientY: clientY
          };
          
          // Open action modal with special context
          openActionModal('orb-connect');
        } catch (e) {
          console.warn('Orb drop failed:', e);
        }
      },
      
      // Check if node is valid for orb
      isValidNode(node) {
        return node && node.id && (node.element || node.parentNode);
      },
      
      // Get orb for a node
      getOrb(node) {
        if (!node) return null;
        const key = Array.from(this.orbs.keys()).find(k => String(k).startsWith(`${node.id}:`));
        return key ? this.orbs.get(key) : null;
      },
      
      // Check if node has an orb
      hasOrb(node) {
        if (!node) return false;
        return Array.from(this.orbs.keys()).some(k => String(k).startsWith(`${node.id}:`));
      },
      
      // Update all orb positions (handles both regular and midpoint orbs), rAF-batched with cached rects
      updateAllOrbPositions() {
        if (this._rafPending) return;
        this._rafPending = true;
        requestAnimationFrame(() => {
          try {
            const containerRect = container.getBoundingClientRect();
            // Build id -> element map once
            const idToEl = new Map();
            for (const n of nodes) { if (n && n.id && n.element) idToEl.set(n.id, n.element); }
            // Rect cache in container-local coordinates
            const rectCache = new Map();
            const getRect = (el) => {
              let r = rectCache.get(el);
              if (!r) {
                const rr = el.getBoundingClientRect();
                r = {
                  left: rr.left - containerRect.left,
                  top: rr.top - containerRect.top,
                  width: rr.width,
                  height: rr.height,
                  right: rr.right - containerRect.left,
                  bottom: rr.bottom - containerRect.top,
                };
                rectCache.set(el, r);
              }
              return r;
            };
            const orbSize = 40;
            const orbHalf = orbSize / 2;
            const pad = 20;
            const maxLeft = containerRect.width - orbSize - pad;
            const maxTop = containerRect.height - orbSize - pad;
            this.orbs.forEach((orb, orbId) => {
              const position = orb.dataset.position;
              if (position === 'midpoint') {
                const nodeIdPart = String(orbId).replace('orb-', '');
                const parts = nodeIdPart.split('-');
                if (parts.length >= 4) {
                  const fromNodeId = `${parts[0]}-${parts[1]}`;
                  const toNodeId = `${parts[2]}-${parts[3]}`;
                  const fromEl = idToEl.get(fromNodeId) || document.getElementById(fromNodeId);
                  const toEl = idToEl.get(toNodeId) || document.getElementById(toNodeId);
                  if (fromEl && toEl) {
                    const fr = getRect(fromEl);
                    const tr = getRect(toEl);
                    const fromX = Math.round(fr.left + fr.width / 2);
                    const fromY = Math.round(fr.bottom - 1);
                    const toX = Math.round(tr.left + tr.width / 2);
                    const toY = Math.round(tr.top + 1);
                    const midX = (fromX + toX) / 2;
                    const midY = (fromY + toY) / 2;
                const left = Math.round(midX);
                const top = Math.round(midY);
                    const leftPx = `${left}px`;
                    const topPx = `${top}px`;
                    if (orb.style.left !== leftPx) orb.style.left = leftPx;
                    if (orb.style.top !== topPx) orb.style.top = topPx;
                    if (orb.style.transform !== 'translate(-50%, -50%)') orb.style.transform = 'translate(-50%, -50%)';
                  }
                }
              } else {
                const nodeId = String(orbId).includes(':') ? String(orbId).split(':')[0] : String(orbId);
                const nodeEl = idToEl.get(nodeId) || document.getElementById(nodeId);
                if (!nodeEl) return;
                const nr = getRect(nodeEl);
                let left, top, transform;
                switch (position) {
                  case 'bottom':
                    left = nr.left + (nr.width / 2);
                    top = nr.top + nr.height + 20;
                    transform = 'translate(-50%, 0)';
                    break;
                  case 'top':
                    left = nr.left + (nr.width / 2);
                    top = nr.top - 20;
                    transform = 'translate(-50%, -100%)';
                    break;
                  case 'right':
                    left = nr.left + nr.width + 20;
                    top = nr.top + (nr.height / 2);
                    transform = 'translate(0, -50%)';
                    break;
                  case 'left':
                    left = nr.left - 20;
                    top = nr.top + (nr.height / 2);
                    transform = 'translate(-100%, -50%)';
                    break;
                  default:
                    left = nr.left + (nr.width / 2);
                    top = nr.top + nr.height + 20;
                    transform = 'translate(-50%, 0)';
                }
            // Snap to integer pixels to avoid subpixel jitter when panning/zooming
            left = Math.round(left);
            top = Math.round(top);
                left = Math.max(pad, Math.min(left, maxLeft));
                top = Math.max(pad, Math.min(top, maxTop));
                const leftPx = `${left}px`;
                const topPx = `${top}px`;
                if (orb.style.left !== leftPx) orb.style.left = leftPx;
                if (orb.style.top !== topPx) orb.style.top = topPx;
                if (transform && orb.style.transform !== transform) orb.style.transform = transform;
              }
            });
          } finally {
            this._rafPending = false;
          }
        });
      },
      
      // Clean up all orbs
      cleanup() {
        this.removeAllOrbs();
      }
    };
    // Workflow Structure Manager - orchestrates connections and orbs
    const StructureManager = {
      rebuildTimeout: null,
      layoutApplied: false,
    
    // Compute and place bottom orbs at the end of each branch (only on true leaves)
    placePathEndOrbs(sortedNodes) {
      try {
        logOrder('StructureManager.placePathEndOrbs start');
        // Helper: a candidate is any node except trigger and If (True/False allowed)
        const isCandidateNode = (n) => {
          if (!n || !n.element) return false;
          if (n.type === 'trigger') return false;
          const t = n.data?.type || '';
          return (t !== 'If');
        };
        // Build a quick set of node elements for candidate filtering
        const candidateNodes = nodes.filter(isCandidateNode);
        const elSet = new Set(candidateNodes.map(n => n.element));

        // Compute desired orbs first, then diff against existing ones
        const desiredOrbs = new Set();

        // Build out-degree map by element id to robustly detect leaves
        const outById = new Map();
        try {
            for (const c of WorkflowManager.connections.values()) {
            if (c && c.from && c.from.id) {
              const k = c.from.id;
              outById.set(k, (outById.get(k) || 0) + 1);
            }
          }
        } catch {}

        // Determine which nodes should have bottom orbs (true leaves)
        for (const n of candidateNodes) {
          try {
            const el = n.element;
            const id = el && el.id;
            let hasOut = id ? ((outById.get(id) || 0) > 0) : false;
            // Fallback guard for True/False headers: if branch has any action nodes, treat as non-leaf
            if (!hasOut) {
              const t = n.data?.type || '';
              if (t === 'True' || t === 'False') {
                try {
                  const pid = n.data?.properties?.parentIfId;
                  const branch = (n.data?.properties?.branch) || (t === 'True' ? 'true' : 'false');
                  if (pid) {
                    const hasBranchAction = nodes.some(m => {
                      const dt = m.data?.type || '';
                      const p = m.data?.properties || {};
                      return (dt && dt !== 'If' && dt !== 'True' && dt !== 'False' && p.parentIfId === pid && p.branch === branch);
                    });
                    if (hasBranchAction) hasOut = true;
                  }
                } catch {}
              }
            }
            if (!hasOut && id) {
              desiredOrbs.add(`${id}:bottom`);
          }
        } catch {}
        }

        // Fallback: if there are no candidate nodes and only a trigger exists, place under trigger
        if (desiredOrbs.size === 0 && candidateNodes.length === 0) {
          const triggerNode = nodes.find(n => n && (n.type === 'trigger' || n.data?.type === 'trigger'));
          if (triggerNode && triggerNode.element) {
            desiredOrbs.add(`${triggerNode.element.id}:bottom`);
          }
        }

        // Remove extra orbs (not in desired set)
        for (const key of Array.from(OrbManager.orbs.keys())) {
          if (String(key).endsWith(':bottom') && !desiredOrbs.has(key)) {
            try { OrbManager.removeOrbById(key); } catch {}
          }
        }

        // Additionally remove any bottom orbs on nodes that now have outgoing connections
        try {
          for (const key of Array.from(OrbManager.orbs.keys())) {
            if (!String(key).endsWith(':bottom')) continue;
            const nodeId = String(key).replace(':bottom', '');
            const node = nodes.find(n => n.element && n.element.id === nodeId);
            if (!node || !node.element) continue;
            const hasOutgoing = (() => {
              try {
                for (const c of WorkflowManager.connections.values()) {
                  if (c && c.from === node.element) return true;
                }
              } catch {}
              return false;
            })();
            if (hasOutgoing) {
              try { OrbManager.removeOrbById(key); } catch {}
            }
          }
        } catch {}

        // Add missing orbs (in desired set but not existing)
        for (const key of desiredOrbs) {
          if (!OrbManager.orbs.has(key)) {
            const nodeId = key.replace(':bottom', '');
            const node = nodes.find(n => n.element && n.element.id === nodeId);
            if (node && node.element) {
              // Final guard: do not add if there are outgoing connections right now
              let hasOutgoing = false;
              try {
                for (const c of WorkflowManager.connections.values()) {
                  if (c && c.from === node.element) { hasOutgoing = true; break; }
                }
              } catch {}
              if (hasOutgoing) continue;
              try { OrbManager.addOrb(node.element, 'bottom'); } catch {}
            }
          }
        }
        
        // Deterministic branch-end orbs for each If block:
        // ensure a bottom orb exists for the last element of each True/False branch,
        // or on the header if the branch is empty. This avoids race conditions with connections.
        try {
          const ifNodes = nodes.filter(n => n?.data?.type === 'If' && n?.data?.properties?.ifId);
          const getTop = (n) => {
            if (!n || !n.element) return 0;
            if (n._layout && typeof n._layout.top === 'number') return n._layout.top;
            const t = parseFloat(n.element.style.top || '0');
            return Number.isFinite(t) ? t : 0;
          };
          for (const ifNode of ifNodes) {
            const ifId = ifNode.data.properties.ifId;
            // Collect branch members including headers
            const branchNodes = nodes.filter(m => m?.data?.properties?.parentIfId === ifId);
            const trueHeader = branchNodes.find(m => m?.data?.type === 'True');
            const falseHeader = branchNodes.find(m => m?.data?.type === 'False');
            const trueMembers = branchNodes.filter(m => m?.data?.properties?.branch === 'true' && m?.data?.type !== 'If');
            const falseMembers = branchNodes.filter(m => m?.data?.properties?.branch === 'false' && m?.data?.type !== 'If');
            const trueLast = (trueMembers.length ? trueMembers : (trueHeader ? [trueHeader] : []))
              .slice().sort((a,b) => getTop(a) - getTop(b)).pop();
            const falseLast = (falseMembers.length ? falseMembers : (falseHeader ? [falseHeader] : []))
              .slice().sort((a,b) => getTop(a) - getTop(b)).pop();
            if (trueLast && trueLast.element) {
              const key = `${trueLast.element.id}:bottom`;
              if (!OrbManager.orbs.has(key)) {
                try { OrbManager.addOrb(trueLast.element, 'bottom'); } catch {}
              }
            }
            if (falseLast && falseLast.element) {
              const key = `${falseLast.element.id}:bottom`;
              if (!OrbManager.orbs.has(key)) {
                try { OrbManager.addOrb(falseLast.element, 'bottom'); } catch {}
              }
            }
          }
        } catch {}
      } catch (e) {
      }
    },
      
      // Rebuild the entire workflow structure with debouncing
      rebuild(callback = null) {
        if (typeof suspendRebuild !== 'undefined' && suspendRebuild) {
          // Defer rebuild until suspension lifted
          this.rebuildPendingCallback = callback || this.rebuildPendingCallback || null;
          return;
        }
        // Clear any pending rebuild
        if (this.rebuildTimeout) {
          clearTimeout(this.rebuildTimeout);
        }
        
        // Debounce rebuilds to prevent multiple rapid calls
        this.rebuildTimeout = setTimeout(() => {
          this.performRebuild(callback);
        }, 50);
      },
      
      // Perform the actual rebuild
      performRebuild(callback = null) {
        logOrder('StructureManager.performRebuild start');
        let _cbCalled = false;
        const safeCallback = () => { if (callback && !_cbCalled) { _cbCalled = true; try { callback(); } catch {} } };
        try {
          // Don't rebuild if there are no nodes
          if (nodes.length === 0) {
            logOrder('StructureManager.performRebuild no-nodes');
            safeCallback();
            return;
          }

          // Apply deterministic layout before wiring connections/orbs
          logOrder('StructureManager.performRebuild before LayoutManager.apply');
          LayoutManager.apply();
          logOrder('StructureManager.performRebuild after LayoutManager.apply');

        // If there's only a trigger, just add an orb below it
          if (nodes.length === 1) {
          logOrder('StructureManager.performRebuild single-node path');
          
          // Clean up existing orbs first to prevent duplicates
          OrbManager.cleanup();
          
          const triggerNode = nodes[0];
          if (triggerNode && triggerNode.element) {
            OrbManager.addOrb(triggerNode, 'bottom');
          }
            safeCallback();
            return;
          }
        
        // Clean up existing structure
        logOrder('StructureManager.performRebuild cleanup managers');
        WorkflowManager.cleanup();
        OrbManager.cleanup();
        
        // Sort nodes by vertical position to ensure proper order; prefer persisted layout from layout pass
        const sortedNodes = [...nodes].sort((a, b) => {
          const at = (a && a._layout && typeof a._layout.top === 'number') ? a._layout.top : parseFloat(a?.element?.style?.top || '0');
          const bt = (b && b._layout && typeof b._layout.top === 'number') ? b._layout.top : parseFloat(b?.element?.style?.top || '0');
          return (at - bt);
        });
        logOrder(`StructureManager.performRebuild sortedNodes=${sortedNodes.length}`);
        
        // Force create implicit join connections for any IF blocks
        try {
          logOrder('StructureManager.performRebuild implicit-join pass begin');
          const ifNodes = sortedNodes.filter(n => n?.data?.type === 'If');
          for (const ifNode of ifNodes) {
            const ifId = ifNode.data?.properties?.ifId;
            if (!ifId) continue;
            
            // Find last actions in each branch
            const trueActions = sortedNodes.filter(n => 
              n?.data?.properties?.parentIfId === ifId && 
              n?.data?.properties?.branch === 'true'
            );
            const falseActions = sortedNodes.filter(n => 
              n?.data?.properties?.parentIfId === ifId && 
              n?.data?.properties?.branch === 'false'
            );
            
            if (trueActions.length > 0 && falseActions.length > 0) {
              // Find the combining action (first non-branch node after this IF)
              let combiningAction = null;
              const ifIndex = sortedNodes.indexOf(ifNode);
              for (let j = ifIndex + 1; j < sortedNodes.length; j++) {
                const node = sortedNodes[j];
                if (!node?.data) continue;
                if (node.data.type === 'If') break; // Stop at next IF
                if (node.data.type === 'True' || node.data.type === 'False') continue;
                if (node.data.properties?.parentIfId === ifId) continue; // Skip branch actions
                combiningAction = node;
                break;
              }
              
              if (combiningAction) {
                const lastTrue = trueActions[trueActions.length - 1];
                const lastFalse = falseActions[falseActions.length - 1];
                
                console.log(`[FORCE JOIN] Creating connections:`, {
                  lastTrue: lastTrue?.element?.id,
                  lastFalse: lastFalse?.element?.id,
                  combiningAction: combiningAction?.element?.id,
                  ifId: ifId
                });
                
                if (lastTrue?.element) {
                  WorkflowManager.createConnection(lastTrue.element, combiningAction.element, false);
                }
                if (lastFalse?.element) {
                  WorkflowManager.createConnection(lastFalse.element, combiningAction.element, false);
                }
              }
            }
          }
        } catch (e) {
          console.error('Error creating implicit join connections:', e);
        }
        logOrder('StructureManager.performRebuild implicit-join pass end');
        
        // Also try to create connections manually if rebuild didn't work
        try {
          const node6 = nodes.find(n => n.element?.id === 'node-6');
          const node5 = nodes.find(n => n.element?.id === 'node-5');
          const node8 = nodes.find(n => n.element?.id === 'node-8');
          
          if (node6 && node8) {
            console.log('[MANUAL JOIN] Creating node-6 -> node-8');
            WorkflowManager.createConnection(node6.element, node8.element, false);
          }
          if (node5 && node8) {
            console.log('[MANUAL JOIN] Creating node-5 -> node-8');
            WorkflowManager.createConnection(node5.element, node8.element, false);
          }
        } catch (e) {
          console.error('Error creating manual join connections:', e);
        }
        
        // Rebuild connections honoring If branching with True/False headers
        logOrder('StructureManager.performRebuild wiring pass begin');
        const isControl = (n) => !!(n && n.data && (n.data.type === 'True' || n.data.type === 'False'));
        const findIfHeaders = (startIdx) => {
          let trueIdx = -1, falseIdx = -1;
          for (let j = startIdx + 1; j < sortedNodes.length; j++) {
            const t = sortedNodes[j]?.data?.type;
            if (t === 'If') break; // stop at next IF block
            if (t === 'True' && trueIdx === -1) trueIdx = j;
            if (t === 'False' && falseIdx === -1) falseIdx = j;
            if (trueIdx !== -1 && falseIdx !== -1) break;
          }
          return { trueIdx, falseIdx };
        };

        // Removed auto-header recreation; we'll address root causes and guard orb placement instead

        const visited = new Set();
        for (let i = 0; i < sortedNodes.length; i++) {
          if (visited.has(i)) continue;
          const node = sortedNodes[i];
          const type = node?.data?.type || '';
          // Handle If block with two branches
          if (type === 'If') {
            console.debug('[IF][REBUILD] processing IF', { index: i, id: node.id });
            const { trueIdx, falseIdx } = findIfHeaders(i);
            console.debug('[IF][REBUILD] headers', { trueIdx, falseIdx });
            // Force-place True/False headers below IF using live DOM rects
            try {
              const ifEl = node.element;
              const cRect = container.getBoundingClientRect();
              const ifRect = ifEl.getBoundingClientRect();
              const ifBottomLocal = ifRect.bottom - cRect.top;
              const headerGap = 80;
              if (trueIdx !== -1) {
                const hEl = sortedNodes[trueIdx].element;
                hEl.style.top = `${Math.round(ifBottomLocal + headerGap)}px`;
                hEl.style.transform = 'translateX(-50%)';
              }
              if (falseIdx !== -1) {
                const hEl = sortedNodes[falseIdx].element;
                hEl.style.top = `${Math.round(ifBottomLocal + headerGap)}px`;
                hEl.style.transform = 'translateX(-50%)';
              }
            } catch {}
            // Connect If -> True/False headers when present
            if (trueIdx !== -1) {
              WorkflowManager.createConnection(node.element, sortedNodes[trueIdx].element, false);
            }
            if (falseIdx !== -1) {
              WorkflowManager.createConnection(node.element, sortedNodes[falseIdx].element, false);
            }

            // Chain within branches: find actions tagged with this IF
            const ifId = node.data?.properties?.ifId;
            if (ifId) {
              const trueBranch = [];
              const falseBranch = [];
              for (let j = i + 1; j < sortedNodes.length; j++) {
                const d = sortedNodes[j]?.data;
                if (!d) continue;
                // If we hit a new top-level IF (no parent linkage), stop scanning this block
                if (d.type === 'If' && (!d.properties || !d.properties.parentIfId)) break;
                // Skip headers
                if (d.type === 'True' || d.type === 'False') continue;
                if (d.properties && d.properties.parentIfId === ifId) {
                  if (d.properties.branch === 'true') trueBranch.push(j);
                  if (d.properties.branch === 'false') falseBranch.push(j);
                }
              }
              // Connect headers to first branch node
            if (trueIdx !== -1 && trueBranch.length > 0) {
              WorkflowManager.createConnection(sortedNodes[trueIdx].element, sortedNodes[trueBranch[0]].element, false);
            }
            if (falseIdx !== -1 && falseBranch.length > 0) {
              WorkflowManager.createConnection(sortedNodes[falseIdx].element, sortedNodes[falseBranch[0]].element, false);
            }
              // Chain within
              for (let k = 0; k < trueBranch.length - 1; k++) WorkflowManager.createConnection(sortedNodes[trueBranch[k]].element, sortedNodes[trueBranch[k + 1]].element, false);
              for (let k = 0; k < falseBranch.length - 1; k++) WorkflowManager.createConnection(sortedNodes[falseBranch[k]].element, sortedNodes[falseBranch[k + 1]].element, false);

              // If a join node exists for this IF, connect last branch nodes to the join node
              try {
                const joinNodes = sortedNodes.filter(n => n && n.data && n.data.properties && n.data.properties.joinForIfId === ifId);
                if (joinNodes.length > 0) {
                  const lastTrueEl = (trueBranch.length > 0)
                    ? sortedNodes[trueBranch[trueBranch.length - 1]].element
                    : (trueIdx !== -1 ? sortedNodes[trueIdx].element : null);
                  const lastFalseEl = (falseBranch.length > 0)
                    ? sortedNodes[falseBranch[falseBranch.length - 1]].element
                    : (falseIdx !== -1 ? sortedNodes[falseIdx].element : null);
                  joinNodes.forEach(jn => {
                    if (lastTrueEl) WorkflowManager.createConnection(lastTrueEl, jn.element, false);
                    if (lastFalseEl) WorkflowManager.createConnection(lastFalseEl, jn.element, false);
                  });
                } else {
                  // Implicit join: connect last true/false nodes to the first non-branch, non-child node after this IF block
                  let blockEnd = i;
                  for (let j = i + 1; j < sortedNodes.length; j++) {
                    const d = sortedNodes[j]?.data;
                    if (!d) continue;
                    // Stop at next top-level IF
                    if (d.type === 'If' && (!d.properties || !d.properties.parentIfId)) { blockEnd = j - 1; break; }
                    blockEnd = j;
                  }
                  // Find first non-control node after block that is not a child of this IF
                  let targetIdx = -1;
                  for (let j = blockEnd + 1; j < sortedNodes.length; j++) {
                    const d = sortedNodes[j]?.data;
                    if (!d) continue;
                    if (d.type === 'True' || d.type === 'False') continue;
                    if (d.properties && d.properties.parentIfId === ifId) continue;
                    targetIdx = j; break;
                  }
                  if (targetIdx !== -1) {
                    const lastTrueEl = (trueBranch.length > 0)
                      ? sortedNodes[trueBranch[trueBranch.length - 1]].element
                      : (trueIdx !== -1 ? sortedNodes[trueIdx].element : null);
                    const lastFalseEl = (falseBranch.length > 0)
                      ? sortedNodes[falseBranch[falseBranch.length - 1]].element
                      : (falseIdx !== -1 ? sortedNodes[falseIdx].element : null);
                    const targetEl = sortedNodes[targetIdx].element;
                    console.log(`[IMPLICIT JOIN] Creating connections:`, {
                      lastTrueEl: lastTrueEl?.id,
                      lastFalseEl: lastFalseEl?.id,
                      targetEl: targetEl?.id,
                      ifId: ifId
                    });
                    if (lastTrueEl) WorkflowManager.createConnection(lastTrueEl, targetEl, false);
                    if (lastFalseEl) WorkflowManager.createConnection(lastFalseEl, targetEl, false);
                  } else {
                    console.log(`[IMPLICIT JOIN] No target found for ifId:`, ifId);
                  }
                }
              } catch {}
            }
            continue;
          }

          // Skip branch headers here (handled by If)
          if (type === 'True' || type === 'False') continue;

          // Do not add default linear connections for nodes inside an IF branch;
          // branch chaining is handled when processing the IF block above
          try {
            const meta = node.data?.properties;
            if (meta && meta.parentIfId) continue;
          } catch {}

          // Default linear connection to the next non-control node, with IF-join handling
          let nextIdx = i + 1;
          while (nextIdx < sortedNodes.length && (sortedNodes[nextIdx].data?.type === 'True' || sortedNodes[nextIdx].data?.type === 'False')) {
            nextIdx++;
          }
          if (nextIdx < sortedNodes.length) {
            // If next node is a join for a previous IF, connect the last of each branch to it
            const nextNode = sortedNodes[nextIdx];
            const joinForIfId = nextNode?.data?.properties?.joinForIfId;
            if (joinForIfId) {
              // Find last true/false nodes for that IF
              let lastTrueEl = null;
              let lastFalseEl = null;
              for (let j = 0; j < sortedNodes.length; j++) {
                const d = sortedNodes[j]?.data;
                if (!d || d.type === 'If' || d.type === 'True' || d.type === 'False') continue;
                if (d.properties && d.properties.parentIfId === joinForIfId) {
                  if (d.properties.branch === 'true') lastTrueEl = sortedNodes[j].element;
                  if (d.properties.branch === 'false') lastFalseEl = sortedNodes[j].element;
                }
              }
              if (lastTrueEl) WorkflowManager.createConnection(lastTrueEl, nextNode.element, false);
              if (lastFalseEl) WorkflowManager.createConnection(lastFalseEl, nextNode.element, false);
            } else {
              WorkflowManager.createConnection(node.element, nextNode.element, false);
            }
          }
        }
        logOrder('StructureManager.performRebuild wiring pass end');
        
        // Add orbs at connection midpoints
        try { WorkflowManager.addInsertOrbsForConnections(); } catch (e) {}
        // Also add source-anchored orbs under sources that feed a join
        try {
          WorkflowManager.connections.forEach((connection) => {
            try { WorkflowManager.createSourceInsertOrb(connection); } catch {}
          });
        } catch {}
        // Place big orbs strictly at branch ends
        this.placePathEndOrbs(sortedNodes);
        
        // Path-end orbs are now idempotent, no need for additional calls
        
        // Update all connection positions and orbs after layout is complete to ensure correct rendering
        requestAnimationFrame(() => {
          try {
            WorkflowManager.connections.forEach((connection) => {
              WorkflowManager.updateConnectionPosition(connection);
            });
            // Also recalc big/small orb positions now that DOM/layout is final
            try {
              const sortedForOrbs = [...nodes].sort((a, b) => {
                const at = (a && a._layout && typeof a._layout.top === 'number') ? a._layout.top : parseFloat(a?.element?.style?.top || '0');
                const bt = (b && b._layout && typeof b._layout.top === 'number') ? b._layout.top : parseFloat(b?.element?.style?.top || '0');
                return (at - bt);
              });
              StructureManager.placePathEndOrbs(sortedForOrbs);
              // Remove stale insert orbs and then position all orbs
              WorkflowManager.cleanupStaleInsertOrbs();
              // Ensure source-anchored orbs exist and are positioned
              try {
                WorkflowManager.connections.forEach((connection) => {
                  try { WorkflowManager.createSourceInsertOrb(connection); WorkflowManager.updateSourceInsertOrbPosition(connection); } catch {}
                });
              } catch {}
              OrbManager.updateAllOrbPositions();
            } catch {}
          } catch (e) {
            console.warn('[STRUCT] Error updating connection positions:', e);
          }
        });
        
          // Call callback if provided
          safeCallback();
        } catch (e) {
          console.warn('[STRUCT] performRebuild error:', e);
          safeCallback();
        }
      },
      
      // Initialize the structure
      init() {
        WorkflowManager.init();
        OrbManager.init();
      },
      
      // Clean up everything
      cleanup() {
        // Clear any pending rebuild
        if (this.rebuildTimeout) {
          clearTimeout(this.rebuildTimeout);
          this.rebuildTimeout = null;
        }
        
        WorkflowManager.cleanup();
        OrbManager.cleanup();
      }
    };
    // Deterministic layout manager for nodes (centers X and enforces vertical spacing)
    const LayoutManager = {
      apply() {
        logOrder('LayoutManager.apply start');
        try {
          if (!container) return;
          const containerRect = container.getBoundingClientRect();
          if (!containerRect) return;
          // Establish container-local coordinate helpers (account for current zoom/pan)
          let _scale = 1;
          try {
            const m = (container.style.transform || '').match(/scale\(([-\d.]+)\)/);
            if (m) _scale = parseFloat(m[1]) || 1;
          } catch {}
          const toLocalX = (vx) => (vx - containerRect.left) / _scale;
          const toLocalY = (vy) => (vy - containerRect.top) / _scale;
          // Reset anchors each layout pass
          try { ifCenters.clear(); ifHeaderCenters.clear(); } catch {}

          // Place trigger node (keep its configured top, center X)
          const trigger = nodes.find(n => n.type === 'trigger');
          if (!trigger || !trigger.element) return;

          const triggerEl = trigger.element;
          // Lock trigger to pixel-based container center to match other nodes
          if (rootCenterLockX == null) {
            rootCenterLockX = Math.round((containerRect.width / _scale) / 2);
          }
          const containerCenterLocalX = rootCenterLockX;
          triggerEl.style.left = `${containerCenterLocalX}px`;
          triggerEl.style.transform = 'translateX(-50%)';

          // Read trigger rect after possible CSS/layout changes
          const trigRect = triggerEl.getBoundingClientRect();

          // Position action nodes with support for horizontal If branching
          const actions = nodes.filter(n => n.type !== 'trigger');
          let currentTop = Math.round(toLocalY(trigRect.bottom) + VERTICAL_SPACING);
          // Root center is locked to rootCenterLockX to prevent post-click drift
          const rootCenterX = rootCenterLockX != null ? rootCenterLockX : Math.round(toLocalX(trigRect.left + (trigRect.width / 2)));

          const CONTROL_TYPES = new Set(['True', 'False']);
          const idxOf = (el) => nodes.findIndex(n => n.element === el);
          const getHeight = (el) => {
            const r = el.getBoundingClientRect();
            return Math.max(1, Math.round(r.height / _scale));
          };

          // Helper: determine if a global index lies within any IF block
          const inIfBlock = (gIndex) => {
            const d = nodes[gIndex]?.data;
            if (!d) return false;
            if (d.type === 'True' || d.type === 'False') return true;
            if (d.properties && d.properties.parentIfId) return true;
            return false;
          };

          for (let i = 0; i < actions.length; i++) {
      const n = actions[i];
            const el = n.element;
            if (!el) continue;
            const t = n.data?.type || '';

            if (t === 'If') {
              // Nest-aware IF placement: center under enclosing branch path if any
              const props = n.data?.properties || {};
              // Root centering based on trigger's center in container-local coordinates
              const baseCenter = rootCenterX;
              const NEST_STEP = 220; // widening per nest level
              // Compute nesting depth by walking parentIfId chain
              let depth = 0;
              let pid = props.parentIfId || null;
              while (pid) {
                const anc = nodes.find(x => x?.data?.type === 'If' && x?.data?.properties?.ifId === pid);
                if (!anc) break;
                depth += 1;
                pid = anc?.data?.properties?.parentIfId || null;
              }
              let center = baseCenter;
              if (props.parentIfId && props.branch) {
                // Prefer locking to recorded parent branch header X if available
                const parentAnchors = ifHeaderCenters.get(props.parentIfId);
                if (parentAnchors) {
                  center = (props.branch === 'true') ? parentAnchors.trueX : parentAnchors.falseX;
                } else {
                  const dir = props.branch === 'true' ? -1 : +1; // left for true, right for false
                  center = baseCenter + (dir * (NEST_STEP * depth));
                }
              }
              el.style.left = `${center}px`;
              el.style.transform = 'translateX(-50%)';
              el.style.top = `${currentTop}px`;
              const ifHeight = getHeight(el);
              const startY = currentTop + ifHeight + 80; // lower branch headers a bit

              // Locate True/False headers for this IF
              const globalIfIdx = idxOf(el);
              let trueIdx = -1, falseIdx = -1;
              for (let j = globalIfIdx + 1; j < nodes.length; j++) {
                const jt = nodes[j]?.data?.type;
                if (jt === 'If') break;
                if (jt === 'True' && trueIdx === -1) trueIdx = j;
                if (jt === 'False' && falseIdx === -1) falseIdx = j;
                if (trueIdx !== -1 && falseIdx !== -1) break;
              }

              // Layout branches: left column for TRUE, right column for FALSE
              let yTrue = startY;
              let yFalse = startY;
              const COLUMN_OFFSET = 280; // px from center
              // Branch columns relative to this IF's center with widening logic
              const centerX = center;
              const baseOffset = 380; // px from center (base gap)
              // Compute nested depths for this IF's branches to widen spacing
              const thisIfId = nodes[globalIfIdx]?.data?.properties?.ifId;
              const nestedDepthFor = (branchVal) => {
                let maxD = 0;
                for (let j = globalIfIdx + 1; j < nodes.length; j++) {
                  const d = nodes[j]?.data;
                  if (!d) continue;
                  if (d.type === 'True' || d.type === 'False') continue;
                  // Only consider nodes that belong to this IF's branches
                  if (!d.properties || d.properties.parentIfId == null) continue;
                  let p = d.properties.parentIfId;
                  let depth = 0;
                  let firstBranch = d.properties?.branch || null;
                  while (p) {
                    const anc = nodes.find(x => x?.data?.type === 'If' && x?.data?.properties?.ifId === p);
                    if (!anc) break;
                    if (p === thisIfId) {
                      // Count immediate nested IF as 1 layer
                      const depthVal = depth + 1;
                      if (firstBranch === branchVal) maxD = Math.max(maxD, depthVal);
                      break;
                    }
                    depth += 1;
                    firstBranch = anc?.data?.properties?.branch || firstBranch;
                    p = anc?.data?.properties?.parentIfId || null;
                  }
                }
                return maxD;
              };
              const widenTrue = nestedDepthFor('true');
              const widenFalse = nestedDepthFor('false');
              // Symmetric widening: keep workflow centered by using the max depth across both branches
              // Only widen for true nested IFs under this IF (nodes with type==='If' and parentIfId===thisIfId)
              const widenIfDepth = (() => {
                const countDepth = (branchVal) => {
                  let maxD = 0;
                  for (let j = globalIfIdx + 1; j < nodes.length; j++) {
                    const d = nodes[j]?.data;
                    if (!d) continue;
                    if (d.type !== 'If') continue;
                    if (!d.properties || d.properties.parentIfId !== thisIfId) continue;
                    // depth 1 for immediate nested IF under this IF
                    if (d.properties.branch === branchVal) maxD = Math.max(maxD, 1);
                  }
                  return maxD;
                };
                return Math.max(countDepth('true'), countDepth('false'));
              })();
              const offset = baseOffset * (1 + widenIfDepth);
              const trueX = centerX - offset;
              const falseX = centerX + offset;

              // Save centers so deeper IFs can attach under the branch path
              if (thisIfId) {
                ifCenters.set(thisIfId, centerX);
                ifHeaderCenters.set(thisIfId, { trueX, falseX });
              }

              const place = (node, side, y) => {
                const e = node.element;
                const cx = side === 'left' ? trueX : falseX;
                e.style.left = `${cx}px`;
                e.style.transform = 'translateX(-50%)';
                e.style.top = `${y}px`;
                return y + getHeight(e) + VERTICAL_SPACING;
              };
              // Place headers if present
              if (trueIdx !== -1) yTrue = place(nodes[trueIdx], 'left', yTrue);
              if (falseIdx !== -1) yFalse = place(nodes[falseIdx], 'right', yFalse);

              // Place branch actions by matching parentIfId
              const ifId = nodes[globalIfIdx]?.data?.properties?.ifId;
              if (ifId) {
                for (let j = globalIfIdx + 1; j < nodes.length; j++) {
                  const d = nodes[j]?.data;
                  if (!d) continue;
                  if (d.type === 'If') break; // next block
                  if (d.type === 'True' || d.type === 'False') continue;
                  if (d.properties && d.properties.parentIfId === ifId) {
                    if (d.properties.branch === 'true') yTrue = place(nodes[j], 'left', yTrue);
                    else if (d.properties.branch === 'false') yFalse = place(nodes[j], 'right', yFalse);
                  }
                }
              }

              // Advance currentTop to below the deeper branch end
              currentTop = Math.max(yTrue, yFalse) + 20;
              
              continue;
            }

            // Non-IF nodes: if already inside an IF block, don't override branch placement
            const gIdx = idxOf(el);
            if (inIfBlock(gIdx)) {
              // Move currentTop down to not overlap whatever was positioned by branches
              const r = el.getBoundingClientRect();
              currentTop = Math.max(currentTop, Math.round(toLocalY(r.bottom)) + VERTICAL_SPACING);
            } else {
              // Centered linear placement under root center
              el.style.left = `${rootCenterX}px`;
              el.style.transform = 'translateX(-50%)';
              el.style.top = `${currentTop}px`;
              currentTop += getHeight(el) + VERTICAL_SPACING;
            }
          }

          // Post-pass: ensure all True/False headers have explicit px centering AND correct vertical offset below their IF
          try {
            // Build IF bottom map in local coordinates
            const ifBottomById = new Map();
            for (const n of nodes) {
              const d = n?.data;
              if (!d || d.type !== 'If') continue;
              const ifId = d.properties?.ifId;
              if (!ifId || !n.element) continue;
              const r = n.element.getBoundingClientRect();
              const bottomLocal = toLocalY(r.bottom);
              ifBottomById.set(ifId, bottomLocal);
            }

            for (const n of nodes) {
              const d = n?.data;
              if (!d || (d.type !== 'True' && d.type !== 'False')) continue;
              const el = n.element; if (!el) continue;
              // Centering (X) fix when needed
              const ls = el.style.left || '';
              if (!ls || ls.includes('%') || ls.startsWith('calc')) {
                const pid = d.properties?.parentIfId || null;
                let px = null;
                if (pid) {
                  const anchors = ifHeaderCenters.get(pid);
                  if (anchors) px = (d.type === 'True') ? anchors.trueX : anchors.falseX;
                  else {
                    const center = ifCenters.get(pid) ?? (rootCenterLockX != null ? rootCenterLockX : Math.round(containerRect.width / _scale / 2));
                    const baseOffset = 380;
                    px = (d.type === 'True') ? (center - baseOffset) : (center + baseOffset);
                  }
                } else {
                  const center = (rootCenterLockX != null) ? rootCenterLockX : Math.round(containerRect.width / _scale / 2);
                  const baseOffset = 380;
                  px = (d.type === 'True') ? (center - baseOffset) : (center + baseOffset);
                }
                el.style.left = `${Math.round(px)}px`;
                el.style.transform = 'translateX(-50%)';
              }
              // Vertical (Y) fix: force headers below their IF bottom by header gap
              try {
                const pid = d.properties?.parentIfId || null;
                const ifBottom = pid ? ifBottomById.get(pid) : null;
                if (typeof ifBottom === 'number') {
                  const headerGap = 80;
                  const desiredTop = Math.round(ifBottom + headerGap);
                  // If current top is missing or too close to IF top, override
                  const rr = el.getBoundingClientRect();
                  const currentTopLocal = toLocalY(rr.top);
                  if (!el.style.top || Math.abs(currentTopLocal - desiredTop) < 2 || currentTopLocal <= desiredTop) {
                    el.style.top = `${desiredTop}px`;
                  }
                }
              } catch {}
            }
          } catch {}

          // Ensure container is tall/wide enough so SVG overlay can draw offscreen lines
          let maxBottom = Math.round(toLocalY(trigRect.bottom));
          let maxRight = Math.round(toLocalX(trigRect.right));
          for (const n of nodes) {
            if (!n?.element) continue;
            const r = n.element.getBoundingClientRect();
            maxBottom = Math.max(maxBottom, Math.round(toLocalY(r.bottom)));
            maxRight = Math.max(maxRight, Math.round(toLocalX(r.right)));
          }
          // Add safe margin
          const extra = 200;
          container.style.height = `${maxBottom + extra}px`;
          // If very wide nested branches, grow container width minimally (convert viewport width to local units)
          const minWidth = Math.max(Math.round(containerRect.width / _scale), maxRight + 200);
          container.style.minWidth = `${minWidth}px`;

          // Persist offscreen-safe layout snapshot for each node in container-local coordinates
          try {
            for (const n of nodes) {
              if (!n?.element) continue;
              const r = n.element.getBoundingClientRect();
              const left = toLocalX(r.left);
              const top = toLocalY(r.top);
              const right = toLocalX(r.right);
              const bottom = toLocalY(r.bottom);
              const width = Math.max(1, Math.round(r.width / _scale));
              const height = Math.max(1, Math.round(r.height / _scale));
              const centerX = Math.round(left + width / 2);
              const centerY = Math.round(top + height / 2);
              n._layout = { left: Math.round(left), top: Math.round(top), right: Math.round(right), bottom: Math.round(bottom), width, height, centerX, centerY };
            }
          } catch {}
        } catch (e) {
          console.warn('LayoutManager.apply error:', e);
        }
      }
    };

    
    
    // Notification function
    function showNotification(message, type = 'success', durationMs = 5000) {
      const notification = document.createElement('div');
      notification.className = `fixed right-4 z-50 p-4 rounded-lg shadow-lg transition-all duration-300 transform translate-x-full`;
      notification.style.background = type === 'success' ? '#34D399' : '#EF4444';
      notification.style.color = '#ffffff';
      notification.style.minWidth = '300px';
      // Position below toolbar to avoid overlap
      try {
        const bar = document.querySelector('.toolbar');
        const topOffset = bar ? (bar.getBoundingClientRect().bottom + 12) : 16;
        notification.style.top = `${Math.max(0, Math.round(topOffset))}px`;
      } catch { notification.style.top = '16px'; }

      notification.innerHTML = `
        <div class="flex items-center justify-between">
          <span>${message}</span>
          <button class="button ml-4 text-white hover:text-gray-200"><span class="material-icons-outlined">close</span></button>
        </div>
      `;
      notification.querySelector('button')?.addEventListener('click', () => {
        notification.style.transform = 'translateX(100%)';
        setTimeout(() => { if (notification.parentElement) notification.remove(); }, 300);
      });
      document.body.appendChild(notification);
      requestAnimationFrame(() => { notification.style.transform = 'translateX(0)'; });
      if (durationMs && durationMs > 0) {
        setTimeout(() => {
          notification.style.transform = 'translateX(100%)';
          setTimeout(() => { if (notification.parentElement) notification.remove(); }, 300);
        }, durationMs);
      }

// Force a full line rebuild using the base renderer to ensure identical paths as initial build
function forceFullLineRebuild(callback) {
  logOrder('FORCE_FULL_LINE_REBUILD start');
  // Begin: block refresh RAFs, ensure base renderer, and wait for DOM/styles to settle
  window.__STRUCT_REBUILDING = true;
  try {
    if (typeof PositionManager !== 'undefined' && PositionManager.originalUpdateConnectionPosition) {
      WorkflowManager.updateConnectionPosition = PositionManager.originalUpdateConnectionPosition;
    }
  } catch {}
  // Two RAFs to allow any style/DOM measurements to stabilize before rebuild
  requestAnimationFrame(() => {
    logOrder('FORCE_FULL_LINE_REBUILD raf1');
    requestAnimationFrame(() => {
      logOrder('FORCE_FULL_LINE_REBUILD raf2');
      try {
        logOrder('FORCE_FULL_LINE_REBUILD performRebuild');
        StructureManager.performRebuild(() => {
          logOrder('FORCE_FULL_LINE_REBUILD callback');
          try { WorkflowManager.updateAllConnections(); OrbManager.updateAllOrbPositions(); } catch {}
          // Re-enable stable positioning after the rebuild paths are drawn
          try {
            if (typeof PositionManager !== 'undefined' && typeof PositionManager.setupStablePositioning === 'function') {
              PositionManager.setupStablePositioning();
            }
          } catch {}
          window.__STRUCT_REBUILDING = false;
          logOrder('FORCE_FULL_LINE_REBUILD done');
          if (typeof callback === 'function') { try { callback(); } catch {} }
        });
      } catch (e) {
        logOrder('FORCE_FULL_LINE_REBUILD fallback');
        try { LayoutManager.apply(); WorkflowManager.updateAllConnections(); OrbManager.updateAllOrbPositions(); } catch {}
        window.__STRUCT_REBUILDING = false;
        if (typeof callback === 'function') { try { callback(); } catch {} }
      }
    });
  });
}

// Centralized immediate full rebuild for any structural change (nodes/lines)
function triggerFullStructureRebuild(callback) {
  logOrder('TRIGGER_FULL_STRUCTURE_REBUILD start');
  try {
    // Run the exact same wiring/path logic as initial build
    StructureManager.performRebuild(() => {
      logOrder('TRIGGER_FULL_STRUCTURE_REBUILD callback');
      try { WorkflowManager.updateAllConnections(); } catch {}
      try { OrbManager.updateAllOrbPositions(); } catch {}
      if (typeof callback === 'function') { try { callback(); } catch {} }
    });
  } catch (e) {
    logOrder('TRIGGER_FULL_STRUCTURE_REBUILD fallback');
    // Fallback if performRebuild throws
    try { LayoutManager.apply(); WorkflowManager.updateAllConnections(); OrbManager.updateAllOrbPositions(); } catch {}
    if (typeof callback === 'function') { try { callback(); } catch {} }
  }
      }
    }

    // Ensure If steps always have branch headers persisted in data snapshots
    function normalizeWorkflowSteps(rawSteps) {
      try {
        const steps = Array.isArray(rawSteps) ? JSON.parse(JSON.stringify(rawSteps)) : [];
        const withHeaders = [];
        for (let i = 0; i < steps.length; i++) {
          const step = steps[i];
          withHeaders.push(step);
          if (step && step.type === 'If') {
            // Ensure If has a stable id; use existing or derive from index
            if (!step.properties) step.properties = {};
            if (!step.properties.ifId) step.properties.ifId = `if_${i}`;
            const ifId = step.properties.ifId;
            // Look ahead for existing True/False linked to this If
            let hasTrue = false, hasFalse = false;
            for (let j = i + 1; j < steps.length; j++) {
              const s = steps[j];
              if (!s) continue;
              if (s.type === 'If') break; // next block
              if (s.type === 'True' && s.properties && s.properties.parentIfId === ifId) hasTrue = true;
              if (s.type === 'False' && s.properties && s.properties.parentIfId === ifId) { hasFalse = true; break; }
            }
            // Inject missing headers immediately after the If
            if (!hasTrue) {
              withHeaders.push({ type: 'True', properties: { parentIfId: ifId, branch: 'true' } });
            }
            if (!hasFalse) {
              withHeaders.push({ type: 'False', properties: { parentIfId: ifId, branch: 'false' } });
            }
          }
        }
        return withHeaders;
      } catch {
        return Array.isArray(rawSteps) ? rawSteps : [];
      }
    }

    // DOM elements
    const canvas = document.getElementById('flowchart-canvas');
    const container = document.getElementById('flowchart-container');
    const workflowNameInput = document.getElementById('workflow-name');
    // Save button removed; apply to main is the explicit publish path
    const triggerModal = document.getElementById('trigger-modal');
    const actionModal = document.getElementById('action-modal');
    const contextModal = document.getElementById('context-modal');
    const errorsDrawer = document.getElementById('errors-drawer');
    const errorsList = document.getElementById('errors-list');
    const runsDrawer = document.getElementById('runs-drawer');
    const runsActive = document.getElementById('runs-active');
    const runsHistory = document.getElementById('runs-history');
    const runDetails = document.getElementById('run-details');

    

    // Anchors for IF layout: centers and branch header X positions
    let ifCenters = new Map();           // ifId -> centerX
    let ifHeaderCenters = new Map();     // ifId -> { trueX, falseX }
    // Lock root trigger horizontal center to avoid any re-centering drift across refreshes
    let rootCenterLockX = null;

    // Throttled refresh for connections/orbs to keep offscreen lines in sync on pan/scroll
    let _refreshRafPending = false;
    // Global gate to prevent refresh churn during full structural rebuilds
    if (typeof window.__STRUCT_REBUILDING === 'undefined') window.__STRUCT_REBUILDING = false;
    function scheduleConnectionRefresh() {
      logOrder('SCHED_CONN_REFRESH requested');
      if (_refreshRafPending) { logOrder('SCHED_CONN_REFRESH skipped: raf pending'); return; }
      if (window.__STRUCT_REBUILDING) { logOrder('SCHED_CONN_REFRESH skipped: rebuilding'); return; }
      _refreshRafPending = true;
      requestAnimationFrame(() => {
        logOrder('SCHED_CONN_REFRESH run begin');
        try {
          WorkflowManager.updateAllConnections();
          // Ensure big orbs exist for current view/state before positioning
          try { StructureManager.placePathEndOrbs(nodes); } catch {}
          OrbManager.updateAllOrbPositions();
        } catch {}
        _refreshRafPending = false;
        logOrder('SCHED_CONN_REFRESH run end');
      });
    }

    // Exit to dashboard: perform autosave then navigate
    (function initExitToDashboard(){
      try {
        const btn = document.getElementById('exit-to-dashboard-top');
        if (!btn) return;
        btn.addEventListener('click', async () => {
          try {
            const snap = HistoryManager.buildSnapshot();
            try { await DraftManager.autosaveDraft(snap); } catch {}
          } catch {}
          window.location.href = '/dashboard';
        });
      } catch {}
    })();

    // Zoom controls (user friendly)
    let zoomLevel = 1;
    const MIN_ZOOM = 0.5;
    const MAX_ZOOM = 1.5;
    const ZOOM_STEP = 0.1;
    function applyZoom() {
      try {
        container.style.transformOrigin = '0 0';
        // Preserve current pan while zooming
        container.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${zoomLevel})`;
        scheduleConnectionRefresh();
      } catch {}
    }

    function initializeCanvas() {
      // Canvas dragging functionality
      canvas.addEventListener('mousedown', (e) => {
        if (e.target === canvas || e.target === container) {
          // Ensure structure is fully aligned before first pan to avoid any jump
        if (!didFirstPanRefresh) {
          // Ensure initial layout aligns to locked root center once before first pan
          try { LayoutManager.apply(); WorkflowManager.updateAllConnections(); OrbManager.updateAllOrbPositions(); } catch {}
          didFirstPanRefresh = true;
        }
          isDragging = true;
          dragStart = { x: e.clientX, y: e.clientY };
          canvas.style.cursor = 'grabbing';
        }
      });

      canvas.addEventListener('mousemove', (e) => {
        if (isDragging) {
          const deltaX = e.clientX - dragStart.x;
          const deltaY = e.clientY - dragStart.y;
          
          canvasOffset.x += deltaX;
          canvasOffset.y += deltaY;
          
          container.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${zoomLevel})`;
          
          dragStart = { x: e.clientX, y: e.clientY };
          scheduleConnectionRefresh();
        }
      });

      canvas.addEventListener('mouseup', () => {
        isDragging = false;
        canvas.style.cursor = 'grab';
        scheduleConnectionRefresh();
      });

      canvas.addEventListener('mouseleave', () => {
        isDragging = false;
        canvas.style.cursor = 'grab';
        scheduleConnectionRefresh();
      });

      // Save button removed

      // Zoom buttons
      try {
        const zOut = document.getElementById('zoom-out');
        const zIn = document.getElementById('zoom-in');
        const zReset = document.getElementById('zoom-reset');
        const zLabel = document.getElementById('zoom-level');
        const updateLabel = () => { if (zLabel) zLabel.textContent = `${Math.round(zoomLevel*100)}%`; };
        if (zOut) zOut.addEventListener('click', () => { zoomLevel = Math.max(MIN_ZOOM, +(zoomLevel - ZOOM_STEP).toFixed(2)); applyZoom(); updateLabel(); });
        if (zIn) zIn.addEventListener('click', () => { zoomLevel = Math.min(MAX_ZOOM, +(zoomLevel + ZOOM_STEP).toFixed(2)); applyZoom(); updateLabel(); });
        if (zReset) zReset.addEventListener('click', () => { zoomLevel = 1; applyZoom(); updateLabel(); });
        updateLabel();
      } catch {}

      // Disable native scrollbars and default scrolling; use wheel to pan
      try {
        if (canvas) {
          canvas.style.overflow = 'hidden';
          canvas.style.touchAction = 'none';
          canvas.addEventListener('wheel', (e) => {
            try {
              e.preventDefault();
              e.stopPropagation();
              // Pan opposite to wheel delta to mimic native scroll behavior
              const dx = -e.deltaX;
              const dy = -e.deltaY;
              canvasOffset.x += dx;
              canvasOffset.y += dy;
              container.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${zoomLevel})`;
              scheduleConnectionRefresh();
            } catch {}
          }, { passive: false });
        }
      } catch {}
      // Debug layout button
      try {
        const btn = document.getElementById('debug-layout');
        if (btn) btn.addEventListener('click', () => {
          try {
            const out = { meta: {}, nodes: [], connections: [], anchors: {} };
            const containerRect = container.getBoundingClientRect();
            // Meta
            out.meta = {
              zoomLevel,
              container: {
                left: Math.round(containerRect.left),
                top: Math.round(containerRect.top),
                width: Math.round(containerRect.width),
                height: Math.round(containerRect.height),
                transform: container.style.transform || null,
              },
              scroll: { x: canvas.scrollLeft || 0, y: canvas.scrollTop || 0 },
            };
            for (const n of nodes) {
              if (!n?.element) continue;
              const r = n.element.getBoundingClientRect();
              const x = r.left - containerRect.left;
              const y = r.top - containerRect.top;
              const w = r.width;
              const h = r.height;
              // Also capture raw style positions (as set by layout), and viewport coords
              const styleLeft = (()=>{ try { return parseFloat(n.element.style.left.replace('px','')) || null; } catch { return null; } })();
              const styleTop = (()=>{ try { return parseFloat(n.element.style.top.replace('px','')) || null; } catch { return null; } })();
              out.nodes.push({
                id: n.id,
                type: n.type || n.data?.type,
                x: Math.round(x),
                y: Math.round(y),
                width: Math.round(w),
                height: Math.round(h),
                viewport: { left: Math.round(r.left), top: Math.round(r.top), right: Math.round(r.right), bottom: Math.round(r.bottom) },
                center: { x: Math.round(x + w / 2), y: Math.round(y + h / 2) },
                anchors: {
                  topCenter: { x: Math.round(x + w / 2), y: Math.round(y + 1) },
                  bottomCenter: { x: Math.round(x + w / 2), y: Math.round(y + h - 1) },
                },
                stylePos: { left: styleLeft, top: styleTop },
                world: { x: zoomLevel ? Math.round(x / zoomLevel) : Math.round(x), y: zoomLevel ? Math.round(y / zoomLevel) : Math.round(y) },
                data: n.data || null,
              });
            }
            // Connections
            for (const c of WorkflowManager.connections.values()) {
              try {
                const fr = c.from.getBoundingClientRect();
                const tr = c.to.getBoundingClientRect();
                const fromX = fr.left - containerRect.left + fr.width / 2;
                const fromY = fr.bottom - containerRect.top - 1;
                const toX = tr.left - containerRect.left + tr.width / 2;
                const toY = tr.top - containerRect.top + 1;
                out.connections.push({
                  id: c.id,
                  from: c.from.id,
                  to: c.to.id,
                  fromX: Math.round(fromX),
                  fromY: Math.round(fromY),
                  toX: Math.round(toX),
                  toY: Math.round(toY),
                  world: {
                    fromX: zoomLevel ? Math.round(fromX / zoomLevel) : Math.round(fromX),
                    fromY: zoomLevel ? Math.round(fromY / zoomLevel) : Math.round(fromY),
                    toX: zoomLevel ? Math.round(toX / zoomLevel) : Math.round(toX),
                    toY: zoomLevel ? Math.round(toY / zoomLevel) : Math.round(toY),
                  },
                  lineTag: (c.line && c.line.tagName) || null,
                });
              } catch {}
            }
            // Anchors: record IF centers and header centers if computed
            try {
              const ifc = {}; ifCenters.forEach((v, k) => { ifc[k] = v; });
              const hdr = {}; ifHeaderCenters.forEach((v, k) => { hdr[k] = v; });
              out.anchors = { ifCenters: ifc, ifHeaderCenters: hdr };
            } catch {}
            showNotification('Layout debug printed to console');
          } catch (e) {
            console.error('[DEBUG][LAYOUT] failed', e);
            showNotification('Failed to print debug', 'error');
          }
        });
      } catch {}
    }

    // Themed confirm / prompt helpers
    function themedConfirm(message, title = 'Confirm') {
      return new Promise((resolve) => {
        const modal = document.getElementById('confirm-modal');
        document.getElementById('confirm-title').textContent = title;
        document.getElementById('confirm-message').textContent = message;
        const ok = document.getElementById('confirm-ok');
        const cancel = document.getElementById('confirm-cancel');
        const close = () => { modal.classList.add('hidden'); ok.onclick = cancel.onclick = null; };
        ok.onclick = () => { resolve(true); close(); };
        cancel.onclick = () => { resolve(false); close(); };
        modal.classList.remove('hidden');
      });
    }

    function themedPrompt(initial = '', title = 'Rename', label = 'New name') {
      return new Promise((resolve) => {
        const modal = document.getElementById('prompt-modal');
        document.getElementById('prompt-title').textContent = title;
        document.getElementById('prompt-label').textContent = label;
        const input = document.getElementById('prompt-input');
        input.value = initial || '';
        const ok = document.getElementById('prompt-ok');
        const cancel = document.getElementById('prompt-cancel');
        const close = () => { modal.classList.add('hidden'); ok.onclick = cancel.onclick = null; };
        ok.onclick = () => { resolve(input.value.trim()); close(); };
        cancel.onclick = () => { resolve(null); close(); };
        modal.classList.remove('hidden');
        setTimeout(() => { try { input.focus(); input.select(); } catch {} }, 50);
      });
    }

    // Force-align nodes, connections and orbs based on current DOM metrics
    function refreshStructure() {
      try {
        LayoutManager.apply();
        WorkflowManager.updateAllConnections();
        OrbManager.updateAllOrbPositions();
      } catch (e) {
        console.warn('refreshStructure error:', e);
      }
    }
    async function loadWorkflow() {
      const id = getCurrentWorkflowId();
      if (id) {
        try {
        let res = await fetch(`${API_URL}/workflows/${id}`, { credentials: 'include', cache: 'no-store' });
        if (res.status === 304) {
          res = await fetch(`${API_URL}/workflows/${id}?t=${Date.now()}`, { credentials: 'include', cache: 'no-store' });
        }
        if (res.status === 401) { handleUnauthorizedRedirect(); return; }
          
          if (res.ok) {
            currentWorkflow = await res.json();
            
            const workflowData = currentWorkflow.data || currentWorkflow;
            logOrder(`Workflow data keys: ${Object.keys(workflowData || {}).join(', ')}`);
            
            if (workflowData.name || currentWorkflow.name) {
              const name = workflowData.name || currentWorkflow.name;
              workflowNameInput.value = name;
              logOrder(`Workflow name set: ${name}`);
            }
            
            // Load existing nodes and connections
            if (workflowData.steps && Array.isArray(workflowData.steps)) {
              logOrder(`Workflow steps count: ${Array.isArray(workflowData.steps) ? workflowData.steps.length : 0}`);
              
              // Clear existing nodes first - more thorough cleanup
              nodes.forEach(node => {
                if (node.element) {
                  node.element.remove();
                }
              });
              nodes = [];
              // Reset DOM id counter so ids don't keep increasing across branch switches
              try { currentNodeId = 0; availableNodeIds = new Set(); } catch {}
              
              // Clear all orbs
              const existingOrbs = container.querySelectorAll('.add-action-orb, .insert-action-orb');
              existingOrbs.forEach(orb => orb.remove());
              
              // Clear all connection lines
              const existingLines = container.querySelectorAll('.connection-line');
              existingLines.forEach(line => line.remove());
              
              // Set loading guard to avoid auto-generating branch headers during load pass
              isLoadingWorkflow = true;
              currentLoadSteps = workflowData.steps;

              // Check if we have trigger data at the top level (for existing workflows)
              if (workflowData.trigger) {
                const triggerData = {
                  type: workflowData.trigger,
                  properties: {
                    eventTypes: workflowData.triggerEventTypes || [],
                    tags: workflowData.triggerTags || []
                  }
                };
                updateTriggerNode(triggerData);
                
                // Remove guide text when loading existing workflow with configured trigger
                const helpText = container.querySelector('div[style*="Configure your trigger above"]');
                if (helpText) {
                  helpText.remove();
        } else {
                  // Try alternative selectors
                  const allDivs = container.querySelectorAll('div');
                  allDivs.forEach((div) => {
                    if (div.innerHTML && div.innerHTML.includes('Configure your trigger above')) {
                      div.remove();
                    }
                  });
                }
                
                // Strong guard: remove guides if configured
                removeGuidesIfConfigured();
                
                // Restore selected tags/event types for editing
                if (workflowData.trigger === 'Tag Added' && workflowData.triggerTags) {
                  window.selectedTags = [...workflowData.triggerTags];
                }
                if (workflowData.trigger === 'Meeting Scheduled') {
                  if (workflowData.triggerEventTypes) window.selectedEventTypes = [...workflowData.triggerEventTypes];
                  if (workflowData.triggerEventTypeIds) window.selectedEventTypeIds = [...workflowData.triggerEventTypeIds];
                }
        } else {
                // Try to find trigger in steps (for new format)
                const triggerStep = workflowData.steps.find(step => step.type === 'trigger');
                
                if (triggerStep) {
                  updateTriggerNode(triggerStep);
                  
                  // Restore selected tags/event types for editing
                  if (triggerStep.type === 'Tag Added' && triggerStep.properties?.tags) {
                    window.selectedTags = [...triggerStep.properties.tags];
                  }
                  if (triggerStep.type === 'Meeting Scheduled' && triggerStep.properties?.eventTypes) {
                    window.selectedEventTypes = [...triggerStep.properties.eventTypes];
                    if (triggerStep.properties?.eventTypeIds) window.selectedEventTypeIds = [...triggerStep.properties.eventTypeIds];
                  }
                }
              }

              // Load actions (skip trigger since it's already loaded)
              const normalizedSteps = normalizeWorkflowSteps(workflowData.steps);
              // Suspend rebuilds during bulk load to avoid intermediate orb/connection flicker
              const prevLoading = isLoadingWorkflow;
              isLoadingWorkflow = true;
              suspendRebuild = true;
              try {
                normalizedSteps.forEach((step, index) => {
                  if (step.type !== 'trigger') {
                    const clean = { ...step };
                    // Ensure join nodes don't trigger IF auto-branching or unwanted UI
                    if (clean.properties && clean.properties.joinForIfId) {
                      // Explicitly clear branch markers on load; wiring will use joinForIfId only
                      delete clean.properties.branch;
                      delete clean.properties.parentIfId;
                    }
                    addActionNode(clean, index);
                  } else {
                  }
                });
              } finally {
                isLoadingWorkflow = prevLoading;
                suspendRebuild = false;
              }
              
              // Load context spec if available, otherwise apply default
              if (workflowData.contextSpec) {
                contextSpec = workflowData.contextSpec;
              } else {
                contextSpec = getDefaultContextSpec();
              }

              // Rebuild the workflow structure after loading all nodes
              setTimeout(() => {
                // End loading guard before rebuild so layout and orbs apply deterministically
                isLoadingWorkflow = false;
                currentLoadSteps = null;
                // Always ensure loading screen hides even if rebuild errors
                try {
                  // Ensure a trigger node exists for empty workflows
                  try {
                    const hasTrigger = nodes.some(n => n.type === 'trigger');
                    if (!hasTrigger) {
                      createInitialTriggerNode();
                    }
                  } catch {}
                  // Stronger guard: remove any guide text if there are actions or a configured trigger
                  try {
                    const hasActions = nodes.some(n => n.type === 'action');
                    const trig = nodes.find(n => n.type === 'trigger');
                    const configured = !!(trig && trig.data && trig.data.type);
                    if (hasActions || configured) {
                      const helpText = container.querySelector('div[style*="Configure your trigger above"]');
                      if (helpText) helpText.remove();
                      const allDivs = container.querySelectorAll('div');
                      allDivs.forEach((div) => {
                        if (div.innerHTML && div.innerHTML.includes('Configure your trigger above')) {
                          div.remove();
                        }
                      });
                      const triggerNode = container.querySelector('.flowchart-node.trigger');
                      if (triggerNode) triggerNode.classList.add('configured');
                    }
                  } catch {}
                  logOrder('loadWorkflow: rebuild start');
                  StructureManager.rebuild(() => {
                    logOrder('loadWorkflow: rebuild complete');
                    hideLoadingScreen();
                  });
                  // Fallback: hide spinner even if callback somehow doesn't fire
                  setTimeout(() => { try { hideLoadingScreen(); } catch {} }, 1500);
                } catch (e) {
                  console.warn('[WF] Rebuild scheduling failed', e);
                  hideLoadingScreen();
                }
              }, 100);
              }
            }
          } catch (error) {
          console.error('[WF] Error loading workflow:', error);
        }
      }
    }

    function createInitialTriggerNode(explicitId) {
      const triggerNode = createNode('trigger', 'Trigger', 'play_circle', '', explicitId);
      triggerNode.style.left = '50%';
      triggerNode.style.top = '50px';
      triggerNode.style.transform = 'translateX(-50%)';
      
      // Override the click handler for the trigger node specifically
      triggerNode.removeEventListener('click', (e) => selectNode(triggerNode));
      triggerNode.addEventListener('click', (e) => {
        e.stopPropagation();
        openTriggerModal();
      });
      
      container.appendChild(triggerNode);
      nodes.push({ id: triggerNode.id, type: 'trigger', element: triggerNode });
      
      // Rebuild to add the orb below the trigger and hide loading screen
      StructureManager.rebuild(() => {
        hideLoadingScreen();
      });
      
      // Add movement listeners
      addNodeMovementListeners();
      
      // Add helpful text
      const helpText = document.createElement('div');
      helpText.id = 'editor-guide-text';
      helpText.style.position = 'absolute';
      helpText.style.left = '50%';
      helpText.style.top = '200px';
      helpText.style.transform = 'translateX(-50%)';
                  helpText.style.color = '#9ca3af';
      helpText.style.fontSize = '0.875rem';
      helpText.style.textAlign = 'center';
      helpText.innerHTML = 'Configure your trigger above, then add actions below to build your workflow';
      container.appendChild(helpText);
    }

    // Remove deterministic renumbering to avoid duplicate DOM ids and broken references
    function renumberNodesDeterministically() { /* no-op */ }

    // Remove all guide texts/tooltips when workflow is configured
    function removeGuidesIfConfigured() {
      try {
        const hasActions = nodes.some(n => n.type === 'action');
        const trigNode = nodes.find(n => n.type === 'trigger');
        const triggerConfigured = !!(trigNode && trigNode.data && trigNode.data.type);
        if (!hasActions && !triggerConfigured) return;
        // Remove inline guide banner
        try { const gt = container.querySelector('#editor-guide-text'); if (gt) gt.remove(); } catch {}
        // Fallback: remove any element containing the message
        try {
          const allDivs = container.querySelectorAll('div');
          allDivs.forEach((div) => {
            if (div.innerHTML && div.innerHTML.includes('Configure your trigger above')) {
              div.remove();
            }
          });
        } catch {}
        // Mark trigger as configured and clear any placeholder content
        try {
          const el = container.querySelector('.flowchart-node.trigger');
          if (el) {
            el.classList.add('configured');
            const contentEl = el.querySelector('.node-content');
            if (contentEl && contentEl.textContent && contentEl.textContent.toLowerCase().includes('click to configure')) {
              contentEl.textContent = '';
            }
          }
        } catch {}
      } catch {}
    }

    function createNode(type, title, icon, content, explicitId) {
      const node = document.createElement('div');
      node.className = `flowchart-node ${type}`;
      try {
        // Helper to claim next reusable or new id
        const claimNextId = () => {
          // Prefer a freed id if available (smallest numeric)
          if (availableNodeIds && availableNodeIds.size > 0) {
            const sorted = Array.from(availableNodeIds).sort((a, b) => a - b);
            for (const n of sorted) {
              const candidate = `node-${n}`;
              if (!document.getElementById(candidate)) {
                availableNodeIds.delete(n);
                return candidate;
              } else {
                // If somehow exists, skip this freed id
                availableNodeIds.delete(n);
              }
            }
          }
          // Fallback to incrementing the counter until a free id is found
          let next = `node-${++currentNodeId}`;
          while (document.getElementById(next)) {
            currentNodeId += 1;
            next = `node-${currentNodeId}`;
          }
          return next;
        };

        const assignedId = explicitId && String(explicitId).trim() ? String(explicitId).trim() : claimNextId();
        // Ensure uniqueness if an explicit id was requested
        let finalId = assignedId;
        if (document.getElementById(finalId)) {
          finalId = claimNextId();
        }
        node.id = finalId;
      } catch {
      // Worst-case fallback
      let fallbackId;
      if (availableNodeIds && availableNodeIds.size > 0) {
        const sorted = Array.from(availableNodeIds).sort((a, b) => a - b);
        fallbackId = `node-${sorted[0]}`;
        availableNodeIds.delete(sorted[0]);
      } else {
        fallbackId = `node-${++currentNodeId}`;
      }
      while (document.getElementById(fallbackId)) {
        currentNodeId += 1;
        fallbackId = `node-${currentNodeId}`;
      }
      node.id = fallbackId;
      }
      node.dataset.stepType = type;
      // Consistent horizontal centering for all nodes
      node.style.left = '50%';
      node.style.transform = 'translateX(-50%)';
      
      if (type !== 'trigger') {
        node.innerHTML = `
          <div class="node-header">
            <span class="material-icons-outlined node-icon">${icon}</span>
            <div class="node-title">${title}</div>
            <div class="node-id-label" style="margin-left:8px;color:#9ca3af;font-size:.75rem;user-select:text">${/* id will be set after append */''}</div>
            ${(['True','False'].includes(type)) ? '' : `
            <div class="node-actions">
              <button class="node-action-btn edit-btn" title="Edit Action">
                <span class="material-icons-outlined">edit</span>
              </button>
              <button class="node-action-btn delete-btn" title="Delete Action">
                <span class="material-icons-outlined">delete</span>
              </button>
            </div>`}
          </div>
          <div class="node-content">${content}</div>
        `;
        
        // Add edit and delete handlers unless True/False header
        if (!(['True','False'].includes(type))) {
          const editBtn = node.querySelector('.edit-btn');
          const deleteBtn = node.querySelector('.delete-btn');
          if (editBtn) editBtn.addEventListener('click', (e) => { e.stopPropagation(); editAction(node); });
          if (deleteBtn) deleteBtn.addEventListener('click', (e) => { e.stopPropagation(); deleteAction(node); });
        }
      } else {
        node.innerHTML = `
          <div class="node-header">
            <span class="material-icons-outlined node-icon">${icon}</span>
            <div class="node-title">${title}</div>
            <div class="node-id-label" style="margin-left:8px;color:#9ca3af;font-size:.75rem;user-select:text">${''}</div>
          </div>
          <div class="node-content">${content}</div>
        `;
      }
      
      // Add click handler for selection
      node.addEventListener('click', (e) => {
        e.stopPropagation();
        selectNode(node);
      });
      // Set visible element id label (after id assigned)
      try { const label = node.querySelector('.node-id-label'); if (label) label.textContent = node.id; } catch {}
      
      return node;
    }

    function parseNodeNumericId(id) {
      try {
        const m = String(id || '').match(/^node-(\d+)$/);
        return m ? parseInt(m[1], 10) : null;
      } catch { return null; }
    }

    function releaseNodeIdByString(id) {
      const n = parseNodeNumericId(id);
      if (n != null) {
        availableNodeIds.add(n);
      }
    }
    
    function selectNode(node) {
      // Deselect previously selected node
      if (selectedNode) {
        selectedNode.classList.remove('selected');
      }
      
      // Select new node
      selectedNode = node;
      node.classList.add('selected');
    }
    
    // Deselect when clicking on canvas
    container.addEventListener('click', (e) => {
      if (e.target === container) {
        try {
          if (selectedNode && selectedNode.classList && typeof selectedNode.classList.remove === 'function') {
            selectedNode.classList.remove('selected');
          } else {
            console.error('Failed to load workflow: HTTP', res.status);
          }
        } catch {}
        selectedNode = null;
      }
    });


    function openTriggerModal() {
      triggerModal.classList.remove('hidden');
      
      // Check if we're editing an existing trigger
      const triggerNode = nodes.find(n => n.type === 'trigger');
      if (triggerNode && triggerNode.data) {
        // Pre-populate the trigger type
        const triggerSelect = document.getElementById('trigger-select');
        if (triggerSelect) {
          triggerSelect.value = triggerNode.data.type;
        }
        
        // Restore selected tags if it's a Tag Added trigger
        if (triggerNode.data.type === 'Tag Added' && triggerNode.data.properties?.tags) {
          window.selectedTags = [...triggerNode.data.properties.tags];
        }
        
        // Restore selected event types if it's a Meeting Scheduled trigger
        if (triggerNode.data.type === 'Meeting Scheduled' && triggerNode.data.properties?.eventTypes) {
          window.selectedEventTypes = [...triggerNode.data.properties.eventTypes];
        }
      } else {
        // Reset for new trigger
        window.selectedTags = [];
      }
      
      renderTriggerProperties();
    }

    function closeTriggerModal() {
      triggerModal.classList.add('hidden');
    }

    function openActionModal(parentNodeId) {
      actionModal.classList.remove('hidden');
      selectedNode = parentNodeId;
      
      // Check if this is an insert operation
      if (parentNodeId === 'insert') {
        const modalTitle = actionModal.querySelector('.modal-title');
        if (modalTitle) {
          modalTitle.textContent = 'Insert Action';
        }
        
        const actionSaveBtn = document.getElementById('action-save-btn');
        if (actionSaveBtn) {
          actionSaveBtn.textContent = 'Insert Action';
        }
      }
      
      // Check if this is an "add after" operation
      if (parentNodeId && parentNodeId.startsWith('add-after-')) {
        const modalTitle = actionModal.querySelector('.modal-title');
        if (modalTitle) {
          modalTitle.textContent = 'Add Action';
        }
        
        const actionSaveBtn = document.getElementById('action-save-btn');
        if (actionSaveBtn) {
          actionSaveBtn.textContent = 'Add Action';
        }
      }
      
      // Check if this is an orb-connect operation
      if (parentNodeId === 'orb-connect') {
        const modalTitle = actionModal.querySelector('.modal-title');
        if (modalTitle) {
          modalTitle.textContent = 'Connect Actions';
        }
        
        const actionSaveBtn = document.getElementById('action-save-btn');
        if (actionSaveBtn) {
          actionSaveBtn.textContent = 'Insert Action';
        }
        // Ensure a default selection for action type to avoid no-op on save
        try {
          const actionSelect = document.getElementById('action-select');
          if (actionSelect && !actionSelect.value) {
            const first = actionSelect.querySelector('option');
            if (first) actionSelect.value = first.value;
          }
        } catch {}
        logOrder('LayoutManager.apply end');
      }
      
      // Check if we're editing an existing action
      const existingNode = nodes.find(n => n.id === parentNodeId);
    if (existingNode && existingNode.type !== 'trigger') {
        // Set the modal title to indicate editing
        const modalTitle = actionModal.querySelector('.modal-title');
        if (modalTitle) {
          modalTitle.textContent = 'Edit Action';
        }
        
        // Update button text
        const actionSaveBtn = document.getElementById('action-save-btn');
        if (actionSaveBtn) {
          actionSaveBtn.textContent = 'Update Action';
        }
        
        // Pre-populate the action type
        const actionSelect = document.getElementById('action-select');
        if (actionSelect) {
          actionSelect.value = existingNode.data.type;
        }
      } else {
        // Reset modal title for new actions
        const modalTitle = actionModal.querySelector('.modal-title');
        if (modalTitle) {
          modalTitle.textContent = 'Add Action';
        }
        
        // Reset button text
        const actionSaveBtn = document.getElementById('action-save-btn');
        if (actionSaveBtn) {
          actionSaveBtn.textContent = 'Add Action';
        }
      }
      
      // Reset selected action tag
      window.selectedActionTag = '';
      renderActionProperties();
    }

    function closeActionModal() {
      actionModal.classList.add('hidden');
      selectedNode = null;
      
      // Reset insert state
      window.insertConnection = null;
      
      // Reset modal title
      const modalTitle = actionModal.querySelector('.modal-title');
      if (modalTitle) {
        modalTitle.textContent = 'Add Action';
      }
      
      // Reset button text
      const actionSaveBtn = document.getElementById('action-save-btn');
      if (actionSaveBtn) {
        actionSaveBtn.textContent = 'Add Action';
      }
    }

    // Context modal handlers
    function openContextModal() {
      try {
        if (!contextSpec) contextSpec = getDefaultContextSpec();
        document.getElementById('context-attach-full').checked = !!contextSpec.attachFullContext;
        const schemaEl = document.getElementById('context-schema');
        schemaEl.textContent = JSON.stringify(contextSpec.schema || getDefaultContextSchema(), null, 2);
        const sampleEl = document.getElementById('context-sample');
        sampleEl.value = contextSpec.sample ? JSON.stringify(contextSpec.sample, null, 2) : '';
      } catch (e) {
        console.warn('Error opening context modal:', e);
      }
      contextModal.classList.remove('hidden');
    }

    function closeContextModal() {
      contextModal.classList.add('hidden');
    }

    function saveContextSpec() {
      const attachFull = document.getElementById('context-attach-full').checked;
      const sampleText = document.getElementById('context-sample').value.trim();
      let sample = null;
      if (sampleText) {
        try {
          sample = JSON.parse(sampleText);
        } catch (e) {
          showNotification('Invalid JSON in sample payload', 'error');
          return;
        }
      }
      contextSpec = {
        ...(contextSpec || {}),
        version: 1,
        attachFullContext: attachFull,
        scope: attachFull ? 'full' : (contextSpec?.scope || 'full'),
        schema: contextSpec?.schema || getDefaultContextSchema(),
        sample: sample || null
      };
      closeContextModal();
      showNotification('Context settings saved');
    }

    async function copyContextSchema() {
      try {
        const schema = (contextSpec && contextSpec.schema) ? contextSpec.schema : getDefaultContextSchema();
        await navigator.clipboard.writeText(JSON.stringify(schema, null, 2));
        const s = document.getElementById('context-schema-copy-status');
        if (s) {
          s.textContent = 'Copied';
          setTimeout(() => { s.textContent = ''; }, 1500);
        }
      } catch (e) {
        console.warn('Copy schema failed:', e);
        showNotification('Failed to copy schema', 'error');
      }
    }

    function renderTriggerProperties() {
      const container = document.getElementById('trigger-properties');
      const triggerType = document.getElementById('trigger-select').value;
      
      let html = '';
      
      if (triggerType === 'Meeting Scheduled') {
        html = `
          <div class="form-group">
            <label class="form-label">Event Types</label>
            <div class="multi-select">
              <button type="button" class="multi-select-button" onclick="toggleMultiSelect('event-type')">
                <span>Select event types...</span>
                <span class="material-icons-outlined">expand_more</span>
                    </button>
              <div class="multi-select-options" id="event-type-options">
                <!-- Event types will be populated here -->
                  </div>
              <button type="button" class="select-all-btn" onclick="selectAllEventTypes()">Select All</button>
                  </div>
                </div>
        `;
      } else if (triggerType === 'Tag Added') {
        html = `
          <div class="form-group">
            <label class="form-label">Tags</label>
            <div class="multi-select">
              <button type="button" class="multi-select-button" onclick="toggleMultiSelect('tag')">
                <span id="tag-display">Select tags...</span>
                <span class="material-icons-outlined">expand_more</span>
              </button>
              <div class="multi-select-options" id="tag-options">
                <!-- Tags will be populated here -->
                  </div>
              <button type="button" class="select-all-btn" onclick="selectAllTags()">Select All</button>
                </div>
            <div class="mt-3" id="tag-confirm" style="display: none;">
              <button type="button" class="btn-primary w-full" onclick="confirmTagSelection()">
                Confirm Tag Selection
              </button>
              </div>
            </div>
        `;
      }
      
      container.innerHTML = html;
      
      // Reset selected tags when changing trigger type
      if (triggerType === 'Tag Added') {
        window.selectedTags = [];
        // Hide confirm button initially
        setTimeout(() => {
          const confirmBtn = document.getElementById('tag-confirm');
          if (confirmBtn) {
            confirmBtn.style.display = 'none';
          }
        }, 100);
      }
      
      // Populate options
      if (triggerType === 'Meeting Scheduled') {
        populateEventTypes();
      } else if (triggerType === 'Tag Added') {
        populateTags();
      }
      
      // Reset selected arrays when changing trigger type
      if (triggerType === 'Tag Added') {
        // Don't reset if we're editing and have existing tags
        if (!window.selectedTags || window.selectedTags.length === 0) {
          window.selectedTags = [];
        }
        window.selectedEventTypes = [];
      } else if (triggerType === 'Meeting Scheduled') {
        // Don't reset if we're editing and have existing event types
        if (!window.selectedEventTypes || window.selectedEventTypes.length === 0) {
          window.selectedEventTypes = [];
        }
        window.selectedTags = [];
      } else {
        window.selectedTags = [];
        window.selectedEventTypes = [];
      }
    }
    function renderActionProperties() {
      const container = document.getElementById('action-properties');
      const actionType = document.getElementById('action-select').value;
      
      let html = '';
      
      if (actionType === 'Add Tag') {
        html = `
          <div class="form-group">
            <label class="form-label">Tag to Add</label>
              <div class="multi-select">
              <button type="button" class="multi-select-button" onclick="toggleMultiSelect('action-tag')">
                <span id="action-tag-display">Select tag...</span>
                <span class="material-icons-outlined">expand_more</span>
                </button>
              <div class="multi-select-options" id="action-tag-options">
                <!-- Available tags will be populated here -->
                </div>
              </div>
            <div class="mt-3" id="action-tag-confirm" style="display: none;">
              <button type="button" class="btn-primary w-full" onclick="confirmActionTag()">
                Confirm Tag Selection
              </button>
            </div>
            <div class="form-group" style="margin-top:.75rem">
              <label class="form-label">Create New Tag</label>
              <div style="display:flex;gap:.5rem;align-items:center">
                <input id="action-new-tag-name" class="form-select" placeholder="New tag name" />
                <button type="button" class="context-btn" onclick="createActionTag()">Create</button>
              </div>
              <div id="action-create-tag-status" style="margin-top:.25rem;color:#9ca3af;font-size:.85rem"></div>
            </div>
          </div>
        `;
        
        // Reset selected tag when changing action type
        window.selectedActionTag = '';
        
        // Hide confirm button initially
        setTimeout(() => {
          const confirmBtn = document.getElementById('action-tag-confirm');
          if (confirmBtn) {
            confirmBtn.style.display = 'none';
          }
        }, 100);
        
        // Populate the action tag options after rendering
        setTimeout(() => populateActionTags(), 100);
      }
      
      if (actionType === 'Send Email') {
        html = `
          <div class="form-group">
            <label class="form-label" style="display:flex;align-items:center;gap:.5rem">
              <input type="checkbox" id="email-manual-recipient" /> Specify recipient manually
            </label>
            <div id="email-to-wrapper" style="margin-top:.5rem;display:none">
              <label class="form-label">To</label>
              <input id="email-to" class="form-select" placeholder="email1@example.com, email2@example.com" />
            </div>
            <div style="margin-top:.25rem;color:#9ca3af;font-size:.85rem">When unchecked, the email is sent to the contact who triggered the workflow.</div>
          </div>
          <div class="form-group">
            <label class="form-label">CC</label>
            <input id="email-cc" class="form-select" placeholder="Optional: comma-separated" />
          </div>
          <div class="form-group">
            <label class="form-label">BCC</label>
            <input id="email-bcc" class="form-select" placeholder="Optional: comma-separated" />
          </div>
          <div class="form-group">
            <label class="form-label">Subject</label>
            <input id="email-subject" class="form-select" placeholder="Subject line" />
          </div>
          <div class="form-group">
            <label class="form-label" style="display:flex;align-items:center;gap:.5rem">
              <input type="checkbox" id="email-is-html" /> Use HTML body
            </label>
          </div>
          <div class="form-group">
            <label class="form-label">Body</label>
            <textarea id="email-body" style="width:100%;min-height:160px;background:#1E3A34;border:1px solid #2C4A43;border-radius:.5rem;padding:.75rem;color:#E0E0E0"></textarea>
            <div style="margin-top:.25rem;color:#9ca3af;font-size:.85rem">Tip: Future versions support tokens like {{contact.fullName}}.</div>
          </div>
        `;
      }

      if (actionType === 'If') {
        const triggerNode = nodes.find(n => n.type === 'trigger');
        const triggerType = triggerNode?.data?.type || 'Meeting Scheduled';
        const contactFields = [
          ['contact.id','ID'],
          ['contact.firstName','First name'],
          ['contact.lastName','Last name'],
          ['contact.fullName','Full name'],
          ['contact.email','Email'],
          ['contact.phone','Phone'],
          ['contact.timezone','Timezone'],
          ['contact.locale','Locale'],
          ['contact.company','Company'],
          ['contact.title','Title'],
          ['contact.tags','Tags'],
          ['contact.notes','Notes'],
          ['contact.createdAt','Created at'],
          ['contact.updatedAt','Updated at']
        ];
        const bookingFields = [
          ['booking.id','ID'],
          ['booking.title','Title'],
          ['booking.status','Status'],
          ['booking.eventType','Event type'],
          ['booking.startTime','Start time'],
          ['booking.endTime','End time'],
          ['booking.durationMinutes','Duration (minutes)'],
          ['booking.timezone','Timezone'],
          ['booking.location','Location'],
          ['booking.meetingLink','Meeting link'],
          ['booking.rescheduleCount','Reschedule count'],
          ['booking.createdAt','Created at'],
          ['booking.updatedAt','Updated at']
        ];
        const defaultField = 'contact.email';
        // Build event-type-aware answer keys for the selected trigger configuration
        let dynamicAnswersOptions = '';
        try {
          const cache = Array.isArray(window.eventTypesCache) ? window.eventTypesCache : [];
          const slugifyKey = (s) => (s || '').toString().trim().toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '').substring(0,64);
          let subset = [];
          if (triggerType === 'Meeting Scheduled') {
            const ids = (window.selectedEventTypeIds && window.selectedEventTypeIds.length)
              ? window.selectedEventTypeIds
              : (triggerNode?.data?.properties?.eventTypeIds || []);
            if (Array.isArray(ids) && ids.length > 0) subset = cache.filter(et => ids.includes(et.id));
          } else if (triggerType === 'Tag Added') {
            subset = cache;
          }
          const seen = new Set();
          const list = [];
          subset.forEach(et => {
            if (Array.isArray(et?.questions)) {
              et.questions.forEach(q => {
                const label = (q && (q.text || q.label)) ? (q.text || q.label) : null;
                if (!label) return;
                const key = slugifyKey(label);
                if (key && !seen.has(key)) {
                  seen.add(key);
                  list.push({ key, label, etTitle: et.title });
                }
              });
            }
          });
          if (list.length > 0) {
            dynamicAnswersOptions += list.map(q => `
              <label class="multi-select-option" data-category="answers" data-text="${('booking.answers.'+q.key).toLowerCase()} ${q.label.toLowerCase()} ${q.etTitle.toLowerCase()}" onclick="selectIfField('booking.answers.${q.key}')">
                <span>${q.label} <span style=\"color:#6b7280\">(${q.etTitle})</span></span>
              </label>
            `).join('');
          }
        } catch (e) {
          // Non-fatal: fall back to manual entry only
        }
        if (!window.eventTypesCache) {
          // Lazy-load event types and re-render the If form once ready
          try {
            populateEventTypes().then(() => {
              const sel = document.getElementById('action-select');
              if (sel && sel.value === 'If') {
                renderActionProperties();
              }
            });
          } catch (_) {}
        }

        html = `
          ${triggerType === 'Tag Added' ? `
          <div style="background:#2c1f1f;border:1px solid #7f1d1d;color:#fca5a5;padding:.75rem;border-radius:.5rem;margin-bottom:.75rem">
            Warning: For Tag Added triggers, this condition can reference any event type's data. If the contact lacks the required data, evaluation will error and default to the false path.
          </div>` : ''}

          <div class="form-group">
            <label class="form-label">Field</label>
            <div class="multi-select">
              <button type="button" class="multi-select-button" onclick="toggleMultiSelect('if-field')">
                <span id="if-field-display">${defaultField}</span>
                <span class="material-icons-outlined">expand_more</span>
              </button>
              <div class="multi-select-options" id="if-field-options" style="max-height:340px;overflow:auto">
                <div style="padding:.5rem .75rem;border-bottom:1px solid #2C4A43;position:sticky;top:0;background:#0b1916;z-index:1">
                  <input id="if-field-search" class="form-select" placeholder="Search fields..." oninput="filterIfFieldOptions()" />
                  <div id="if-field-categories" style="display:flex;gap:.5rem;margin-top:.5rem;flex-wrap:wrap">
                    <button type="button" class="context-btn" data-cat="all" onclick="setIfFieldCategory('all')">All</button>
                    <button type="button" class="context-btn" data-cat="contact" onclick="setIfFieldCategory('contact')">Contact</button>
                    <button type="button" class="context-btn" data-cat="booking" onclick="setIfFieldCategory('booking')">Booking</button>
                    <button type="button" class="context-btn" data-cat="answers" onclick="setIfFieldCategory('answers')">Answers</button>
                    <button type="button" class="context-btn" data-cat="custom" onclick="setIfFieldCategory('custom')">Custom</button>
                  </div>
                </div>
                <div id="if-field-list" style="padding-top:.5rem">
                  <div class="if-cat-header" data-category="contact" style="padding:.5rem .75rem;color:#9ca3af;font-size:.8rem">Contact</div>
                  ${contactFields.map(([f,label]) => `<label class=\"multi-select-option\" data-category=\"contact\" data-text=\"${(label+' '+f).toLowerCase()}\" onclick=\"selectIfField('${f}')\"><span>${label} <span style=\\"color:#6b7280\\">(${f})</span></span></label>`).join('')}
                  <div class="if-cat-header" data-category="booking" style="padding:.5rem .75rem;color:#9ca3af;font-size:.8rem">Booking</div>
                  ${bookingFields.map(([f,label]) => `<label class=\"multi-select-option\" data-category=\"booking\" data-text=\"${(label+' '+f).toLowerCase()}\" onclick=\"selectIfField('${f}')\"><span>${label} <span style=\\"color:#6b7280\\">(${f})</span></span></label>`).join('')}
                  <div class="if-cat-header" data-category="answers" style="padding:.5rem .75rem;color:#9ca3af;font-size:.8rem">Available Answers</div>
                  ${dynamicAnswersOptions}
                  <div class="if-cat-header" data-category="custom" style="padding:.5rem .75rem;color:#9ca3af;font-size:.8rem">Custom Answers</div>
                  <div id="if-custom-answers-container" data-category="custom" style="padding:.5rem .75rem">
                    <input id="if-custom-answer-key" class="form-select" placeholder="answers.<questionKey> or booking.answers.<key>" />
                    <div style="margin-top:.25rem;text-align:right">
                      <button type="button" class="context-btn" onclick="applyIfCustomAnswer()">Use</button>
                    </div>
                    <div style="margin-top:.35rem;color:#9ca3af;font-size:.85rem">
                      Not sure which key to use? See the <a href="/editor/guide#custom-keys" target="_blank" style="color:#34D399;text-decoration:none">Custom Keys guide</a>.
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="form-group">
            <label class="form-label">Operator</label>
            <select id="if-operator" class="form-select">
              <option value="equals">Equals</option>
              <option value="not_equals">Does not equal</option>
              <option value="contains">Contains</option>
              <option value="not_contains">Does not contain</option>
              <option value="gt">Greater than</option>
              <option value="lt">Less than</option>
              <option value="exists">Exists</option>
              <option value="not_exists">Does not exist</option>
              <option value="in">In list (comma separated)</option>
            </select>
          </div>

          <div class="form-group" id="if-value-group">
            <label class="form-label">Value</label>
            <input id="if-value" class="form-select" placeholder="Value or CSV for 'in'" />
            <div style="margin-top:.25rem;color:#9ca3af;font-size:.85rem">Numbers compare numerically; others compare as strings. Use ISO dates for lexicographic comparisons.</div>
          </div>

          <input type="hidden" id="if-field" value="${defaultField}" />
        `;
      }
      
      container.innerHTML = html;

      // If editing, prefill Send Email fields
      if (actionType === 'Send Email' && selectedNode) {
        const existingNode = nodes.find(n => n.id === selectedNode);
        if (existingNode && existingNode.data && existingNode.data.type === 'Send Email') {
          const p = existingNode.data.properties || {};
          const set = (id, val) => { const el = document.getElementById(id); if (el && val !== undefined && val !== null) el.value = val; };
          const manualEl = document.getElementById('email-manual-recipient');
          const toWrap = document.getElementById('email-to-wrapper');
          const manual = !(p.useTriggerRecipient === true || (!p.to || (Array.isArray(p.to) && p.to.length === 0)));
          if (manualEl) manualEl.checked = manual;
          if (toWrap) toWrap.style.display = manual ? 'block' : 'none';
          set('email-to', Array.isArray(p.to) ? p.to.join(', ') : (p.to || ''));
          set('email-cc', Array.isArray(p.cc) ? p.cc.join(', ') : (p.cc || ''));
          set('email-bcc', Array.isArray(p.bcc) ? p.bcc.join(', ') : (p.bcc || ''));
          set('email-subject', p.subject || '');
          const bodyEl = document.getElementById('email-body');
          if (bodyEl) bodyEl.value = p.body || '';
          const htmlEl = document.getElementById('email-is-html');
          if (htmlEl) htmlEl.checked = !!p.isHtml;
        }
      }

      // Wire up manual recipient toggle (for create/edit)
      if (actionType === 'Send Email') {
        const manualEl = document.getElementById('email-manual-recipient');
        const toWrap = document.getElementById('email-to-wrapper');
        if (manualEl && toWrap) {
          const sync = () => { toWrap.style.display = manualEl.checked ? 'block' : 'none'; };
          manualEl.addEventListener('change', sync);
          sync();
        }
      }

      if (actionType === 'If') {
        // Toggle visibility of value field for exists/not_exists
        const opEl = document.getElementById('if-operator');
        const valueGroup = document.getElementById('if-value-group');
        if (opEl && valueGroup) {
          const sync = () => {
            const op = opEl.value;
            valueGroup.style.display = ['exists','not_exists'].includes(op) ? 'none' : 'block';
          };
          opEl.addEventListener('change', sync);
          sync();
        }

        // Prefill If when editing
        if (selectedNode) {
          const nodeData = nodes.find(n => n.id === selectedNode);
          if (nodeData && nodeData.data && nodeData.data.type === 'If') {
            const p = nodeData.data.properties || {};
            const field = p.field || 'contact.email';
            const operator = p.operator || 'equals';
            const value = p.value ?? '';
            const fieldDisplay = document.getElementById('if-field-display');
            const fieldHidden = document.getElementById('if-field');
            const opSelect = document.getElementById('if-operator');
            const valueEl = document.getElementById('if-value');
            if (fieldDisplay) fieldDisplay.textContent = field;
            if (fieldHidden) fieldHidden.value = field;
            if (opSelect) opSelect.value = operator;
            if (valueEl && value !== undefined) valueEl.value = Array.isArray(value) ? value.join(', ') : value;
          }
        }

        // Initialize category and search state
        setIfFieldCategory('all');
        filterIfFieldOptions();
      }
    }

    async function populateEventTypes() {
      try {
        const res = await fetch(`${API_URL}/event-types`);
        if (res.ok) {
          const eventTypes = await res.json();
          // Cache event types for conditional builder (If action)
          window.eventTypesCache = Array.isArray(eventTypes) ? eventTypes : [];
          const container = document.getElementById('event-type-options');
          if (!container) {
            console.warn('[IF][EVENT_TYPES] options container missing, skipping render');
            return;
          }
          console.debug('[IF][EVENT_TYPES] rendering', { count: window.eventTypesCache.length });
          container.innerHTML = eventTypes.map(et => `
            <label class="multi-select-option" onclick="selectEventType('${et.id}', '${et.title.replace(/'/g, "&#39;")}')">
              <span>${et.title}</span>
            </label>
          `).join('');
          
          // Restore selected event types if they exist
          if (window.selectedEventTypes && window.selectedEventTypes.length > 0) {
            const wrapper = document.getElementById('event-type-options');
            const display = wrapper && wrapper.previousElementSibling ? wrapper.previousElementSibling.querySelector('span') : null;
            if (display) {
              display.textContent = window.selectedEventTypes.join(', ');
            }
          }
        }
      } catch (error) {
        console.error('Error fetching event types:', error);
      }
    }

    async function populateTags() {
      try {
        const res = await fetch(`${API_URL}/tags`, { credentials: 'include' });
        if (res.ok) {
          const tags = await res.json();
          const container = document.getElementById('tag-options');
          if (!container) return;
          console.debug('[TAGS] rendering', { count: Array.isArray(tags) ? tags.length : 0 });
          container.innerHTML = (Array.isArray(tags) ? tags : []).map(tag => `
            <label class="multi-select-option" onclick="selectTag('${tag.name}')">
              <span>${tag.name}</span>
            </label>
          `).join('');
          // Restore selected tags if they exist
          if (window.selectedTags && window.selectedTags.length > 0) {
            const display = document.getElementById('tag-display');
            if (display) {
              display.textContent = window.selectedTags.join(', ');
              display.style.color = '#34D399';
            }
            const confirmBtn = document.getElementById('tag-confirm');
            if (confirmBtn) confirmBtn.style.display = 'block';
            }
        } else if (res.status === 401) {
          handleUnauthorizedRedirect();
        }
      } catch (error) {
        console.error('Error fetching tags:', error);
      }
    }

    async function populateActionTags() {
      try {
        const res = await fetch(`${API_URL}/tags`, { credentials: 'include' });
        if (res.ok) {
          const tags = await res.json();
          const container = document.getElementById('action-tag-options');
          if (!container) return;
          if (window.__DEBUG_EDITOR__) console.debug('[ACTION_TAGS] rendering', { count: Array.isArray(tags) ? tags.length : 0 });
          container.innerHTML = (Array.isArray(tags) ? tags : []).map(tag => `
            <label class="multi-select-option" onclick="selectActionTag('${tag.name}')">
              <span>${tag.name}</span>
            </label>
          `).join('');
        } else if (res.status === 401) {
          handleUnauthorizedRedirect();
        }
      } catch (error) {
        console.error('Error fetching action tags:', error);
      }
    }

    function toggleMultiSelect(type) {
      const options = document.getElementById(`${type}-options`);
      if (options) {
        options.classList.toggle('show');
        
        // Close other open dropdowns
        document.querySelectorAll('.multi-select-options').forEach(other => {
          if (other !== options) {
            other.classList.remove('show');
          }
        });
      }
    }
    
    // Close dropdowns when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.multi-select')) {
        document.querySelectorAll('.multi-select-options').forEach(dropdown => {
          dropdown.classList.remove('show');
        });
      }
    });

    function selectEventType(eventTypeId, eventTypeName) {
      if (!window.selectedEventTypes) window.selectedEventTypes = [];
      if (!window.selectedEventTypeIds) window.selectedEventTypeIds = [];
      
      const idxName = window.selectedEventTypes.indexOf(eventTypeName);
      const idxId = window.selectedEventTypeIds.indexOf(eventTypeId);
      const isSelected = idxName > -1 || idxId > -1;
      if (isSelected) {
        if (idxName > -1) window.selectedEventTypes.splice(idxName, 1);
        if (idxId > -1) window.selectedEventTypeIds.splice(idxId, 1);
      } else {
        window.selectedEventTypes.push(eventTypeName);
        window.selectedEventTypeIds.push(eventTypeId);
      }
      
      // Update display
      const display = document.querySelector('#event-type-options').previousElementSibling.querySelector('span');
      if (display) {
        if (window.selectedEventTypes.length > 0) {
          display.textContent = window.selectedEventTypes.join(', ');
        } else {
          display.textContent = 'Select event types...';
        }
      }
      
      // Close the dropdown
      const options = document.getElementById('event-type-options');
      if (options) {
        options.classList.remove('show');
      }
    }
    
    function selectAllEventTypes() {
      // Get all available event types from the options
      const eventTypeOptions = document.querySelectorAll('#event-type-options .multi-select-option span');
      if (eventTypeOptions.length > 0) {
        window.selectedEventTypes = Array.from(eventTypeOptions).map(span => span.textContent);
        
        // Update display
        const display = document.querySelector('#event-type-options').previousElementSibling.querySelector('span');
        if (display) {
          display.textContent = window.selectedEventTypes.join(', ');
        }
      }
    }

    function selectAllTags() {
      // Get all available tags from the options
      const tagOptions = document.querySelectorAll('#tag-options .multi-select-option span');
      if (tagOptions.length > 0) {
        window.selectedTags = Array.from(tagOptions).map(span => span.textContent);
        
        // Update display
        const display = document.getElementById('tag-display');
        if (display) {
          display.textContent = window.selectedTags.join(', ');
        }
        
        // Show confirm button
        const confirmBtn = document.getElementById('tag-confirm');
        if (confirmBtn) {
          confirmBtn.style.display = 'block';
        }
      }
    }

        function selectActionTag(tagName) {
      const display = document.getElementById('action-tag-display');
      if (display) {
        display.textContent = tagName;
      }
      
      // Close the dropdown
      const options = document.getElementById('action-tag-options');
      if (options) {
        options.classList.remove('show');
      }
      
      // Store the selected tag for later use
      window.selectedActionTag = tagName;

      // Show confirm button
      const confirmBtn = document.getElementById('action-tag-confirm');
      if (confirmBtn) {
        confirmBtn.style.display = 'block';
      }
    }
    
    function confirmTagSelection() {
      // Hide confirm button after confirmation
      const confirmBtn = document.getElementById('tag-confirm');
      if (confirmBtn) {
        confirmBtn.style.display = 'none';
      }
      
      // Update display to show confirmed selection
      const display = document.getElementById('tag-display');
      if (display && window.selectedTags && window.selectedTags.length > 0) {
        display.textContent = `✓ ${window.selectedTags.join(', ')}`;
        display.style.color = '#34D399';
      }
    }
    
    function selectTag(tagName) {
      // Initialize selectedTags array if it doesn't exist
      if (!window.selectedTags) {
        window.selectedTags = [];
      }
      
      // Toggle tag selection
      const index = window.selectedTags.indexOf(tagName);
      if (index > -1) {
        window.selectedTags.splice(index, 1);
      } else {
        window.selectedTags.push(tagName);
      }
      
      // Update display
      const display = document.getElementById('tag-display');
      if (display) {
        if (window.selectedTags.length > 0) {
          display.textContent = window.selectedTags.join(', ');
          // Show confirm button
          const confirmBtn = document.getElementById('tag-confirm');
          if (confirmBtn) {
            confirmBtn.style.display = 'block';
          }
          } else {
          display.textContent = 'Select tags...';
          // Hide confirm button
          const confirmBtn = document.getElementById('tag-confirm');
          if (confirmBtn) {
            confirmBtn.style.display = 'none';
          }
        }
      }
      
      // Close the dropdown
      const options = document.getElementById('tag-options');
      if (options) {
        options.classList.remove('show');
      }
    }

    function confirmActionTag() {
      // Hide confirm button after confirmation
      const confirmBtn = document.getElementById('action-tag-confirm');
      if (confirmBtn) {
        confirmBtn.style.display = 'none';
      }
      
      // Update display to show confirmed selection
      const display = document.getElementById('action-tag-display');
      if (display && window.selectedActionTag) {
        display.textContent = `✓ ${window.selectedActionTag}`;
        display.style.color = '#34D399';
      }
    }

    async function createActionTag() {
      const input = document.getElementById('action-new-tag-name');
      const status = document.getElementById('action-create-tag-status');
      if (!input) return;
      const name = (input.value || '').trim();
      if (!name) {
        if (status) status.textContent = 'Please enter a tag name.';
        return;
      }
      try {
        const res = await fetch(`${API_URL}/tags`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({ name })
        });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        // Clear input and update status
        input.value = '';
        if (status) status.textContent = `Created tag "${name}"`;
        // Refresh tag options so the new tag appears
        await populateActionTags();
        // Auto-select the newly created tag
        selectActionTag(name);
        confirmActionTag();
      } catch (e) {
        if (status) status.textContent = 'Failed to create tag';
        console.error('createActionTag error:', e);
      }
    }

    // IF action helpers
    function selectIfField(fieldPath) {
      const display = document.getElementById('if-field-display');
      const hidden = document.getElementById('if-field');
      if (display) display.textContent = fieldPath;
      if (hidden) hidden.value = fieldPath;
      const options = document.getElementById('if-field-options');
      if (options) options.classList.remove('show');
    }
    function applyIfCustomAnswer() {
      const input = document.getElementById('if-custom-answer-key');
      if (!input) return;
      let key = input.value.trim();
      if (!key) return;
      // Normalize to booking.answers.<key> if user typed shorthand answers.<key>
      if (key.startsWith('answers.')) key = `booking.${key}`;
      if (!key.startsWith('booking.answers.')) key = `booking.answers.${key}`;
      selectIfField(key);
    }

    // Category + search for IF field dropdown
    window.currentIfFieldCategory = 'all';
    function setIfFieldCategory(cat) {
      window.currentIfFieldCategory = cat;
      // Update button active styles
      const btns = document.querySelectorAll('#if-field-categories .context-btn');
      btns.forEach(b => {
        if (b.getAttribute('data-cat') === cat) {
          b.style.background = '#34D399';
          b.style.color = '#1A2E29';
        } else {
          b.style.background = '';
          b.style.color = '';
        }
      });
      filterIfFieldOptions();
    }

    function filterIfFieldOptions() {
      const searchEl = document.getElementById('if-field-search');
      const q = (searchEl ? searchEl.value : '').toLowerCase().trim();
      const cat = window.currentIfFieldCategory || 'all';
      const list = document.getElementById('if-field-options');
      if (!list) return;
      const items = list.querySelectorAll('label.multi-select-option, .if-cat-header, #if-custom-answers-container');

      // First pass: show/hide by category
      items.forEach(el => {
        const elCat = el.getAttribute('data-category');
        let showByCat = cat === 'all' || (elCat ? elCat === cat : true);
        // Always keep sticky header (search/categories wrapper) visible
        if (el.id === 'if-field-categories' || el.id === 'if-field-search') showByCat = true;
        el.style.display = showByCat ? '' : 'none';
      });

      // Second pass: apply search filter within visible category
      if (q) {
        items.forEach(el => {
          if (el.tagName.toLowerCase() === 'label') {
            if (el.style.display === 'none') return; // already hidden by category
            const text = (el.getAttribute('data-text') || el.textContent || '').toLowerCase();
            el.style.display = text.includes(q) ? '' : 'none';
          }
        });
        // Hide headers with no following visible items of same category
        const headers = list.querySelectorAll('.if-cat-header');
        headers.forEach(h => {
          if (h.style.display === 'none') return;
          const hCat = h.getAttribute('data-category');
          let hasVisible = false;
          let next = h.nextElementSibling;
          while (next && !next.classList.contains('if-cat-header')) {
            if (next.style.display !== 'none') { hasVisible = true; break; }
            next = next.nextElementSibling;
          }
          h.style.display = hasVisible ? '' : 'none';
        });
      } else {
        // No search: show headers relevant to selected category
        const headers = list.querySelectorAll('.if-cat-header');
        headers.forEach(h => {
          const hCat = h.getAttribute('data-category');
          h.style.display = (cat === 'all' || hCat === cat) ? '' : 'none';
        });
      }
    }

    function saveTrigger() {
      const triggerType = document.getElementById('trigger-select').value;
      const triggerNode = nodes.find(n => n.type === 'trigger');
      
      if (!triggerNode) return;
      
      let properties = {};
      
      if (triggerType === 'Meeting Scheduled') {
        properties.eventTypes = window.selectedEventTypes || [];
        properties.eventTypeIds = window.selectedEventTypeIds || [];
      } else if (triggerType === 'Tag Added') {
        properties.tags = window.selectedTags || [];
      }
      
      // Update trigger node
      updateTriggerNode({ type: triggerType, properties });
      
      // Strong guard: remove guides if configured
      removeGuidesIfConfigured();
      
      closeTriggerModal();
    }

    function saveAction() {
      logOrder('saveAction start');
      const selectEl = document.getElementById('action-select');
      const actionType = selectEl ? selectEl.value : '';
      const parentNodeId = selectedNode;
      
      // If we have an orb-drag context, prioritize it even if selectedNode is null
      if (!parentNodeId && window.orbDragContext) {
        logOrder('saveAction using orbDragContext');
      } else if (!parentNodeId) {
        logOrder('saveAction no parentNodeId - aborting');
        return;
      }
      
      let properties = {};

      // Handle orb-connect upfront without blocking on validations
      if (window.orbDragContext) {
        logOrder('saveAction orb-connect path');
        logOrder(`saveAction orb-connect source: ${window.orbDragContext.sourceNode?.id}, target: ${window.orbDragContext.targetNode?.id}`);
        try {
          const { sourceNode, targetNode } = window.orbDragContext;
          
          // Validate that we have two different nodes for combining
          if (!sourceNode || !targetNode || sourceNode.id === targetNode.id) {
            logOrder('saveAction invalid orb-connect context - falling back to normal placement');
            window.orbDragContext = null;
            // Fall through to normal placement logic
          } else {
            const safeType = actionType || 'Add Tag';
            
            // Collect properties for orb-connect operations
            let safeProps = {};
            if (safeType === 'Add Tag') {
              safeProps.tag = window.selectedActionTag || '';
            }
            if (safeType === 'Send Email') {
              const val = id => {
                const el = document.getElementById(id);
                return el ? el.value.trim() : '';
              };
              const csv = s => s ? s.split(',').map(x => x.trim()).filter(Boolean) : [];
              const manual = !!(document.getElementById('email-manual-recipient')?.checked);
              const toList = csv(val('email-to'));
              safeProps = {
                useTriggerRecipient: !manual,
                to: manual ? toList : [],
                cc: csv(val('email-cc')),
                bcc: csv(val('email-bcc')),
                subject: val('email-subject'),
                body: val('email-body'),
                isHtml: !!(document.getElementById('email-is-html')?.checked)
              };
            }
            if (safeType === 'If') {
              const val = id => {
                const el = document.getElementById(id);
                return el ? el.value.trim() : '';
              };
              const csv = s => s ? s.split(',').map(x => x.trim()).filter(Boolean) : [];
              const field = val('if-field');
              const operator = val('if-operator');
              const value = val('if-value');
              const triggerType = val('if-trigger-type');
              safeProps = {
                field: field,
                operator: operator,
                value: value,
                triggerType: triggerType
              };
            }
            
            const inserted = insertActionBetweenOrbs({ type: safeType, properties: safeProps }, sourceNode, targetNode);
            if (safeType === 'If' && inserted && inserted.element) {
              if (!inserted.data.properties) inserted.data.properties = {};
              if (!inserted.data.properties.ifId) inserted.data.properties.ifId = `if_${Date.now()}_${Math.random().toString(36).slice(2)}`;
              const trueNode = addControlNodeAfterElement(inserted.element, 'True');
              const falseNode = addControlNodeAfterElement(inserted.element, 'False');
              if (trueNode && trueNode.element) trueNode.data = { type: 'True', properties: { parentIfId: inserted.data.properties.ifId, ifDomId: inserted.element.id, branch: 'true' } };
              if (falseNode && falseNode.element) falseNode.data = { type: 'False', properties: { parentIfId: inserted.data.properties.ifId, ifDomId: inserted.element.id, branch: 'false' } };
            }
            window.orbDragContext = null;
            closeActionModal();
            return;
          }
        } catch (e) {
          try { console.error('[ORB_CONNECT] saveAction error', e); } catch {}
          alert('Failed to insert action between orbs. See console for details.');
          return;
        }
      }
      
      if (actionType === 'Add Tag') {
        properties.tag = window.selectedActionTag || '';
      }
      if (actionType === 'Send Email') {
        const val = id => {
          const el = document.getElementById(id);
          return el ? el.value.trim() : '';
        };
        const csv = s => s ? s.split(',').map(x => x.trim()).filter(Boolean) : [];
        const manual = !!(document.getElementById('email-manual-recipient')?.checked);
        const toList = csv(val('email-to'));
        properties = {
          useTriggerRecipient: !manual,
          to: manual ? toList : [],
          cc: csv(val('email-cc')),
          bcc: csv(val('email-bcc')),
          subject: val('email-subject'),
          body: val('email-body'),
          isHtml: !!(document.getElementById('email-is-html')?.checked)
        };
        if (manual && !toList.length) {
          alert('Please provide at least one recipient in To');
          return;
        }
        if (!properties.subject) {
          alert('Please provide an email subject');
          return;
        }
        if (!properties.body) {
          alert('Please provide an email body');
          return;
        }
      }
      if (actionType === 'If') {
        const field = document.getElementById('if-field')?.value?.trim();
        const operator = document.getElementById('if-operator')?.value;
        const rawValue = document.getElementById('if-value')?.value ?? '';
        if (!field || !operator) {
          alert('Please select a field and operator for the If condition');
          return;
        }
        let value = rawValue;
        if (['gt','lt'].includes(operator)) {
          const n = Number(rawValue);
          if (!Number.isFinite(n)) {
            alert('Please enter a valid number for the comparison');
            return;
          }
          value = n;
        } else if (operator === 'in') {
          value = (rawValue || '').split(',').map(s => s.trim()).filter(Boolean);
          if (value.length === 0) {
            alert('Please provide at least one list item for the "in" operator');
            return;
          }
        }
        const triggerType = nodes.find(n => n.type === 'trigger')?.data?.type || 'Meeting Scheduled';
        properties = { field, operator };
        if (!['exists','not_exists'].includes(operator)) properties.value = value;
        properties.triggerType = triggerType;
        if (triggerType === 'Tag Added') properties.missingDataBehavior = 'default_false_path_on_error';
      }
      
      if (actionType === 'Add Tag' && !properties.tag) {
        alert('Please select a tag');
        return;
      }
      
      // Check if this is an insert operation
      if (parentNodeId === 'insert' && window.insertConnection) {
        const inserted = insertActionBetween({ type: actionType, properties }, window.insertConnection);
        // If IF, auto-create True/False headers
        if (actionType === 'If' && inserted && inserted.element) {
          if (!inserted.data.properties) inserted.data.properties = {};
          if (!inserted.data.properties.ifId) inserted.data.properties.ifId = `if_${Date.now()}_${Math.random().toString(36).slice(2)}`;
          const trueNode = addControlNodeAfterElement(inserted.element, 'True');
          const falseNode = addControlNodeAfterElement(inserted.element, 'False');
          if (trueNode && trueNode.element) trueNode.data = { type: 'True', properties: { parentIfId: inserted.data.properties.ifId, ifDomId: inserted.element.id, branch: 'true' } };
          if (falseNode && falseNode.element) falseNode.data = { type: 'False', properties: { parentIfId: inserted.data.properties.ifId, ifDomId: inserted.element.id, branch: 'false' } };
        }
        window.insertConnection = null;
        closeActionModal();
        return;
      }
      
      // Check if this is an orb-connect operation
      if (parentNodeId === 'orb-connect' && window.orbDragContext) {
        const { sourceNode, targetNode } = window.orbDragContext;
        const inserted = insertActionBetweenOrbs({ type: actionType, properties }, sourceNode, targetNode);
        // If IF, auto-create True/False headers
        if (actionType === 'If' && inserted && inserted.element) {
          if (!inserted.data.properties) inserted.data.properties = {};
          if (!inserted.data.properties.ifId) inserted.data.properties.ifId = `if_${Date.now()}_${Math.random().toString(36).slice(2)}`;
          const trueNode = addControlNodeAfterElement(inserted.element, 'True');
          const falseNode = addControlNodeAfterElement(inserted.element, 'False');
          if (trueNode && trueNode.element) trueNode.data = { type: 'True', properties: { parentIfId: inserted.data.properties.ifId, ifDomId: inserted.element.id, branch: 'true' } };
          if (falseNode && falseNode.element) falseNode.data = { type: 'False', properties: { parentIfId: inserted.data.properties.ifId, ifDomId: inserted.element.id, branch: 'false' } };
        }
        window.orbDragContext = null;
        closeActionModal();
        return;
      }
      // Branch insertions from IF node (True / False columns)
      if (parentNodeId && parentNodeId.startsWith('branch-true-')) {
        const ifId = parentNodeId.replace('branch-true-', '');
        const { ifIndex, trueIndex } = findIfHeaders(ifId);
        if (ifIndex === -1 || trueIndex === -1) { closeActionModal(); return; }
        const actionNode = createNode(actionType, actionType, 'settings', getActionContent({ type: actionType, properties }));
        // Try to lock X to the parent IF's true header
        try {
          const anchors = ifHeaderCenters.get(nodes[ifIndex]?.data?.properties?.ifId);
          if (anchors && typeof anchors.trueX === 'number') {
            actionNode.style.left = `${anchors.trueX}px`;
          } else {
            const containerRect = container.getBoundingClientRect();
            const baseCenter = (rootCenterLockX != null) ? rootCenterLockX : Math.round(containerRect.width / 2);
            const baseOffset = 380;
            actionNode.style.left = `${baseCenter - baseOffset}px`;
          }
        } catch {
          const containerRect = container.getBoundingClientRect();
          const baseCenter = (rootCenterLockX != null) ? rootCenterLockX : Math.round(containerRect.width / 2);
          const baseOffset = 380;
          actionNode.style.left = `${baseCenter - baseOffset}px`;
        }
        actionNode.style.transform = 'translateX(-50%)';
        const trueEl = nodes[trueIndex].element;
        const containerRect = container.getBoundingClientRect();
        let y = trueEl.getBoundingClientRect().bottom - containerRect.top + 60;
        const ifStepId = nodes[ifIndex]?.data?.properties?.ifId;
        for (let i = 0; i < nodes.length; i++) {
          const d = nodes[i]?.data;
          if (d && d.properties && d.properties.parentIfId === ifStepId && d.properties.branch === 'true') {
            const r = nodes[i].element.getBoundingClientRect();
            y = Math.max(y, r.bottom - containerRect.top + 60);
          }
        }
        actionNode.style.top = `${y}px`;
        container.appendChild(actionNode);
        // Ensure a visible path from header to a newly added IF immediately
        try { if (actionType === 'If') WorkflowManager.createConnection(trueEl, actionNode, false); } catch {}
        const nodeData = { id: actionNode.id, type: 'action', element: actionNode, data: { type: actionType, properties: { ...properties, parentIfId: ifStepId, ifDomId: ifId, branch: 'true' } } };
        nodes.push(nodeData);
        StructureManager.rebuild();
        try { HistoryManager.recordSnapshot('branch-true-insert'); } catch {}
        closeActionModal();
        return;
      }
      if (parentNodeId && parentNodeId.startsWith('branch-false-')) {
        const ifId = parentNodeId.replace('branch-false-', '');
        const { ifIndex, falseIndex } = findIfHeaders(ifId);
        if (ifIndex === -1 || falseIndex === -1) { closeActionModal(); return; }
        const actionNode = createNode(actionType, actionType, 'settings', getActionContent({ type: actionType, properties }));
        // Try to lock X to the parent IF's false header
        try {
          const anchors = ifHeaderCenters.get(nodes[ifIndex]?.data?.properties?.ifId);
          if (anchors && typeof anchors.falseX === 'number') {
            actionNode.style.left = `${anchors.falseX}px`;
          } else {
            const containerRect = container.getBoundingClientRect();
            const baseCenter = (rootCenterLockX != null) ? rootCenterLockX : Math.round(containerRect.width / 2);
            const baseOffset = 380;
            actionNode.style.left = `${baseCenter + baseOffset}px`;
          }
        } catch {
          const containerRect = container.getBoundingClientRect();
          const baseCenter = (rootCenterLockX != null) ? rootCenterLockX : Math.round(containerRect.width / 2);
          const baseOffset = 380;
          actionNode.style.left = `${baseCenter + baseOffset}px`;
        }
        actionNode.style.transform = 'translateX(-50%)';
        const falseEl = nodes[falseIndex].element;
        const containerRect = container.getBoundingClientRect();
        let y = falseEl.getBoundingClientRect().bottom - containerRect.top + 60;
        const ifStepId = nodes[ifIndex]?.data?.properties?.ifId;
        for (let i = 0; i < nodes.length; i++) {
          const d = nodes[i]?.data;
          if (d && d.properties && d.properties.parentIfId === ifStepId && d.properties.branch === 'false') {
            const r = nodes[i].element.getBoundingClientRect();
            y = Math.max(y, r.bottom - containerRect.top + 60);
          }
        }
        actionNode.style.top = `${y}px`;
        container.appendChild(actionNode);
        // Ensure a visible path from header to a newly added IF immediately
        try { if (actionType === 'If') WorkflowManager.createConnection(falseEl, actionNode, false); } catch {}
        const nodeData = { id: actionNode.id, type: 'action', element: actionNode, data: { type: actionType, properties: { ...properties, parentIfId: ifStepId, ifDomId: ifId, branch: 'false' } } };
        nodes.push(nodeData);
        StructureManager.rebuild();
        try { HistoryManager.recordSnapshot('branch-false-insert'); } catch {}
        closeActionModal();
        return;
      }
      
      // Check if this is an "add after" operation
      if (parentNodeId && parentNodeId.startsWith('add-after-')) {
        const afterNodeId = parentNodeId.replace('add-after-', '');
        
        // Create the action node
        const actionNode = createNode(actionType, actionType, 'settings', getActionContent({ type: actionType, properties }));
        
        // Find the node to add after
        const afterNode = nodes.find(n => n.id === afterNodeId);
        if (!afterNode) {
          console.error('Could not find node to add after:', afterNodeId);
          closeActionModal();
          return;
        }
        
        // Determine if we are in a branch (True/False) and position accordingly
        const containerRect = container.getBoundingClientRect();
        const afterType = afterNode.data?.type;
        const afterProps = afterNode.data?.properties || {};
        let branchCtx = null;
        if (afterType === 'True' || afterType === 'False') {
          branchCtx = { parentIfId: afterProps.parentIfId, ifDomId: afterProps.ifDomId, branch: (afterType === 'True' ? 'true' : 'false') };
        } else if (afterProps && afterProps.parentIfId) {
          branchCtx = { parentIfId: afterProps.parentIfId, ifDomId: afterProps.ifDomId, branch: afterProps.branch };
        }
        
        if (branchCtx && branchCtx.parentIfId) {
          // Anchor horizontally to parent IF's branch header X if available
          let anchorX = null;
          try {
            const anchors = ifHeaderCenters.get(branchCtx.parentIfId);
            if (anchors) {
              anchorX = branchCtx.branch === 'true' ? anchors.trueX : anchors.falseX;
            }
          } catch {}
          if (typeof anchorX === 'number') {
            actionNode.style.left = `${anchorX}px`;
          } else {
            const columnLeft = branchCtx.branch === 'true' ? 'calc(50% - 280px)' : 'calc(50% + 280px)';
            actionNode.style.left = columnLeft;
          }
          actionNode.style.transform = 'translateX(-50%)';
          // Place below the last item in this branch
          let y;
          // Try to anchor from header if present
          const headerType = branchCtx.branch === 'true' ? 'True' : 'False';
          const header = nodes.find(n => n.data?.type === headerType && n.data?.properties?.parentIfId === branchCtx.parentIfId);
          if (header && header.element) {
            const headerRect = header.element.getBoundingClientRect();
            y = headerRect.bottom - containerRect.top + 60;
          } else {
            const afterRect = afterNode.element.getBoundingClientRect();
            y = afterRect.bottom - containerRect.top + 60;
          }
          for (const n of nodes) {
            const d = n.data;
            if (!d || d.type === 'If') continue;
            if (d.properties && d.properties.parentIfId === branchCtx.parentIfId && d.properties.branch === branchCtx.branch) {
              const r = n.element.getBoundingClientRect();
              y = Math.max(y, r.bottom - containerRect.top + 60);
            }
          }
          actionNode.style.top = `${y}px`;
          // Merge branch context into properties so connections build correctly
          properties = { ...properties, ...branchCtx };
        } else {
          // Not in a branch: position below the after node, centered
          const afterRect = afterNode.element.getBoundingClientRect();
          const topPosition = afterRect.bottom - containerRect.top + 120;
          actionNode.style.left = '50%';
          actionNode.style.top = `${topPosition}px`;
          actionNode.style.transform = 'translateX(-50%)';
        }
        
        container.appendChild(actionNode);
        
        // Add to nodes array
        const nodeData = { 
          id: actionNode.id, 
          type: 'action', 
          element: actionNode, 
          data: { type: actionType, properties } 
        };
        nodes.push(nodeData);
        
        // Rebuild the entire workflow structure to ensure all connections are created
        StructureManager.rebuild();
        try { HistoryManager.recordSnapshot('add-after'); } catch {}

        // If IF, auto-create True/False headers
        if (actionType === 'If') {
          if (!properties) properties = {};
          if (!properties.ifId) properties.ifId = `if_${Date.now()}_${Math.random().toString(36).slice(2)}`;
          // Update node data to include ifId
          nodeData.data = { type: actionType, properties };
          const trueNode = addControlNodeAfterElement(actionNode, 'True');
          const falseNode = addControlNodeAfterElement(actionNode, 'False');
          if (trueNode && trueNode.element) trueNode.data = { type: 'True', properties: { parentIfId: properties.ifId, ifDomId: actionNode.id, branch: 'true' } };
          if (falseNode && falseNode.element) falseNode.data = { type: 'False', properties: { parentIfId: properties.ifId, ifDomId: actionNode.id, branch: 'false' } };
        }
        
        // Add movement listeners to the new node
        addNodeMovementListeners();
        
        closeActionModal();
        return;
      }
      
      // Check if we're editing an existing action
      const existingNode = nodes.find(n => n.id === parentNodeId);
      if (existingNode && existingNode.type !== 'trigger') {
        // Update existing action
        existingNode.data = { type: actionType, properties };
        existingNode.element.querySelector('.node-title').textContent = actionType;
        existingNode.element.querySelector('.node-content').textContent = getActionContent({ type: actionType, properties });
        updateWorkflowFromNodes();
      } else {
        // Add new action node
        addActionNode({ type: actionType, properties }, nodes.length);
      }
      
      try { HistoryManager.recordSnapshot(existingNode ? 'editAction' : 'newAction'); } catch {}
      closeActionModal();
    }

    function updateTriggerNode(triggerData) {
      
      let triggerNode = nodes.find(n => n.type === 'trigger');
      
      if (!triggerNode) {
        // Create new trigger node if it doesn't exist
        const node = createNode('trigger', triggerData.type, 'play_circle', '', triggerData.domId || triggerData.id || null);
        node.style.left = '50%';
        node.style.top = '50px';
        node.style.transform = 'translateX(-50%)';
        
        // Override the click handler for the trigger node specifically
        node.removeEventListener('click', (e) => selectNode(node));
        node.addEventListener('click', (e) => {
          e.stopPropagation();
          openTriggerModal();
        });
        
        container.appendChild(node);
        
        triggerNode = { 
          id: node.id, 
          type: 'trigger', 
          element: node 
        };
        nodes.push(triggerNode);
        
      // Rebuild workflow structure to ensure proper connections
      StructureManager.rebuild();
      
      // Add movement listeners
      addNodeMovementListeners();
      }
      
      const node = triggerNode.element;
      const title = triggerData.type;
      let content = '';
      
      if (triggerData.type === 'Meeting Scheduled' && triggerData.properties?.eventTypes) {
        content = `Triggers when meetings are scheduled for: ${triggerData.properties.eventTypes.join(', ')}`;
      } else if (triggerData.type === 'Tag Added' && triggerData.properties?.tags) {
        content = `Triggers when tags are added: ${triggerData.properties.tags.join(', ')}`;
      } else {
        content = `Triggers on: ${triggerData.type}`;
      }
      
      node.querySelector('.node-title').textContent = title;
      node.querySelector('.node-content').textContent = content;
      
      // Store trigger data
      triggerNode.data = triggerData;
    try { HistoryManager.recordSnapshot('updateTriggerNode'); } catch {}
    }

    function addActionNode(actionData, index) {
      
      // Avoid duplicating True/False branch headers on load or rebuild
      if (actionData.type === 'True' || actionData.type === 'False') {
        const parentIfId = actionData.properties?.parentIfId;
        const branch = actionData.properties?.branch;
        if (parentIfId && branch) {
          const exists = nodes.some(n => n.data?.type === actionData.type && n.data?.properties?.parentIfId === parentIfId && n.data?.properties?.branch === branch);
          if (exists) {
            return;
          }
        }
      }
      
      // Find the trigger node (should be the first one)
      const triggerNode = nodes.find(n => n.type === 'trigger');
      if (!triggerNode) {
        console.error('No trigger node found when adding action');
        return;
      }
      
        const explicitId = actionData && (actionData.domId || actionData.id) ? (actionData.domId || actionData.id) : null;
        const actionNode = createNode(actionData.type, actionData.type, 'settings', getActionContent(actionData), explicitId);
        // Mark join nodes on the DOM for reliable detection in path rendering
        try {
          if (actionData && actionData.properties && actionData.properties.joinForIfId) {
            actionNode.dataset.joinForIfId = actionData.properties.joinForIfId;
          }
        } catch {}
      
      // Decide placement: if the action is in a branch, place in that column; otherwise center
      const containerRect = container.getBoundingClientRect();
      const branch = actionData.properties?.branch;
      const parentIfId = actionData.properties?.parentIfId;
      let topPosition;
      if (branch && parentIfId) {
        // Find the header for this branch to anchor below
        const headerType = branch === 'true' ? 'True' : 'False';
        const header = nodes.find(n => n.data?.type === headerType && n.data?.properties?.parentIfId === parentIfId);
        const containerRect = container.getBoundingClientRect();
        const baseCenter = (rootCenterLockX != null) ? rootCenterLockX : Math.round(containerRect.width / 2);
        const baseOffset = 380;
        actionNode.style.left = `${branch === 'true' ? (baseCenter - baseOffset) : (baseCenter + baseOffset)}px`;
        actionNode.style.transform = 'translateX(-50%)';
        if (header && header.element) {
          // Place below the header or last item in this branch
          const headerRect = header.element.getBoundingClientRect();
          topPosition = headerRect.bottom - containerRect.top + 60;
          for (const n of nodes) {
            const d = n.data;
            if (!d || d.type === 'If') continue;
            if (d.properties && d.properties.parentIfId === parentIfId && d.properties.branch === branch) {
              const r = n.element.getBoundingClientRect();
              topPosition = Math.max(topPosition, r.bottom - containerRect.top + 60);
            }
          }
        } else {
          // Fallback: position relative to trigger
          const parentRect = triggerNode.element.getBoundingClientRect();
          topPosition = parentRect.bottom - containerRect.top + 120;
        }
        actionNode.style.top = `${topPosition}px`;
      } else {
        // Centered linear placement (not in a branch)
        let parentNode = triggerNode;
        const lastActionNode = nodes.filter(n => n.type !== 'trigger').pop();
        if (lastActionNode) parentNode = lastActionNode;
        const parentRect = parentNode.element.getBoundingClientRect();
        topPosition = parentRect.bottom - containerRect.top + 120;
        actionNode.style.left = '50%';
        actionNode.style.top = `${topPosition}px`;
        actionNode.style.transform = 'translateX(-50%)';
      }
      
      container.appendChild(actionNode);
      
      const nodeData = { 
        id: actionNode.id, 
        type: 'action', 
        element: actionNode, 
        data: actionData 
      };
      nodes.push(nodeData);
      
      // Rebuild the entire workflow structure to ensure consistency
      StructureManager.rebuild();

      // Ensure big orbs reflect new structure immediately (no pan required)
      requestAnimationFrame(() => {
        try {
          const sortedForOrbs = [...nodes].sort((a, b) => {
            const at = (a && a._layout && typeof a._layout.top === 'number') ? a._layout.top : parseFloat(a?.element?.style?.top || '0');
            const bt = (b && b._layout && typeof b._layout.top === 'number') ? b._layout.top : parseFloat(b?.element?.style?.top || '0');
            return (at - bt);
          });
          StructureManager.placePathEndOrbs(sortedForOrbs);
          OrbManager.updateAllOrbPositions();
          WorkflowManager.updateAllConnections();
        } catch {}
      });

      // If we just added an IF, auto-create True/False headers
      if (actionData.type === 'If') {
        // If loading from persisted data that already includes True/False, do not auto-create
        if (isLoadingWorkflow) {
          addNodeMovementListeners();
          return;
        }
        if (!actionData.properties) actionData.properties = {};
        if (!actionData.properties.ifId) actionData.properties.ifId = `if_${Date.now()}_${Math.random().toString(36).slice(2)}`;
        nodeData.data = actionData;
        const trueNode = addControlNodeAfterElement(actionNode, 'True');
        const falseNode = addControlNodeAfterElement(actionNode, 'False');
        if (trueNode && trueNode.element) trueNode.data = { type: 'True', properties: { parentIfId: actionData.properties.ifId, ifDomId: actionNode.id, branch: 'true' } };
        if (falseNode && falseNode.element) falseNode.data = { type: 'False', properties: { parentIfId: actionData.properties.ifId, ifDomId: actionNode.id, branch: 'false' } };
        try {
          const snapshot = HistoryManager.buildSnapshot();
          const summary = Array.isArray(snapshot.steps) ? snapshot.steps.map(s => s?.type).join(', ') : 'none';
          console.debug('[IF][SAVE] Snapshot after header creation', { ifId: actionData.properties.ifId, stepsCount: snapshot.steps?.length, types: summary });
        } catch {}
        try { HistoryManager.recordSnapshot('after-create-headers'); } catch {}
      }
      
      // Add movement listeners to the new node
      addNodeMovementListeners();
    try { HistoryManager.recordSnapshot('addActionNode'); } catch {}
    }

    function insertActionBetween(actionData, connection) {
      logOrder(`insertActionBetween start from=${connection?.from?.id || 'el'} to=${connection?.to?.id || 'el'}`);
      
      // Create the new action node
      // Determine if this insertion is intended to join True/False branches of the same IF
      let joinForIfId = null;
      try {
        const fromNodeData = nodes.find(n => n.element === connection.from);
        const toNodeData = nodes.find(n => n.element === connection.to);
        const fromProps = fromNodeData?.data?.properties;
        const toProps = toNodeData?.data?.properties;
        const fromIf = fromProps?.parentIfId || (fromNodeData?.data?.type === 'If' ? (fromNodeData.data.properties?.ifId) : null);
        const toIf = toProps?.parentIfId || (toNodeData?.data?.type === 'If' ? (toNodeData.data.properties?.ifId) : null);
        if (fromIf && toIf && fromIf === toIf) joinForIfId = fromIf;
        else if (fromIf) joinForIfId = fromIf;
        else if (toIf) joinForIfId = toIf;
      } catch {}
      const actionNode = createNode(actionData.type, actionData.type, 'settings', getActionContent(actionData));
      try {
        if (actionData && actionData.properties && actionData.properties.joinForIfId) {
          actionNode.dataset.joinForIfId = actionData.properties.joinForIfId;
        }
      } catch {}
      
      const containerRect = container.getBoundingClientRect();
      if (joinForIfId) {
        // Place centered horizontally and below the deeper of the two branches
        const centerX = containerRect.width / 2;
        // Find deepest Y among true/false branch nodes for this IF
        let maxBottom = 0;
        for (const n of nodes) {
          const d = n.data;
          if (!d || d.type === 'If' || d.type === 'True' || d.type === 'False') continue;
          if (d.properties && d.properties.parentIfId === joinForIfId) {
            const r = n.element.getBoundingClientRect();
            maxBottom = Math.max(maxBottom, r.bottom - containerRect.top);
          }
        }
        // If no branch actions, anchor under headers
        if (maxBottom === 0) {
          const headers = nodes.filter(n => (n.data?.type === 'True' || n.data?.type === 'False') && n.data?.properties?.parentIfId === joinForIfId);
          headers.forEach(h => { const r = h.element.getBoundingClientRect(); maxBottom = Math.max(maxBottom, r.bottom - containerRect.top); });
        }
        actionNode.style.left = `${centerX}px`;
        actionNode.style.transform = 'translateX(-50%)';
        actionNode.style.top = `${Math.round(maxBottom + 60)}px`;
        // Mark as join node (do not set branch) so rebuild can wire both branches to it;
        // also remove any existing midpoint orbs for this IF block
        actionData.properties = { ...(actionData.properties || {}), joinForIfId: joinForIfId };
        try {
          // Remove insert orbs on If->True/False for this IF
          const conns = Array.from(WorkflowManager.connections.values());
          conns.forEach(c => {
            const fData = nodes.find(n => n.element === c.from)?.data || {};
            const tData = nodes.find(n => n.element === c.to)?.data || {};
            if ((fData?.type === 'If' && fData?.properties?.ifId === joinForIfId) || (tData?.type === 'If' && tData?.properties?.ifId === joinForIfId)) {
              const orb = WorkflowManager.insertOrbs.get(c.id);
              if (orb) { orb.remove(); WorkflowManager.insertOrbs.delete(c.id); }
            }
          });
        } catch {}
      } else {
        // Default: position the action node in the middle of the connection
        const fromRect = connection.from.getBoundingClientRect();
        const toRect = connection.to.getBoundingClientRect();
        const middleX = (fromRect.left + toRect.left) / 2 - containerRect.left;
        const middleY = (fromRect.bottom + toRect.top) / 2 - containerRect.top;
        actionNode.style.left = `${middleX - 100}px`; // 100 is half of node width
        actionNode.style.top = `${middleY - 25}px`; // 25 is half of node height
      }
      
      container.appendChild(actionNode);
      logOrder(`insertActionBetween node created id=${actionNode.id}`);
      
      const nodeData = { 
        id: actionNode.id, 
        type: 'action', 
        element: actionNode, 
        data: actionData 
      };
      
      // Insert the node into the nodes array at the correct position
      const fromNodeIndex = nodes.findIndex(n => n.element === connection.from);
      const toNodeIndex = nodes.findIndex(n => n.element === connection.to);
      
      if (fromNodeIndex !== -1 && toNodeIndex !== -1) {
        // Insert between the two nodes
        const insertIndex = Math.min(fromNodeIndex, toNodeIndex) + 1;
        nodes.splice(insertIndex, 0, nodeData);
      } else {
        // Fallback: add to end
        nodes.push(nodeData);
      }
      
       // Remove existing connection between the original endpoints if present
      try {
        for (const [connId, conn] of WorkflowManager.connections.entries()) {
          if (conn.from === connection.from && conn.to === connection.to) {
            WorkflowManager.removeConnection(connId);
             logOrder(`insertActionBetween removed old connection id=${connId}`);
             break;
          }
        }
      } catch {}

       // Create new connections: from -> inserted -> to
      try {
        WorkflowManager.createConnection(connection.from, actionNode, false);
        WorkflowManager.createConnection(actionNode, connection.to, false);
          logOrder('insertActionBetween created 2 connections');
        } catch {}

       // Unify with initial build by running an immediate rebuild (no debounce) so path logic is identical
       logOrder('insertActionBetween forceFullLineRebuild');
       forceFullLineRebuild();
      // Also ensure orbs reflect new structure immediately
      requestAnimationFrame(() => {
        try {
          const sortedForOrbs = [...nodes].sort((a, b) => {
            const at = (a && a._layout && typeof a._layout.top === 'number') ? a._layout.top : parseFloat(a?.element?.style?.top || '0');
            const bt = (b && b._layout && typeof b._layout.top === 'number') ? b._layout.top : parseFloat(b?.element?.style?.top || '0');
            return (at - bt);
          });
          StructureManager.placePathEndOrbs(sortedForOrbs);
          OrbManager.updateAllOrbPositions();
        } catch {}
      });
      
      // Add movement listeners
      addNodeMovementListeners();
      
    try { HistoryManager.recordSnapshot('insertActionBetween'); } catch {}
    logOrder('insertActionBetween end');
      return nodeData;
    }
    
    function insertActionBetweenOrbs(actionData, sourceNode, targetNode) {
      logOrder(`insertActionBetweenOrbs start src=${sourceNode?.id || sourceNode?.element?.id} tgt=${targetNode?.id || targetNode?.element?.id}`);
      
      // Ensure properties exist for the action
      if (!actionData.properties) {
        actionData.properties = {};
      }
      
      // Detect upfront if this insertion is a branch-join between True/False of the same IF
      let isJoin = false;
      let joinForIfId = null;
      try {
        const sData = sourceNode.data || nodes.find(n => n.element === sourceNode.element)?.data;
        const tData = targetNode.data || nodes.find(n => n.element === targetNode.element)?.data;
        const sIf = sData?.properties?.parentIfId || null;
        const tIf = tData?.properties?.parentIfId || null;
        const sBranch = sData?.properties?.branch || (sData?.type === 'True' ? 'true' : (sData?.type === 'False' ? 'false' : null));
        const tBranch = tData?.properties?.branch || (tData?.type === 'True' ? 'true' : (tData?.type === 'False' ? 'false' : null));
        if (sIf && tIf && sIf === tIf && sBranch && tBranch && sBranch !== tBranch) {
          joinForIfId = sIf;
          isJoin = true;
          actionData.properties.joinForIfId = joinForIfId;
        }
      } catch {}
      
      // Set default properties based on action type
      if (actionData.type === 'Add Tag' && !actionData.properties.tag) {
        actionData.properties.tag = 'New Tag';
      }
      
      // Create the new action node
      const actionNode = createNode(actionData.type, actionData.type, 'settings', getActionContent(actionData));
      
      // Position the new node between the source and target
      const containerRect = container.getBoundingClientRect();
      const sourceRect = sourceNode.element.getBoundingClientRect();
      const targetRect = targetNode.element.getBoundingClientRect();
      
      // Calculate position - horizontally between the two nodes, vertically below the lowest one
      const sourceX = sourceRect.left + sourceRect.width / 2 - containerRect.left;
      const targetX = targetRect.left + targetRect.width / 2 - containerRect.left;
      const midX = (sourceX + targetX) / 2;
      
      // Find the lowest (bottom-most) of the two nodes
      const sourceBottom = sourceRect.bottom - containerRect.top;
      const targetBottom = targetRect.bottom - containerRect.top;
      const lowestBottom = Math.max(sourceBottom, targetBottom);
      
      // Place the new node below the lowest node with some spacing
      const midY = lowestBottom + 120; // 120px below the lowest node
      
      
      actionNode.style.left = `${Math.round(midX)}px`;
      actionNode.style.transform = 'translateX(-50%)';
      actionNode.style.top = `${Math.round(midY)}px`;
      
      // Add the node to the DOM first
      container.appendChild(actionNode);
      logOrder(`insertActionBetweenOrbs node created id=${actionNode.id}`);
      
      // Add the node to the workflow
      const nodeData = { id: actionNode.id, type: 'action', element: actionNode, data: actionData };
      nodes.push(nodeData);
      
      // Add movement listeners
      addNodeMovementListeners();
      
      // Break existing connection between source and target if it exists
      try {
        for (const [connId, conn] of WorkflowManager.connections.entries()) {
          if (conn.from === sourceNode.element && conn.to === targetNode.element) {
            WorkflowManager.removeConnection(connId);
            logOrder(`insertActionBetweenOrbs removed old connection id=${connId}`);
            break;
          }
        }
      } catch {}
      
      // Create connections
      // If this is a branch-join, feed both branch ends INTO the new node (source -> new, target -> new)
      // Otherwise, insert normally (source -> new -> target)
      let conn1 = null, conn2 = null;
      if (isJoin) {
        conn1 = WorkflowManager.createConnection(sourceNode.element, actionNode, false);
        conn2 = WorkflowManager.createConnection(targetNode.element, actionNode, false);
        // Create source-anchored orbs under both branch sources immediately
        try { if (conn1) { WorkflowManager.createSourceInsertOrb(conn1); WorkflowManager.updateSourceInsertOrbPosition(conn1); } } catch {}
        try { if (conn2) { WorkflowManager.createSourceInsertOrb(conn2); WorkflowManager.updateSourceInsertOrbPosition(conn2); } } catch {}
      } else {
        conn1 = WorkflowManager.createConnection(sourceNode.element, actionNode, false);
        conn2 = WorkflowManager.createConnection(actionNode, targetNode.element, false);
      }
      logOrder(`insertActionBetweenOrbs created conn1=${!!conn1} conn2=${!!conn2}`);
      
      
      // Apply layout immediately to position the node at its final correct position
      try { LayoutManager.apply(); } catch {}
      logOrder('insertActionBetweenOrbs layout applied');
      
      // Update connections AFTER layout is applied to ensure correct positioning
      WorkflowManager.updateAllConnections();
      logOrder('insertActionBetweenOrbs connections updated');
      // Ensure orbs reflect new structure immediately for non-join inserts too
      try {
        WorkflowManager.addInsertOrbsForConnections();
        const sortedForOrbs = [...nodes].sort((a, b) => {
          const at = (a && a._layout && typeof a._layout.top === 'number') ? a._layout.top : parseFloat(a?.element?.style?.top || '0');
          const bt = (b && b._layout && typeof b._layout.top === 'number') ? b._layout.top : parseFloat(b?.element?.style?.top || '0');
          return (at - bt);
        });
        StructureManager.placePathEndOrbs(sortedForOrbs);
        WorkflowManager.cleanupStaleInsertOrbs();
        OrbManager.updateAllOrbPositions();
      } catch {}
      
      // Create implicit join connections if this is a combining action (only if not already treated as a join)
      if (!isJoin) try {
        // Check if the source and target are from different branches of the same IF
        const sourceData = sourceNode.data || nodes.find(n => n.element === sourceNode.element)?.data;
        const targetData = targetNode.data || nodes.find(n => n.element === targetNode.element)?.data;
        
        // (debug removed)
        
        
        if (sourceData?.properties?.parentIfId && targetData?.properties?.parentIfId && 
            sourceData.properties.parentIfId === targetData.properties.parentIfId &&
            sourceData.properties.branch !== targetData.properties.branch) {
          
          // (debug removed)
          
          // This is a combining action - create connections from both branch actions to it
          const ifId = sourceData.properties.parentIfId;
          const trueActions = nodes.filter(n => 
            n?.data?.properties?.parentIfId === ifId && 
            n?.data?.properties?.branch === 'true'
          );
          const falseActions = nodes.filter(n => 
            n?.data?.properties?.parentIfId === ifId && 
            n?.data?.properties?.branch === 'false'
          );
          
          if (trueActions.length > 0 && falseActions.length > 0) {
            const lastTrue = trueActions[trueActions.length - 1];
            const lastFalse = falseActions[falseActions.length - 1];
            
            
            if (lastTrue?.element) {
              WorkflowManager.createConnection(lastTrue.element, actionNode, true);
            }
            if (lastFalse?.element) {
              WorkflowManager.createConnection(lastFalse.element, actionNode, true);
            }
            
            // Update connections again and refresh orbs to position the new ones correctly
            WorkflowManager.updateAllConnections();
            logOrder('insertActionBetweenOrbs implicit join connections created + updated');
            try {
              // Ensure insert orbs exist/are positioned for the new connections
              WorkflowManager.addInsertOrbsForConnections();
              WorkflowManager.cleanupStaleInsertOrbs();
              // Recompute big bottom orbs now that branches changed
              const sortedForOrbs = [...nodes].sort((a, b) => {
                const at = (a && a._layout && typeof a._layout.top === 'number') ? a._layout.top : parseFloat(a?.element?.style?.top || '0');
                const bt = (b && b._layout && typeof b._layout.top === 'number') ? b._layout.top : parseFloat(b?.element?.style?.top || '0');
                return (at - bt);
              });
              StructureManager.placePathEndOrbs(sortedForOrbs);
              OrbManager.updateAllOrbPositions();
              // Force a connection refresh on next frame to ensure immediate paint
              try { scheduleConnectionRefresh && scheduleConnectionRefresh(); } catch {}
              requestAnimationFrame(() => { try { WorkflowManager.updateAllConnections(); OrbManager.updateAllOrbPositions(); } catch {} });
            } catch {}
          }
        }
      } catch (e) {
        console.error('Error creating immediate join connections:', e);
      }
      
      // Verify our connections exist and are properly positioned
      const allConnections = Array.from(WorkflowManager.connections.values());
      const ourConnections = allConnections.filter(conn => 
        (conn.from === sourceNode.element && conn.to === actionNode) ||
        (conn.from === actionNode && conn.to === targetNode.element) ||
        (conn.from === targetNode.element && conn.to === actionNode)
      );
      
      try { updateWorkflowFromNodes(); } catch {}
      
      // Record history
      try { HistoryManager.recordSnapshot('insertActionBetweenOrbs'); } catch {}
  // Ensure lines mirror initial build immediately
  logOrder('insertActionBetweenOrbs triggerFullStructureRebuild');
  try { triggerFullStructureRebuild(); } catch {}
  logOrder('insertActionBetweenOrbs end');
      
      return nodeData;
    }

    // Helper: add a lightweight branch header node (True/False) immediately after a given node element
    function addControlNodeAfterElement(afterNodeElement, type) {
      const content = type;
      const actionNode = createNode(type, type, 'settings', content);
      const afterRect = afterNodeElement.getBoundingClientRect();
      const containerRect = container.getBoundingClientRect();
      const topPosition = afterRect.bottom - containerRect.top + 80;
      
      // Position True/False headers in their respective columns
      const ifNode = nodes.find(n => n.element === afterNodeElement);
      const ifId = ifNode?.data?.properties?.ifId;
      const branch = type === 'True' ? 'true' : 'false';
      
      // Get the IF node's center position
      const ifCenter = afterRect.left + (afterRect.width / 2) - containerRect.left;
      const baseOffset = 380; // Same as in main positioning logic
      const leftPosition = branch === 'true' ? (ifCenter - baseOffset) : (ifCenter + baseOffset);
      
      actionNode.style.left = `${leftPosition}px`;
      actionNode.style.top = `${topPosition}px`;
      actionNode.style.transform = 'translateX(-50%)';
      container.appendChild(actionNode);
      const afterIndex = nodes.findIndex(n => n.element === afterNodeElement);
      const nodeData = { id: actionNode.id, type: 'action', element: actionNode, data: { type, properties: { parentIfId: ifId, ifDomId: afterNodeElement.id, branch } } };
      if (afterIndex >= 0) {
        nodes.splice(afterIndex + 1, 0, nodeData);
      } else {
        nodes.push(nodeData);
      }
      StructureManager.rebuild();
      addNodeMovementListeners();
      return nodeData;
    }

    function getActionContent(actionData) {
      if (actionData.type === 'Add Tag') {
        return `Adds tag: ${actionData.properties.tag}`;
      }
      if (actionData.type === 'Send Email') {
        const p = actionData.properties || {};
        const auto = p.useTriggerRecipient === true || (!p.to || (Array.isArray(p.to) && p.to.length === 0));
        const to = auto ? 'Contact' : (Array.isArray(p.to) ? p.to.join(', ') : (p.to || ''));
        const subj = p.subject || '';
        const mode = p.isHtml ? 'HTML' : 'Text';
        return `Email (${mode}) to ${to} — Subject: ${subj}`;
      }
      if (actionData.type === 'If') {
        const p = actionData.properties || {};
        const needsValue = !['exists','not_exists'].includes(p.operator);
        const val = Array.isArray(p.value) ? p.value.join(', ') : (p.value ?? '');
        const core = `If ${p.field} ${p.operator}${needsValue ? ' ' : ''}${needsValue ? val : ''}`;
        const warn = p.triggerType === 'Tag Added' ? ' — missing data -> false path' : '';
        return core + warn + '  •  Use buttons to add to True/False paths';
      }
      if (actionData.type === 'True') return 'True — actions in this branch run when the If condition evaluates to TRUE.';
      if (actionData.type === 'False') return 'False — actions in this branch run when the If condition evaluates to FALSE.';
      return `Action: ${actionData.type}`;
    }
    
    function editAction(actionNode) {
      const nodeData = nodes.find(n => n.element === actionNode);
      if (!nodeData) return;
      
      // If IF node: present branch controls instead of opening modal
      if (nodeData.data && nodeData.data.type === 'If') {
        try { decorateIfNodeForBranches(actionNode); } catch {}
        // Do not open modal for IF itself on click; let user choose branch buttons
        return;
      }

      // Open action modal with existing data
      selectedNode = actionNode.id;
      openActionModal(actionNode.id);
      
      // Pre-populate the form
      const actionSelect = document.getElementById('action-select');
      if (actionSelect) {
        actionSelect.value = nodeData.data.type;
        renderActionProperties();
        
        // Set the selected tag if it's an Add Tag action
        if (nodeData.data.type === 'Add Tag' && nodeData.data.properties?.tag) {
          window.selectedActionTag = nodeData.data.properties.tag;
          const display = document.getElementById('action-tag-display');
          if (display) {
            display.textContent = `✓ ${nodeData.data.properties.tag}`;
            display.style.color = '#34D399';
          }
        }

        // Prefill Send Email fields when editing
        if (nodeData.data.type === 'Send Email' && nodeData.data.properties) {
          const p = nodeData.data.properties;
          const set = (id, val) => { const el = document.getElementById(id); if (el && val !== undefined && val !== null) el.value = val; };
          const manualEl = document.getElementById('email-manual-recipient');
          const toWrap = document.getElementById('email-to-wrapper');
          const manual = !(p.useTriggerRecipient === true || (!p.to || (Array.isArray(p.to) && p.to.length === 0)));
          if (manualEl) manualEl.checked = manual;
          if (toWrap) toWrap.style.display = manual ? 'block' : 'none';
          set('email-to', Array.isArray(p.to) ? p.to.join(', ') : (p.to || ''));
          set('email-cc', Array.isArray(p.cc) ? p.cc.join(', ') : (p.cc || ''));
          set('email-bcc', Array.isArray(p.bcc) ? p.bcc.join(', ') : (p.bcc || ''));
          set('email-subject', p.subject || '');
          const bodyEl = document.getElementById('email-body');
          if (bodyEl) bodyEl.value = p.body || '';
          const htmlEl = document.getElementById('email-is-html');
          if (htmlEl) htmlEl.checked = !!p.isHtml;
        }
      }
    }
    
    function deleteAction(actionNode) {
      if (!confirm('Are you sure you want to delete this action?')) return;
      
      const nodeData = nodes.find(n => n.element === actionNode);
      if (!nodeData) return;
      
      
      // If deleting an IF node, cascade delete its True/False headers and branch actions
      try {
        if (nodeData.data && nodeData.data.type === 'If') {
          const ifId = nodeData.data.properties?.ifId;
          if (ifId) {
            const toRemove = nodes.filter(n => n.element !== actionNode && n.data && (
              ((n.data.type === 'True' || n.data.type === 'False') && n.data.properties?.parentIfId === ifId) ||
              (n.data.properties && n.data.properties.parentIfId === ifId)
            ));
            toRemove.forEach(n => {
              try { WorkflowManager.removeNodeConnections(n.element); } catch {}
              try { OrbManager.removeOrb(n.element); } catch {}
              try { if (n.element && n.element.id) releaseNodeIdByString(n.element.id); } catch {}
              if (n.element && n.element.parentNode) {
                n.element.remove();
              }
              const idx = nodes.findIndex(x => x.id === n.id);
              if (idx > -1) nodes.splice(idx, 1);
            });
          }
        }
      } catch (e) {
        console.warn('IF cascade delete warning:', e);
      }
      
      // Remove all connections involving this node
      WorkflowManager.removeNodeConnections(actionNode);
      
      // Remove the node's orb
      OrbManager.removeOrb(actionNode);
      
      // Remove the node from the DOM
      if (actionNode.parentNode) {
        actionNode.remove();
      }
      
      // Remove from nodes array
      const index = nodes.findIndex(n => n.element === actionNode);
      if (index > -1) {
        nodes.splice(index, 1);
      }

      // Free up this node's id for reuse
      try { if (actionNode && actionNode.id) releaseNodeIdByString(actionNode.id); } catch {}
      
      // Rebuild the entire workflow structure
      StructureManager.rebuild();
      
      // Update the workflow data
      updateWorkflowFromNodes();
      
    try { HistoryManager.recordSnapshot('deleteAction'); } catch {}
    }
    
    
    function validateWorkflowStructure() {
      try {
        // Check if we have a valid trigger
        const triggerNode = nodes.find(n => n.type === 'trigger');
        if (!triggerNode || !triggerNode.data || !triggerNode.data.type) {
          console.error('Invalid trigger node');
          return false;
        }
        
        // Check if trigger has required properties
        if (triggerNode.data.type === 'Meeting Scheduled' && (!triggerNode.data.properties?.eventTypes || triggerNode.data.properties.eventTypes.length === 0)) {
          console.error('Meeting Scheduled trigger requires event types');
          return false;
        }
        
        if (triggerNode.data.type === 'Tag Added' && (!triggerNode.data.properties?.tags || triggerNode.data.properties.tags.length === 0)) {
          console.error('Tag Added trigger requires tags');
          return false;
        }
        
        // Check if all action nodes have valid data
        const actionNodes = nodes.filter(n => n.type !== 'trigger');
        for (const actionNode of actionNodes) {
          if (!actionNode.data || !actionNode.data.type) {
            console.error('Invalid action node:', actionNode);
            return false;
          }
          
          // Check if Add Tag action has required properties
          if (actionNode.data.type === 'Add Tag' && (!actionNode.data.properties?.tag || actionNode.data.properties.tag === '')) {
            console.error('Add Tag action requires a tag');
            return false;
          }
        }
        // No End If/Else validation needed in True/False branching model

        return true;
      } catch (error) {
        console.error('Error validating workflow structure:', error);
        return false;
      }
    }
    
    function updateWorkflowFromNodes() {
      // Rebuild the workflow steps array from current nodes
      const steps = [];
      
      nodes.forEach(node => {
        // Only add non-trigger nodes to steps array
        if (node.type !== 'trigger' && node.data) {
          steps.push(node.data);
        }
      });
      
      
      // Update the current workflow data structure
      if (currentWorkflow) {
        const triggerNode = nodes.find(n => n.type === 'trigger');
        if (triggerNode && triggerNode.data) {
          currentWorkflow.data = {
            trigger: triggerNode.data.type,
            triggerEventTypes: triggerNode.data.properties?.eventTypes || [],
            triggerEventTypeIds: triggerNode.data.properties?.eventTypeIds || [],
            triggerTags: triggerNode.data.properties?.tags || [],
            steps: steps,
            status: true
          };
          } else {
        }
      } else {
      }
    }


    // Save workflow is deprecated in favor of autosave drafts + Apply to Main
    async function saveWorkflow() {
      const workflowNameInput = document.getElementById('workflow-name');
      const name = workflowNameInput.value.trim() || `Untitled Workflow`;
      
      if (nodes.length === 0) {
        alert('Please configure at least a trigger for your workflow');
        return;
      }
      
      const triggerNode = nodes.find(n => n.type === 'trigger');
      if (!triggerNode || !triggerNode.data) {
        alert('Please configure the trigger for your workflow');
        return;
      }
      
      // Validate workflow structure before saving
      if (!validateWorkflowStructure()) {
        alert('Workflow structure is invalid. Please check your configuration.');
        return;
      }
      
      // Always rebuild the workflow data from current nodes to ensure accuracy
      // Only include non-trigger nodes in steps array
      const steps = nodes
        .filter(node => node.type !== 'trigger')
        .map(node => node.data);
      
      
      // Prepare the workflow data structure - always use current node state
      const workflowData = {
        trigger: triggerNode.data.type,
        triggerEventTypes: triggerNode.data.properties?.eventTypes || [],
        triggerEventTypeIds: triggerNode.data.properties?.eventTypeIds || [],
        triggerTags: triggerNode.data.properties?.tags || [],
        steps: steps, // Include trigger in steps for consistency
        status: true,
        contextSpec: contextSpec || getDefaultContextSpec(),
        // No editorDraftUUID persisted; avoid local storage
      };
      
      // Update currentWorkflow.data to match what we're saving
      if (currentWorkflow) {
        currentWorkflow.data = workflowData;
      }
      
      
      try {
        if (currentWorkflow) {
          // Update existing workflow
          const updateData = {
            name,
            description: currentWorkflow.description || '',
            data: workflowData
          };
          
          const res = await fetch(`${API_URL}/workflows/${currentWorkflow.id}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify(updateData)
          });
          
          
          if (res.ok) {
            setCurrentWorkflowId(null);
            // Use URL parameters for navigation state
            window.location.href = '/dashboard?notification=Workflow updated successfully!';
          } else {
            const errorData = await res.json();
            console.error('Failed to update workflow:', errorData);
            showNotification('Failed to update workflow', 'error');
          }
        } else {
        // Creating new workflows directly is handled on init; no-op here
        showNotification('Use Apply to Main to publish your draft');
        }
      } catch (error) {
        console.error('Error saving workflow:', error);
        showNotification('Failed to save workflow', 'error');
      }
    }

    // Close modals when clicking outside
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('modal-backdrop')) {
        e.target.classList.add('hidden');
      }
    });

    // Handle trigger type change
    document.getElementById('trigger-select').addEventListener('change', renderTriggerProperties);
    
    // Handle action type change
    document.getElementById('action-select').addEventListener('change', renderActionProperties);
    
    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Delete' && selectedNode) {
        deleteSelectedNode();
      } else if (e.key === 'Escape') {
        if (triggerModal.classList.contains('hidden') && actionModal.classList.contains('hidden')) {
          // Deselect node
          if (selectedNode) {
            selectedNode.classList.remove('selected');
            selectedNode = null;
          }
        } else {
          // Close modals
          closeTriggerModal();
          closeActionModal();
        }
      }
    });
    
    function deleteSelectedNode() {
      if (!selectedNode || selectedNode.type === 'trigger') return;
      // Delegate to main deletion flow to ensure cascading IF cleanup
      deleteAction(selectedNode);
    }
    
    // Add movement listeners to all nodes (simplified - no automatic updates)
    function addNodeMovementListeners() {
      const nodes = container.querySelectorAll('.flowchart-node');
      nodes.forEach(node => {
        // Remove any existing transition listeners that might cause issues
        node.removeEventListener('transitionend', () => {});
        // No automatic position updates - PositionManager handles stability
      });
    }
    
    // Loading screen functions
    function showLoadingScreen() {
      const loadingScreen = document.getElementById('workflow-loading-screen');
      if (loadingScreen) {
        loadingScreen.style.display = 'flex';
      }
    }

    function hideLoadingScreen() {
      const loadingScreen = document.getElementById('workflow-loading-screen');
      if (loadingScreen) {
        loadingScreen.style.display = 'none';
      }
    }
    // Production-grade position management system
    const PositionManager = {
      isInitialized: false,
      isUpdating: false,
      
      init() {
        if (this.isInitialized) return;
        this.isInitialized = true;
        
        // Disable all CSS transitions on connection lines and orbs
        this.disableProblematicTransitions();
        
        // Set up stable positioning system
        this.setupStablePositioning();
        
      },
      
      disableProblematicTransitions() {
        // Remove all transitions from connection lines and orbs
        const style = document.createElement('style');
        style.textContent = `
          .connection-line,
          .add-action-orb,
          .insert-action-orb {
            transition: none !important;
            animation: none !important;
          }
          
          .flowchart-node {
            transition: box-shadow 0.2s, border-color 0.2s !important;
          }
          
          .flowchart-node * {
            transition: none !important;
          }
        `;
        document.head.appendChild(style);
      },
      
      setupStablePositioning() {
        // Override the connection positioning to be completely stable
        this.originalUpdateConnectionPosition = WorkflowManager.updateConnectionPosition;
        WorkflowManager.updateConnectionPosition = this.stableUpdateConnectionPosition.bind(this);
        
        // Override orb positioning to be completely stable
        this.originalPositionOrbAtMidpoint = OrbManager.positionOrbAtMidpoint;
        OrbManager.positionOrbAtMidpoint = this.stablePositionOrbAtMidpoint.bind(this);
        
        this.originalPositionOrb = OrbManager.positionOrb;
        OrbManager.positionOrb = this.stablePositionOrb.bind(this);
      },
      
      stableUpdateConnectionPosition(connection) {
        if (!connection || !connection.line || !connection.from || !connection.to) {
        return;
      }
        
        try {
          const fromRect = connection.from.getBoundingClientRect();
          const toRect = connection.to.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          
          if (!fromRect || !toRect || !containerRect) {
          return;
        }
        
          // Calculate connection points (center bottom of from, center top of to)
          // EXACT same math used for SVG paths
          const fromX = Math.round(fromRect.left - containerRect.left + fromRect.width / 2);
          const fromY = Math.round(fromRect.bottom - containerRect.top - 1);
          const toX = Math.round(toRect.left - containerRect.left + toRect.width / 2);
          const toY = Math.round(toRect.top - containerRect.top + 1);

          // If using SVG path, draw an orthogonal rounded path; otherwise keep legacy div behavior
          const el = connection.line;
          if (el && el.tagName && el.tagName.toLowerCase() === 'path') {
            const fromType = (connection.from.__nodeData && connection.from.__nodeData.data?.type) || nodes.find(n=>n.element===connection.from)?.data?.type || '';
            const toType = (connection.to.__nodeData && connection.to.__nodeData.data?.type) || nodes.find(n=>n.element===connection.to)?.data?.type || '';
            connection.from.__nodeData = nodes.find(n => n.element === connection.from) || connection.from.__nodeData || null;
            connection.to.__nodeData = nodes.find(n => n.element === connection.to) || connection.to.__nodeData || null;

            let d = '';
            const vDrop = 30;
            const r = 12;
            // Handle True/False to join connections first (specific case)
            if ((fromType === 'True' || fromType === 'False') && WorkflowManager.toNodeHasJoin && WorkflowManager.toNodeHasJoin(toType, connection)) {
              const minDrop = 120;
              let midY;
              try {
                const inbound = Array.from(WorkflowManager.connections.values()).filter(c => c && c.to === connection.to);
                if (inbound.length >= 2) {
                  let maxFromY = fromY;
                  for (const c of inbound) {
                    if (!c.from) continue;
                    const fr = c.from.getBoundingClientRect();
                    if (!fr) continue;
                    const fy = Math.round(fr.bottom - containerRect.top - 1);
                    if (fy > maxFromY) maxFromY = fy;
                  }
                  midY = Math.min(toY - 12 - 10, maxFromY + minDrop);
                } else {
                  const verticalDistance = Math.abs(toY - fromY);
                  const maxDrop = 240;
                  midY = fromY + Math.min(Math.max(verticalDistance * 0.4, minDrop), maxDrop);
                }
              } catch {
                const verticalDistance = Math.abs(toY - fromY);
                const maxDrop = 240;
                midY = fromY + Math.min(Math.max(verticalDistance * 0.4, minDrop), maxDrop);
              }
              const dir = (toX >= fromX) ? 1 : -1;
              d = `M ${fromX} ${fromY}`;
              d += ` L ${fromX} ${midY - r}`;
              d += ` Q ${fromX} ${midY} ${fromX + dir * r} ${midY}`;
              d += ` L ${toX - dir * r} ${midY}`;
              d += ` Q ${toX} ${midY} ${toX} ${midY + r}`;
              d += ` L ${toX} ${toY}`;
              
              // Note: Orbs are created once when connection is first made, not on every update
              el.setAttribute('stroke-linecap', 'round');
              el.setAttribute('stroke-linejoin', 'round');
            // Handle branch actions to join node (implicit join detection)
            } else if (WorkflowManager.toNodeIsImplicitJoin && WorkflowManager.toNodeIsImplicitJoin(connection)) {
              const minDrop = 120;
              let midY;
              try {
                const inbound = Array.from(WorkflowManager.connections.values()).filter(c => c && c.to === connection.to);
                if (inbound.length >= 2) {
                  let maxFromY = fromY;
                  for (const c of inbound) {
                    if (!c.from) continue;
                    const fr = c.from.getBoundingClientRect();
                    if (!fr) continue;
                    const fy = Math.round(fr.bottom - containerRect.top - 1);
                    if (fy > maxFromY) maxFromY = fy;
                  }
                  midY = Math.min(toY - 12 - 10, maxFromY + minDrop);
                } else {
                  const verticalDistance = Math.abs(toY - fromY);
                  const maxDrop = 240;
                  midY = fromY + Math.min(Math.max(verticalDistance * 0.4, minDrop), maxDrop);
                }
              } catch {
                const verticalDistance = Math.abs(toY - fromY);
                const maxDrop = 240;
                midY = fromY + Math.min(Math.max(verticalDistance * 0.4, minDrop), maxDrop);
              }
              const dir = (toX >= fromX) ? 1 : -1;
              d = `M ${fromX} ${fromY}`;
              d += ` L ${fromX} ${midY - r}`;
              d += ` Q ${fromX} ${midY} ${fromX + dir * r} ${midY}`;
              d += ` L ${toX - dir * r} ${midY}`;
              d += ` Q ${toX} ${midY} ${toX} ${midY + r}`;
              d += ` L ${toX} ${toY}`;
              
              // Note: Orbs are created once when connection is first made, not on every update
              el.setAttribute('stroke-linecap', 'round');
              el.setAttribute('stroke-linejoin', 'round');
            // Always render other lines targeting a join node with orthogonal rounded corners
            } else if (WorkflowManager.toNodeHasJoin && WorkflowManager.toNodeHasJoin(toType, connection)) {
              const vDropJoin = 28; // halved to account for longer lines with orbs
              const approachShorten = 14;
              const midY = fromY + vDropJoin;
              const dir = (toX >= fromX) ? 1 : -1;
              d += `M ${fromX} ${fromY}`;
              d += ` L ${fromX} ${midY - r}`;
              d += ` Q ${fromX} ${midY} ${fromX + dir * r} ${midY}`;
              d += ` L ${toX - dir * (r + approachShorten)} ${midY}`;
              d += ` Q ${toX} ${midY} ${toX} ${midY + r}`;
              d += ` L ${toX} ${toY}`;
              el.setAttribute('stroke-linecap', 'round');
              el.setAttribute('stroke-linejoin', 'round');
            } else if (fromType === 'If' && (toType === 'True' || toType === 'False')) {
              const midY = fromY + vDrop;
              d += `M ${fromX} ${fromY}`;
              d += ` L ${fromX} ${midY - r}`;
              const dir = (toX >= fromX) ? 1 : -1;
              d += ` Q ${fromX} ${midY} ${fromX + dir * r} ${midY}`;
              d += ` L ${toX - dir * r} ${midY}`;
              d += ` Q ${toX} ${midY} ${toX} ${midY + r}`;
              d += ` L ${toX} ${toY}`;
            } else if ((fromType === 'True' || fromType === 'False')) {
              if (WorkflowManager.isJoinNode && WorkflowManager.isJoinNode(connection.to)) {
                const midY = fromY + vDrop;
                const dir = (toX >= fromX) ? 1 : -1;
                d += `M ${fromX} ${fromY}`;
                d += ` L ${fromX} ${midY - r}`;
                d += ` Q ${fromX} ${midY} ${fromX + dir * r} ${midY}`;
                d += ` L ${toX - dir * r} ${midY}`;
                d += ` Q ${toX} ${midY} ${toX} ${midY + r}`;
                d += ` L ${toX} ${toY}`;
              } else if (!(toType === 'True' || toType === 'False')) {
                // Legacy gentle orthogonal used in refresh renderer
                const ctrlY = fromY + 20;
                d = `M ${fromX} ${fromY} Q ${fromX} ${ctrlY} ${fromX} ${ctrlY} L ${toX} ${ctrlY} Q ${toX} ${ctrlY} ${toX} ${toY}`;
              } else {
                const mx = Math.round((fromX + toX) / 2);
                d = `M ${fromX} ${fromY} C ${mx} ${fromY}, ${mx} ${toY}, ${toX} ${toY}`;
              }
            } else {
              // Generic vertical line for non-IF connections to keep visuals stable
              const fromDataProps = (connection.from.__nodeData && connection.from.__nodeData.data && connection.from.__nodeData.data.properties) || {};
              const toDataProps = (connection.to.__nodeData && connection.to.__nodeData.data && connection.to.__nodeData.data.properties) || {};
              if ((fromType === 'True' || fromType === 'False') || (toType === 'True' || toType === 'False') || fromDataProps.parentIfId || toDataProps.parentIfId) {
                const side = (fromType === 'True' || fromDataProps.branch === 'true') ? -1 : 1;
                const hOffset = 32;
                const midY = fromY + 28;
                const hx1 = fromX + side * hOffset;
                const hx2 = Math.abs(toX - fromX) < 2 ? (toX - side * hOffset) : toX;
                d = `M ${fromX} ${fromY}`;
                d += ` L ${fromX} ${midY - r}`;
                d += ` Q ${fromX} ${midY} ${hx1} ${midY}`;
                d += ` L ${hx2} ${midY}`;
                d += ` Q ${toX} ${midY} ${toX} ${midY + r}`;
                d += ` L ${toX} ${toY}`;
              } else {
              d = `M ${fromX} ${fromY} L ${fromX} ${toY}`;
              }
            }
            el.setAttribute('d', d);
            el.style.display = 'block';
            if (DEBUG_LINE_PATHS) {
              const toIsJoin = (WorkflowManager.isJoinNode && WorkflowManager.isJoinNode(connection.to)) || false;
              console.log(`Refresh Connection ${connection.from?.id}->${connection.to?.id}: fromType=${fromType}, toType=${toType}, toIsJoin=${toIsJoin}, path=${d}`);
              // Debug the specific problematic connections
              if ((connection.from?.id === 'node-6' && connection.to?.id === 'node-8') || 
                  (connection.from?.id === 'node-5' && connection.to?.id === 'node-8') ||
                  (connection.from?.id === 'node-5' && connection.to?.id === 'node-9') ||
                  (connection.from?.id === 'node-9' && connection.to?.id === 'node-6')) {
                const implicitJoin = WorkflowManager.toNodeIsImplicitJoin && WorkflowManager.toNodeIsImplicitJoin(connection);
                console.log(`PROBLEMATIC JOIN PATH: ${connection.from?.id}->${connection.to?.id}`, {
                  fromX, fromY, toX, toY, fromType, toType, 
                  path: d,
                  hasJoin: toIsJoin,
                  implicitJoin: implicitJoin
                });
              }
            }
          } else {
            // Legacy fallback (div line rotated)
            const deltaX = toX - fromX;
            const deltaY = toY - fromY;
            const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const angle = Math.atan2(deltaY, deltaX);
            el.style.left = `${fromX}px`;
            el.style.top = `${fromY}px`;
            el.style.width = `${length}px`;
            el.style.transform = `rotate(${angle}rad)`;
            el.style.display = 'block';
          }
          connection.line.style.opacity = '1';
          
          // Update insert orb position if it exists using identical center math (no extra rounding jitter)
          if (connection.insertOrb) {
            const midX = (fromX + toX) / 2;
            const midY = (fromY + toY) / 2;
            connection.insertOrb.style.left = `${midX}px`;
            connection.insertOrb.style.top = `${midY}px`;
            connection.insertOrb.style.transform = 'translate(-50%, -50%)';
          }
          
      } catch (error) {
          console.error('Error in stable connection positioning:', error);
        }
      },
      
      stablePositionOrbAtMidpoint(orb, fromNode, toNode) {
        if (!orb || !fromNode || !toNode) {
          return;
        }
        
        try {
          const fromRect = fromNode.getBoundingClientRect();
          const toRect = toNode.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          if (!fromRect || !toRect || !containerRect) return;
          let _scale = 1;
          try { const m = (container.style.transform || '').match(/scale\(([-\d.]+)\)/); if (m) _scale = parseFloat(m[1]) || 1; } catch {}
          const toLocalX = (vx) => (vx - containerRect.left) / _scale;
          const toLocalY = (vy) => (vy - containerRect.top) / _scale;
          const fromX = Math.round(toLocalX(fromRect.left + fromRect.width / 2));
          const fromY = Math.round(toLocalY(fromRect.bottom) - 1);
          const toX = Math.round(toLocalX(toRect.left + toRect.width / 2));
          const toY = Math.round(toLocalY(toRect.top) + 1);
          const midpointX = (fromX + toX) / 2;
          const midpointY = (fromY + toY) / 2;
          orb.style.left = `${midpointX}px`;
          orb.style.top = `${midpointY}px`;
          orb.style.transform = 'translate(-50%, -50%)';
          orb.style.opacity = '1';
          
        } catch (error) {
          // Fallback positioning
          orb.style.left = '50%';
          orb.style.top = '50%';
          orb.style.transform = 'translate(-50%, -50%)';
        }
      },
      
      stablePositionOrb(orb, node, position) {
        if (!orb || !node) {
          return;
        }
        
        try {
          const nodeRect = node.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          if (!nodeRect || !containerRect) return;
          const nodeLeft = nodeRect.left - containerRect.left;
          const nodeTop = nodeRect.top - containerRect.top;
          const nodeRight = nodeRect.right - containerRect.left;
          const nodeBottom = nodeRect.bottom - containerRect.top;
          const nodeWidth = nodeRect.width;
          const nodeHeight = nodeRect.height;
          let finalLeft, finalTop, transform;
          if (position === 'bottom') {
            // Align to the same horizontal center as connection start, +1px visual tweak
            finalLeft = Math.round(nodeLeft + (nodeWidth / 2)) + 1;
            finalTop = Math.round(nodeBottom + 20);
            transform = 'translate(-50%, 0)';
          } else if (position === 'top') {
            finalLeft = Math.round(nodeLeft + (nodeWidth / 2));
            finalTop = Math.round(nodeTop - 20);
            transform = 'translate(-50%, -100%)';
          } else {
            finalLeft = Math.round(nodeLeft + (nodeWidth / 2));
            finalTop = Math.round(nodeBottom + 20);
            transform = 'translate(-50%, 0)';
          }
          orb.style.left = `${finalLeft}px`;
          orb.style.top = `${finalTop}px`;
          if (transform) orb.style.transform = transform;
          orb.style.opacity = '1';
          
        } catch (error) {
          // Fallback positioning
          orb.style.left = '50%';
          orb.style.top = '50%';
          orb.style.transform = 'translate(-50%, -50%)';
        }
      },
      
      updateInsertOrbPosition(connection) {
        if (!connection.insertOrb) return;
        
        try {
          const fromRect = connection.from.getBoundingClientRect();
          const toRect = connection.to.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          if (!fromRect || !toRect || !containerRect) return;
          let _scale = 1;
          try { const m = (container.style.transform || '').match(/scale\(([-\d.]+)\)/); if (m) _scale = parseFloat(m[1]) || 1; } catch {}
          const toLocalX = (vx) => (vx - containerRect.left) / _scale;
          const toLocalY = (vy) => (vy - containerRect.top) / _scale;
          const fromX = Math.round(toLocalX(fromRect.left + fromRect.width / 2));
          const fromY = Math.round(toLocalY(fromRect.bottom) - 1);
          const toX = Math.round(toLocalX(toRect.left + toRect.width / 2));
          const toY = Math.round(toLocalY(toRect.top) + 1);
          const midpointX = (fromX + toX) / 2;
          const midpointY = (fromY + toY) / 2;
          connection.insertOrb.style.left = `${Math.round(midpointX)}px`;
          connection.insertOrb.style.top = `${Math.round(midpointY)}px`;
          connection.insertOrb.style.transform = 'translate(-50%, -50%)';
        } catch (error) {
          console.error('Error updating insert orb position:', error);
        }
      },
      
      // Clean up and restore original functions
      cleanup() {
        if (this.originalUpdateConnectionPosition) {
          WorkflowManager.updateConnectionPosition = this.originalUpdateConnectionPosition;
        }
        if (this.originalPositionOrbAtMidpoint) {
          OrbManager.positionOrbAtMidpoint = this.originalPositionOrbAtMidpoint;
        }
        if (this.originalPositionOrb) {
          OrbManager.positionOrb = this.originalPositionOrb;
        }
        this.isInitialized = false;
      }
    };

  // --- Persistent History (Undo/Redo up to 50) and Draft Autosave ---
  const HistoryManager = {
    maxSize: 50,
    stack: [],
    index: -1,
    workflowKey: null,
    lastSnapshotHash: null,
    isApplying: false,

    initForCurrentWorkflow() {
      const id = getCurrentWorkflowId();
      this.workflowKey = id ? String(id) : 'new-workflow';
      this.loadPersistent();
      // Seed initial snapshot from current UI state
      this.recordSnapshot('initial');
    },

    buildSnapshot() {
      // Serialize minimal UI state: name + trigger + steps
      const triggerNode = nodes.find(n => n.type === 'trigger');
      const triggerData = triggerNode?.data || null;
      const steps = nodes.filter(n => n.type !== 'trigger').map(n => n.data);
      let name = '';
      try { name = (document.getElementById('workflow-name')?.value || '').trim(); } catch {}
      return { meta: { name }, trigger: triggerData, steps };
    },

    applySnapshot(snapshot) {
      if (!snapshot) return;
      this.isApplying = true;
      try {
        // Apply workflow name from snapshot (so name changes persist across autosave/load)
        try {
          const name = snapshot?.meta?.name || '';
          const input = document.getElementById('workflow-name');
          if (input && typeof name === 'string') input.value = name;
        } catch {}

        // Clear current UI
        try {
          nodes.forEach(n => { try { if (n.element && n.element.parentNode) n.element.remove(); } catch {} });
          nodes = [];
          const existingOrbs = container.querySelectorAll('.add-action-orb, .insert-action-orb');
          existingOrbs.forEach(orb => orb.remove());
          const existingPaths = container.querySelectorAll('#connections-svg');
          existingPaths.forEach(p => p.remove());
          // Ensure WorkflowManager will recreate the SVG overlay on next draw
          try { WorkflowManager.svg = null; } catch {}
        } catch {}

        // Reset DOM id counter before recreating nodes to avoid id growth across applies
        try { currentNodeId = 0; availableNodeIds = new Set(); } catch {}
        // Recreate trigger
        if (snapshot.trigger) {
          updateTriggerNode(snapshot.trigger);
        } else {
          createInitialTriggerNode();
        }

        // Recreate actions (normalize to ensure If blocks have headers)
        if (Array.isArray(snapshot.steps)) {
          const normalized = normalizeWorkflowSteps(snapshot.steps);
          // Suspend rebuilds during bulk-apply to avoid intermediate orb placement
          const prevLoading = isLoadingWorkflow;
          isLoadingWorkflow = true;
          suspendRebuild = true;
          try {
            normalized.forEach((step, idx) => {
              if (step && step.type !== 'trigger') {
                addActionNode(step, idx);
              }
            });
          } finally {
            isLoadingWorkflow = prevLoading;
            suspendRebuild = false;
          }
        }

        // Final rebuild (force re-init of WorkflowManager to recreate overlay if needed)
        try { WorkflowManager.init(); } catch {}
        // If a rebuild was requested while suspended, run it now and chain the pending callback
        if (this.rebuildPendingCallback) {
          const cb = this.rebuildPendingCallback; this.rebuildPendingCallback = null;
          StructureManager.rebuild(cb);
        } else {
          StructureManager.rebuild();
        }
      } finally {
        this.isApplying = false;
      }
    },

    hashSnapshot(snapshot) {
      try { return JSON.stringify(snapshot); } catch { return String(Date.now()); }
    },

    async recordSnapshot(reason = 'change') {
      if (this.isApplying) return;
      try { if (typeof isLoadingWorkflow !== 'undefined' && isLoadingWorkflow) return; } catch {}
      const snap = this.buildSnapshot();
      const hash = this.hashSnapshot(snap);
      if (hash === this.lastSnapshotHash) return; // ignore duplicates
      this.lastSnapshotHash = hash;

      // If we undid some, truncate forward history
      if (this.index < this.stack.length - 1) {
        this.stack = this.stack.slice(0, this.index + 1);
      }

      this.stack.push(snap);
      if (this.stack.length > this.maxSize) {
        this.stack.shift();
      } else {
        this.index++;
      }
      this.persist();
      if (reason !== 'initial') {
        try {
        await DraftManager.autosaveDraft(snap);
          if (window.__DEBUG_EDITOR__) console.debug('[AUTOSAVE] Snapshot saved', { reason, ts: Date.now() });
        } catch (e) {
          if (window.__DEBUG_EDITOR__) console.warn('[AUTOSAVE] Failed', e);
        }
      }
    },

    undo() {
      if (this.index <= 0) return;
      this.index--;
      const snap = this.stack[this.index];
      this.persist();
      this.applySnapshot(snap);
    },

    redo() {
      if (this.index >= this.stack.length - 1) return;
      this.index++;
      const snap = this.stack[this.index];
      this.persist();
      this.applySnapshot(snap);
    },

    persist() {
      if (!this.workflowKey) return;
      // No more local history storage - everything is server-side only
    },

    loadPersistent() {
      if (!this.workflowKey) return;
      // No more local history storage - everything is server-side only
    }
  };

  const DraftManager = {
    debounceTimer: null,
    debounceMs: 0,
    // No more local draft storage - everything is server-side only
    getDraftKey() {
      return null; // Disabled - use server-side drafts only
    },
    // No more local display name storage - everything is server-side metadata
    setDisplayName(branchId, name) {
      // No-op - server-side metadata only
    },
    getDisplayName(branchId) {
      return ''; // No-op - server-side metadata only
    },
    getActiveDisplayName() {
      try { const lbl = document.getElementById('branch-current-label'); return (lbl && lbl.textContent) ? lbl.textContent.trim() : ''; } catch { return ''; }
    },
    async ensureDraftBranch(initialSnapshot) {
      const current = this.currentBranch();
      if (current && current !== 'main') return current;
      // Create stable branch id + human readable display name
      const branchId = `draft-${Date.now()}-${Math.random().toString(36).slice(2,8)}`;
      const name = `Draft ${new Date().toLocaleString(undefined, { dateStyle: 'medium', timeStyle: 'short' })}`;
      try {
        const id = getCurrentWorkflowId();
        // Must have server ID for draft branches
        if (!id) {
          console.error('Cannot create draft branch without server workflow ID');
          return null;
        }
        const seed = initialSnapshot || (typeof HistoryManager?.buildSnapshot === 'function' ? HistoryManager.buildSnapshot() : null);
        await fetch(`${API_URL}/workflows/${id}/drafts`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({ branch: branchId, name, data: seed || {} }),
        });
        setCurrentBranch(branchId);
        try { const lbl = document.getElementById('branch-current-label'); if (lbl) lbl.textContent = name; } catch {}
        // Server-side metadata only
        // Refresh branch dropdown to include the new draft branch
        try {
          const resB = await fetch(`${API_URL}/workflows/${id}/draft-branches`, { credentials: 'include', cache: 'no-store' });
          const branches = resB.ok ? await resB.json() : [];
          if (Array.isArray(branches)) { try { refreshBranchMenu(branches); } catch {} }
        } catch {}
        return branchId;
      } catch {
        return 'main';
      }
    },
    async autosaveDraft(snapshot) {
      let branch = this.currentBranch();
      if (!branch || branch === 'main') {
        branch = await this.ensureDraftBranch(snapshot);
        if (!branch || branch === 'main') return;
      }
      // No more local draft storage - everything is server-side only
      try {
        const id = getCurrentWorkflowId();
        // Must have server ID for autosaving
        if (!id) return;
        const displayName = this.getActiveDisplayName();
        await fetch(`${API_URL}/workflows/${id}/drafts`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({ branch, name: displayName || undefined, data: snapshot }),
        });
        // Opportunistically refresh branches so UI reflects the active draft
        try {
          const resB = await fetch(`${API_URL}/workflows/${id}/draft-branches`, { credentials: 'include', cache: 'no-store' });
          const branches = resB.ok ? await resB.json() : [];
          if (Array.isArray(branches)) { try { refreshBranchMenu(branches); } catch {} }
        } catch {}
      } catch {}
    },
    currentBranch() {
      return getCurrentBranch();
    },
    // No more local draft storage - everything is server-side only
    getDraft() {
      return null; // Disabled - use server-side drafts only
    },
    clearDraft() {
      // No-op - server-side drafts only
    },
    // No more draft banner system - everything is server-side only
    async checkAndOfferDraft() {
      // Load server branches and refresh menu
      const id = getCurrentWorkflowId();
      if (id) {
        try {
          const res = await fetch(`${API_URL}/workflows/${id}/draft-branches`);
          const branches = res.ok ? await res.json() : [];
          refreshBranchMenu(branches);
            } catch {}
      }
    }
  };
  // Branch switcher wiring
  (function initBranchSwitcher(){
    const sel = null; // removed native select
    const btn = document.getElementById('create-branch-btn');
    const applyBtn = document.getElementById('apply-branch-to-main-btn');
    const triggerBtn = document.getElementById('branch-trigger');
    const menu = document.getElementById('branch-menu');
    const itemsRoot = document.getElementById('branch-items');
    const currentLabel = document.getElementById('branch-current-label');
    function refreshBranchMenu(branches = []) {
      if (!itemsRoot) return;
      itemsRoot.innerHTML = '';
      const seen = new Set();
      branches.forEach(b => {
        const branchId = b && b.branch;
        const displayName = (b && (b.name || b.branch)) || '';
        if (!branchId || branchId === 'main' || seen.has(branchId)) return;
        seen.add(branchId);
        const row = document.createElement('div');
        row.className = 'branch-item';
        row.dataset.branch = branchId;
        row.style.cssText = 'display:flex;align-items:center;justify-content:space-between;gap:12px;padding:10px 12px;border-radius:8px;cursor:pointer;max-width:100%;';
        const span = document.createElement('span');
        span.textContent = displayName;
        span.style.cssText = 'flex:1 1 auto;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;';
        const actionsWrap = document.createElement('div');
        actionsWrap.style.cssText = 'display:flex;gap:4px;align-items:center';
        const rename = document.createElement('button');
        rename.className = 'context-btn';
        rename.style.cssText = 'padding:2px 6px;height:24px;';
        rename.textContent = 'Rename';
        const del = document.createElement('button');
        del.className = 'context-btn';
        del.style.cssText = 'padding:2px 6px;height:24px;';
        del.textContent = 'Delete';
        actionsWrap.appendChild(rename);
        actionsWrap.appendChild(del);
        rename.addEventListener('click', async (e) => {
          e.stopPropagation();
          const newName = await themedPrompt(displayName, 'Rename Draft', 'Draft name');
          if (!newName || newName.trim() === displayName) return;
          try {
            const id = getCurrentWorkflowId();
            if (!id) return;
            const token = getAnyToken();
            if (!token) return;
            
            const clean = token.replace(/^"|"$/g, '');
            // Find newest draft (server returns newest first)
            const resFind = await fetch(`${API_URL}/workflows/${id}/drafts?branch=${encodeURIComponent(row.dataset.branch)}`, { credentials: 'include' });
            const list = resFind.ok ? await resFind.json() : [];
            const latest = Array.isArray(list) && list.length ? list[0] : null;
            if (!latest) return;
            const res = await fetch(`${API_URL}/workflows/${id}/drafts/${latest.id}`, { 
              method: 'PATCH', 
              headers: { 'Content-Type': 'application/json' }, 
              credentials: 'include',
              body: JSON.stringify({ name: newName.trim() }) 
            });
            if (res.ok) {
              // Refresh branches to pull back saved names
              try {
                const resB = await fetch(`${API_URL}/workflows/${id}/draft-branches`);
                const branches = resB.ok ? await resB.json() : [];
                refreshBranchMenu(branches);
                // Update the trigger label with the server display name
                const active = branches.find(b => b.branch === row.dataset.branch);
                if (active) {
                  const lbl = document.getElementById('branch-current-label');
                  if (lbl) lbl.textContent = (active.name || active.branch);
                  // Server-side metadata only
                }
              } catch {}
              // Update current label if active
            if (DraftManager.currentBranch() === row.dataset.branch) {
              const lbl = document.getElementById('branch-current-label'); if (lbl) lbl.textContent = newName.trim();
              }
              showNotification('Draft renamed');
            } else {
              showNotification('Failed to rename draft', 'error');
            }
          } catch { showNotification('Failed to rename draft', 'error'); }
        });
        del.addEventListener('click', async (e) => {
          e.stopPropagation();
          // Use the actual branch id, not the display name
          const branch = row?.dataset?.branch || branchId;
          const ok = await themedConfirm(`Delete draft branch "${branch}"? This cannot be undone.`, 'Delete Draft');
          if (!ok) return;
          const originalAutosave = DraftManager.autosaveDraft; DraftManager.autosaveDraft = async () => {};
          try {
            const id = getCurrentWorkflowId();
            if (!id) { console.error('[DRAFT][DELETE] missing workflow id'); showNotification('No workflow selected', 'error'); return; }
            const token = getAnyToken();
            if (!token) { console.error('[DRAFT][DELETE] missing auth token'); showNotification('Not authenticated', 'error'); return; }
            
            const clean = token.replace(/^"|"$/g, '');
            const deleteUrl = `${API_URL}/workflows/${id}/drafts?branch=${encodeURIComponent(branch)}`;
            console.debug('[DRAFT][DELETE] request', { deleteUrl, id, branch });
            let res = await fetch(deleteUrl, { 
              method: 'DELETE',
              credentials: 'include'
            });
            console.debug('[DRAFT][DELETE] response', { ok: res?.ok, status: res?.status });
            if (!res.ok) {
              // Fallback: delete each draft snapshot in the branch individually
              try {
                const listUrl = `${API_URL}/workflows/${id}/drafts?branch=${encodeURIComponent(branch)}`;
                console.debug('[DRAFT][DELETE] fallback list', { listUrl });
                const listRes = await fetch(listUrl, { credentials: 'include', cache: 'no-store' });
                if (listRes.ok) {
                  const drafts = await listRes.json();
                  console.debug('[DRAFT][DELETE] fallback drafts', { count: Array.isArray(drafts) ? drafts.length : 0 });
                  if (Array.isArray(drafts) && drafts.length) {
                    let allOk = true;
                    for (const d of drafts) {
                      try {
                        const delOneUrl = `${API_URL}/workflows/${id}/drafts/${d.id}`;
                        console.debug('[DRAFT][DELETE] deleting draft', { delOneUrl, draftId: d.id });
                        const delOne = await fetch(delOneUrl, { method: 'DELETE', credentials: 'include' });
                        console.debug('[DRAFT][DELETE] delete one response', { ok: delOne?.ok, status: delOne?.status, draftId: d.id });
                        if (!delOne.ok) {
                          allOk = false;
                          try { const txt = await delOne.text(); console.error('[DRAFT][DELETE] delete one error body', txt); } catch {}
                        }
                      } catch { allOk = false; }
                    }
                    if (allOk) {
                      // Simulate success
                      res = { ok: true };
                    }
                  }
                } else {
                  console.error('[DRAFT][DELETE] fallback list failed', { status: listRes?.status });
                }
              } catch {}
            }
            if (res.ok) {
              showNotification('Draft branch deleted');
              row.remove();
              if (DraftManager.currentBranch() === branch) {
                setCurrentBranch('main');
                if (currentLabel) currentLabel.textContent = 'Main';
                await loadWorkflow();
              }
              // Refresh branches list to reflect deletion
              try {
                const listBranchesUrl = `${API_URL}/workflows/${id}/draft-branches`;
                console.debug('[DRAFT][DELETE] refresh branches', { listBranchesUrl });
                const resB = await fetch(listBranchesUrl, { credentials: 'include', cache: 'no-store' });
                const branches = resB.ok ? await resB.json() : [];
                console.debug('[DRAFT][DELETE] refreshed branches', { count: Array.isArray(branches) ? branches.length : 0 });
                refreshBranchMenu(branches);
              } catch {}
            } else {
              try {
                const errText = await res.text();
                console.error('[DRAFT][DELETE] failed', { status: res?.status, body: errText });
                let msg = 'Failed to delete draft branch';
                try { const err = JSON.parse(errText); if (err && err.message) msg = err.message; } catch {}
                showNotification(msg, 'error');
              } catch {
              showNotification('Failed to delete draft branch', 'error');
            }
            }
          } catch (e) {
            console.error('[DRAFT][DELETE] exception', e);
            showNotification('Draft deletion error', 'error');
          } finally { DraftManager.autosaveDraft = originalAutosave; }
        });
        row.addEventListener('click', async () => {
          setCurrentBranch(branchId);
          if (currentLabel) currentLabel.textContent = displayName;
          if (menu) menu.style.display = 'none';
          // Immediate visual cleanup to avoid lingering lines while branch switches
          try {
            const toRemove = container.querySelectorAll('.connection-line, #connections-svg');
            toRemove.forEach(el => { try { el.remove(); } catch {} });
          } catch {}
          try { OrbManager?.insertOrbs?.clear?.(); } catch {}
          try { StructureManager.rebuild(); } catch {}
          setTimeout(async () => {
            try {
              const id = getCurrentWorkflowId();
              if (id) {
                const res = await fetch(`${API_URL}/workflows/${id}/drafts?branch=${encodeURIComponent(branchId)}`, { credentials: 'include', cache: 'no-store' });
                if (res.ok) {
                  const drafts = await res.json();
                  if (Array.isArray(drafts) && drafts.length > 0) {
                    HistoryManager.applySnapshot(drafts[0].data);
                    // Aggressive refresh: two raf passes for layout → connections
                    requestAnimationFrame(() => {
                      try { LayoutManager.apply(); OrbManager.updateAllOrbPositions(); } catch {}
                      requestAnimationFrame(() => {
                        try { WorkflowManager.updateAllConnections(); } catch {}
                      });
                    });
                  }
                }
              }
            } catch {}
          }, 0);
          // Force refresh lines and orbs immediately after branch switch
          try { 
            WorkflowManager.updateAllConnections();
            OrbManager.updateAllOrbPositions();
          } catch {}
        });
        row.appendChild(span);
        row.appendChild(actionsWrap);
        itemsRoot.appendChild(row);
        // spacer
        const spacer = document.createElement('div');
        spacer.style.cssText = 'height:1px;background:#223A35;margin:4px 0;';
        itemsRoot.appendChild(spacer);
      });
      // No more local draft branches - everything is server-side only
    }

    if (triggerBtn) triggerBtn.addEventListener('click', async (e) => {
      e.stopPropagation();
      if (menu) menu.style.display = menu.style.display === 'none' || !menu.style.display ? 'block' : 'none';
      // Load branches when opening (no-cache to avoid stale)
      try {
        const id = getCurrentWorkflowId();
        if (id) {
          const res = await fetch(`${API_URL}/workflows/${id}/draft-branches`, { credentials: 'include', cache: 'no-store' });
          const branches = res.ok ? await res.json() : [];
          refreshBranchMenu(branches);
        }
      } catch {}
    });
    document.addEventListener('click', () => { if (menu) menu.style.display = 'none'; });
    // Handle selecting Main
    try {
      const mainItem = document.querySelector('#branch-menu .branch-item[data-branch="main"]');
      if (mainItem) mainItem.addEventListener('click', async () => {
        setCurrentBranch('main');
        if (currentLabel) currentLabel.textContent = 'Main';
        if (menu) menu.style.display = 'none';
        // Immediate visual cleanup
        try {
          const toRemove = container.querySelectorAll('.connection-line, #connections-svg');
          toRemove.forEach(el => { try { el.remove(); } catch {} });
          OrbManager?.insertOrbs?.clear?.();
          StructureManager.rebuild();
        } catch {}
        await loadWorkflow();
        // Multi-pass refresh to ensure lines are synced even without user interaction
        try {
          requestAnimationFrame(() => {
            try { LayoutManager.apply(); OrbManager.updateAllOrbPositions(); } catch {}
            requestAnimationFrame(() => { try { WorkflowManager.updateAllConnections(); } catch {} });
          });
          setTimeout(() => { try { WorkflowManager.updateAllConnections(); OrbManager.updateAllOrbPositions(); } catch {} }, 200);
          setTimeout(() => { try { WorkflowManager.updateAllConnections(); } catch {} }, 800);
        } catch {}
      });
    } catch {}
    if (btn) btn.addEventListener('click', async () => {
      // Open themed modal
      try {
        const overlay = document.getElementById('draft-modal-overlay');
        const input = document.getElementById('draft-name-input');
        const cancel = document.getElementById('draft-cancel');
        const create = document.getElementById('draft-create');
        if (!overlay || !input || !cancel || !create) return;
        input.value = '';
        overlay.style.display = 'flex';
        const close = () => { overlay.style.display = 'none'; };
        const onCancel = (e) => { e?.stopPropagation?.(); close(); };
        const onCreate = async (e) => {
          e?.stopPropagation?.();
          const name = (input.value || '').trim() || `Draft ${new Date().toLocaleDateString()}`;
          try {
            const id = getCurrentWorkflowId();
            if (!id) return;
        const snap = HistoryManager.buildSnapshot();
        await fetch(`${API_URL}/workflows/${id}/drafts`, {
              method: 'POST', headers: { 'Content-Type': 'application/json' }, credentials: 'include',
          body: JSON.stringify({ branch: name, data: snap }),
        });
            setCurrentBranch(name);
        await DraftManager.checkAndOfferDraft();
        if (currentLabel) currentLabel.textContent = name;
          } catch {}
          close();
        };
        const onKey = (e) => { if (e.key === 'Enter') { onCreate(e); } if (e.key === 'Escape') { onCancel(e); } };
        cancel.onclick = onCancel; create.onclick = onCreate; input.onkeydown = onKey; input.focus();
      } catch {}
    });
    if (applyBtn) applyBtn.addEventListener('click', async () => {
      const branch = DraftManager.currentBranch();
      if (!branch || branch === 'main') { showNotification('Select a draft branch first'); return; }
      try {
        const id = getCurrentWorkflowId();
        if (!id) return;
        // Authentication handled via server-side session cookies
        // Get latest draft in branch
        const res = await fetch(`${API_URL}/workflows/${id}/drafts?branch=${encodeURIComponent(branch)}`, { credentials: 'include', cache: 'no-store' });
        if (!res.ok) { showNotification('Failed to fetch drafts', 'error'); return; }
        const drafts = await res.json();
        if (!Array.isArray(drafts) || drafts.length === 0) { showNotification('No drafts to apply', 'error'); return; }
        const latest = drafts[0];
        // Capture draft snapshot (name + trigger + steps) to persist to main
        const draftSnap = latest?.data || null;
        const draftName = draftSnap && draftSnap.meta && typeof draftSnap.meta.name === 'string' ? draftSnap.meta.name.trim() : '';
        // Apply draft to main on server
        const apply = await fetch(`${API_URL}/workflows/${id}/drafts/${latest.id}/apply`, { method: 'POST', credentials: 'include' });
        if (apply.ok) {
          // Persist draft snapshot (name + trigger + steps) to main workflow
          try {
            const toData = (snap) => {
              try {
                const triggerType = snap?.trigger?.type || null;
                const props = snap?.trigger?.properties || {};
                return {
                  trigger: triggerType || null,
                  triggerEventTypes: Array.isArray(props.eventTypes) ? props.eventTypes : [],
                  triggerEventTypeIds: Array.isArray(props.eventTypeIds) ? props.eventTypeIds : [],
                  triggerTags: Array.isArray(props.tags) ? props.tags : [],
                  steps: Array.isArray(snap?.steps) ? snap.steps : [],
                  status: true,
                };
              } catch { return { steps: [], status: true }; }
            };
            const payload = { };
            if (draftName) payload.name = draftName;
            if (draftSnap) payload.data = toData(draftSnap);
            await fetch(`${API_URL}/workflows/${id}`, {
              method: 'PATCH',
              headers: { 'Content-Type': 'application/json' },
              credentials: 'include',
              body: JSON.stringify(payload)
            });
          } catch {}
          showNotification('Applied draft to Main');
          // After successful apply, delete the entire draft branch on server
          try {
            const del = await fetch(`${API_URL}/workflows/${id}/drafts?branch=${encodeURIComponent(branch)}`, { method: 'DELETE', credentials: 'include' });
            if (del.ok) {
              // Server-side metadata only
              // If branch menu is open, refresh it
              try {
                const resB = await fetch(`${API_URL}/workflows/${id}/draft-branches`, { credentials: 'include', cache: 'no-store' });
                const branches = resB.ok ? await resB.json() : [];
                if (Array.isArray(branches)) refreshBranchMenu(branches);
              } catch {}
            }
          } catch {}
          setCurrentBranch('main');
          if (currentLabel) currentLabel.textContent = 'Main';
          // Immediate visual cleanup
          try {
            const toRemove = container.querySelectorAll('.connection-line, #connections-svg');
            toRemove.forEach(el => { try { el.remove(); } catch {} });
            OrbManager?.insertOrbs?.clear?.();
            StructureManager.rebuild();
          } catch {}
          await loadWorkflow();
          // Ensure connections render without needing a manual reload
          try { WorkflowManager.init(); } catch {}
          try {
            requestAnimationFrame(() => {
              try { LayoutManager.apply(); OrbManager.updateAllOrbPositions(); } catch {}
              requestAnimationFrame(() => { try { WorkflowManager.updateAllConnections(); } catch {} });
            });
            setTimeout(() => { try { WorkflowManager.updateAllConnections(); OrbManager.updateAllOrbPositions(); } catch {} }, 200);
            setTimeout(() => { try { WorkflowManager.updateAllConnections(); } catch {} }, 800);
          } catch {}
          // Kick autosave path to create a fresh draft on next change
          try { DraftManager.currentBranch() === 'main'; } catch {}
        } else {
          showNotification('Failed to apply draft', 'error');
        }
      } catch { showNotification('Failed to apply draft', 'error'); }
    });
    // legacy actions menu handlers removed after custom dropdown migration
  })();

  // Keyboard shortcuts for undo/redo
  document.addEventListener('keydown', (e) => {
    const isMac = navigator.platform.toUpperCase().includes('MAC');
    const mod = isMac ? e.metaKey : e.ctrlKey;
    if (!mod) return;
    if (e.key.toLowerCase() === 'z' && !e.shiftKey) { e.preventDefault(); HistoryManager.undo(); }
    if ((e.key.toLowerCase() === 'z' && e.shiftKey) || e.key.toLowerCase() === 'y') { e.preventDefault(); HistoryManager.redo(); }
  });

    // Initialize the workflow editor when the page loads
    document.addEventListener('DOMContentLoaded', async () => {
      try {
        logOrder('initEditor start');
        showLoadingScreen();
        
        // Initialize canvas
        initializeCanvas();
        
        // Load existing workflow if editing; if none, reuse a stable per-user empty draft or create one
        await loadWorkflow();
        if (!getCurrentWorkflowId()) {
          try {
            if (window.__creatingWorkflow) return; // prevent duplicate calls in same session
            window.__creatingWorkflow = true;
            // First try to reuse an existing empty untitled workflow
            try {
              let listRes = await fetch(`${API_URL}/workflows`, { credentials: 'include', cache: 'no-store' });
              if (listRes.status === 304) {
                listRes = await fetch(`${API_URL}/workflows?t=${Date.now()}` , { credentials: 'include', cache: 'no-store' });
              }
              if (listRes.ok) {
                const all = await listRes.json();
                if (Array.isArray(all)) {
                  const reusable = all.find(w => {
                    try {
                      const nm = (w.name || '').trim();
                      const steps = (w.data && Array.isArray(w.data.steps)) ? w.data.steps : [];
                      const status = (w.data && typeof w.data.status === 'boolean') ? w.data.status : false;
                      return (!nm || nm === 'Untitled Workflow') && steps.length === 0 && status === false;
                    } catch { return false; }
                  });
                  if (reusable && reusable.id) {
                    setCurrentWorkflowId(String(reusable.id));
                    window.__creatingWorkflow = false;
                    await loadWorkflow();
                    return;
                  }
                }
              }
            } catch {}

            // Otherwise create a fresh empty workflow
            const name = (document.getElementById('workflow-name')?.value?.trim()) || 'Untitled Workflow';
            const emptyData = { trigger: null, steps: [], status: false, contextSpec: getDefaultContextSpec() };
            const res = await fetch(`${API_URL}/workflows`, { 
              method: 'POST', 
              headers: { 'Content-Type': 'application/json' }, 
              credentials: 'include',
              body: JSON.stringify({ name, description: '', data: emptyData }) 
            });
            if (res.ok) {
              const nw = await res.json();
              setCurrentWorkflowId(String(nw.id));
              try { await loadWorkflow(); } catch {}
            } else if (res.status === 401) {
              handleUnauthorizedRedirect();
            }
          } catch {} finally { try { window.__creatingWorkflow = false; } catch {} }
        }

        // After workflow load, auto-select the newest edited draft if present
        try {
          const id = getCurrentWorkflowId();
        if (id) {
            // Authentication handled via server-side session cookies
            const res = await fetch(`${API_URL}/workflows/${id}/draft-branches`);
            if (res.ok) {
              const branches = await res.json();
              if (Array.isArray(branches) && branches.length > 0) {
                // Sort by updated_at desc if not already
                branches.sort((a,b) => new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime());
                const newest = branches.find(b => b.branch && b.branch !== 'main');
                if (newest && newest.branch) {
                  setCurrentBranch(newest.branch);
                  const lbl = document.getElementById('branch-current-label');
                  if (lbl) lbl.textContent = (newest.name || newest.branch);
                  // Load newest draft snapshot
                  try {
                    const res2 = await fetch(`${API_URL}/workflows/${id}/drafts?branch=${encodeURIComponent(newest.branch)}`, { credentials: 'include' });
                    if (res2.ok) {
                      const list = await res2.json();
                      if (Array.isArray(list) && list.length > 0) {
                        HistoryManager.applySnapshot(list[0].data);
                        // Notify with auto-hide
                        showNotification(`Auto-selected latest draft: ${newest.branch}`);
                        setTimeout(() => {
                          const notif = document.querySelector('.notification.show, .fixed.top-4.right-4.z-50');
                          if (notif && notif.parentElement) try { notif.parentElement.removeChild(notif); } catch {}
                        }, 5000);
                      }
                    }
                  } catch {}
                }
              }
            }
          }
        } catch {}

        // Initialize history and drafts after initial load; now that an id should exist, autosaves go to server drafts
        try { HistoryManager.initForCurrentWorkflow(); } catch {}
        // Check for existing drafts and set up branch switching
        try { DraftManager.checkAndOfferDraft(); } catch {}
        
        // Create initial trigger node if no workflow loaded
        if (nodes.length === 0) {
          createInitialTriggerNode();
        }
        
        // Add movement listeners
        addNodeMovementListeners();
        
        // Initialize production-grade position management system
        PositionManager.init();
        
        // Preload errors if an id is present
        try { await refreshErrors(); } catch {}
        try { await refreshRuns(); } catch {}

    // After fonts and layout settle, do a final alignment pass
        const settle = () => {
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              refreshStructure();
          // Additional offscreen line sync
          scheduleConnectionRefresh();
            });
          });
        };
        if (document.fonts && document.fonts.ready) {
          document.fonts.ready.then(settle).catch(settle);
        } else {
          settle();
        }
        
        logOrder('initEditor complete');
      } catch (error) {
        console.error('[BOOT] Init error:', error);
        hideLoadingScreen();
      }
    });

    // Cleanup position manager when page is unloaded
    window.addEventListener('beforeunload', () => {
      PositionManager.cleanup();
    });

    // Keep layout fresh on resize
    window.addEventListener('resize', () => {
      StructureManager.rebuild();
      scheduleConnectionRefresh();
    });

  // Errors panel logic
    async function refreshErrors(limit = 25) {
      const id = getCurrentWorkflowId();
      if (!id) return [];
      try {
        // Authentication handled via server-side session cookies
        // Authentication handled via server-side session cookies
        const res = await fetch(`${API_URL}/workflows/${id}/errors?limit=${limit}`);
        if (!res.ok) return [];
        const items = await res.json();
        renderErrors(items || []);
        return items;
      } catch (e) {
        console.warn('Failed to load workflow errors', e);
        return [];
  }

  // Insert an action between an existing connection's from/to nodes (triggered by small insert orb)
  function insertActionBetween(actionData, connection) {
    try {
      if (!connection || !connection.from || !connection.to) return null;
      // Resolve node objects from DOM elements
      const sourceNode = nodes.find(n => n.element === connection.from);
      const targetNode = nodes.find(n => n.element === connection.to);
      if (!sourceNode || !targetNode) return null;
      // Delegate to the same logic used for orb-connect insertions
      const inserted = insertActionBetweenOrbs(actionData, sourceNode, targetNode);
      return inserted;
    } catch (e) {
      try { console.warn('insertActionBetween failed:', e); } catch {}
      return null;
    }
  }

  // Branch helpers (defined after DOM and utils)
    function findIfHeaders(ifNodeId) {
      const idx = nodes.findIndex(n => n.id === ifNodeId || n.element?.id === ifNodeId);
      let trueIndex = -1, falseIndex = -1;
      if (idx >= 0) {
        for (let i = idx + 1; i < nodes.length; i++) {
          const t = nodes[i]?.data?.type;
          if (t === 'True' && trueIndex === -1) trueIndex = i;
          if (t === 'False') { falseIndex = i; break; }
        }
      }
      return { ifIndex: idx, trueIndex, falseIndex };
    }

  function decorateIfNodeForBranches(actionNodeEl) {
    const content = actionNodeEl.querySelector('.node-content');
    if (!content) return;
    const existing = content.querySelector('.branch-controls');
    if (existing) existing.remove();
    const controls = document.createElement('div');
    controls.className = 'branch-controls';
    controls.style.marginTop = '.5rem';
    controls.style.display = 'flex';
    controls.style.gap = '.5rem';
    controls.innerHTML = `
      <button class="context-btn" title="Add to TRUE path">+ True path</button>
      <button class="context-btn" title="Add to FALSE path">+ False path</button>
    `;
    const [btnTrue, btnFalse] = controls.querySelectorAll('button');
    btnTrue.addEventListener('click', (e) => { e.stopPropagation(); openActionModal(`branch-true-${actionNodeEl.id}`); });
    btnFalse.addEventListener('click', (e) => { e.stopPropagation(); openActionModal(`branch-false-${actionNodeEl.id}`); });
    content.appendChild(controls);
  }
    }

    // Runs panel logic
    const contactCache = new Map();
    const bookingCache = new Map();

    async function fetchContact(contactId) {
      if (!contactId) return null;
      if (contactCache.has(contactId)) return contactCache.get(contactId);
      try {
        // Authentication handled via server-side session cookies
        const res = await fetch(`${API_URL}/contacts/${contactId}`);
        if (!res.ok) return null;
        const data = await res.json();
        contactCache.set(contactId, data);
        return data;
      } catch { return null; }
    }

    async function fetchBooking(bookingId) {
      if (!bookingId) return null;
      if (bookingCache.has(bookingId)) return bookingCache.get(bookingId);
      try {
        // Authentication handled via server-side session cookies
        const res = await fetch(`${API_URL}/bookings/${bookingId}`);
        if (!res.ok) return null;
        const data = await res.json();
        bookingCache.set(bookingId, data);
        return data;
      } catch { return null; }
    }

    async function refreshRuns(limit = 50) {
      const id = getCurrentWorkflowId();
      if (!id) return [];
      try {
        // Authentication handled via server-side session cookies
        // Authentication handled via server-side session cookies
        const res = await fetch(`${API_URL}/workflows/${id}/runs?limit=${limit}`);
        if (!res.ok) return [];
        const items = await res.json();
        await renderRuns(items || []);
        return items;
      } catch { return []; }
    }

    function toggleRunsPanel() {
      if (!runsDrawer) return;
      const isOpen = runsDrawer.style.display !== 'none';
      runsDrawer.style.display = isOpen ? 'none' : 'block';
      if (!isOpen) refreshRuns();
    }

    async function renderRuns(items) {
      if (!runsActive || !runsHistory) return;
      runsActive.innerHTML = '';
      runsHistory.innerHTML = '';
      const active = items.filter(r => r.status === 'running');
      const past = items.filter(r => r.status !== 'running');

      const section = async (list, container, title) => {
        const header = document.createElement('div');
        header.style.color = '#9ca3af';
        header.style.fontWeight = '600';
        header.style.margin = '0.25rem 0 0.5rem';
        header.textContent = title;
        container.appendChild(header);
        if (list.length === 0) {
          const empty = document.createElement('div');
          empty.style.color = '#9ca3af';
          empty.textContent = 'None';
          container.appendChild(empty);
          return;
        }
        for (const run of list) {
          const row = document.createElement('div');
          row.style.border = '1px solid #263a35';
          row.style.borderRadius = '.5rem';
          row.style.padding = '.75rem';
          row.style.background = '#10231f';
          row.style.cursor = 'pointer';

          const whoEl = document.createElement('div');
          whoEl.style.color = '#E0E0E0';
          whoEl.style.fontWeight = '600';
          whoEl.textContent = 'Resolving participant…';

          // Resolve participant
          const ctx = run.context || {};
          let who = 'Unknown participant';
          try {
            if (ctx.contactId) {
              const c = await fetchContact(ctx.contactId);
              if (c) who = `${c.name || c.email} (${c.email})`;
            } else if (ctx.bookingId) {
              const b = await fetchBooking(ctx.bookingId);
              if (b) who = `${b.name || b.email} (${b.email})`;
            }
          } catch {}
          whoEl.textContent = who;

          const meta = document.createElement('div');
          meta.style.color = '#9ca3af';
          meta.style.fontSize = '.85rem';
          const start = new Date(run.started_at || run.startedAt || run.startedAtUtc || Date.now());
          const end = run.finished_at ? new Date(run.finished_at) : null;
          const dur = end ? ` • ${Math.max(0, Math.round((+end - +start)/1000))}s` : '';
          meta.textContent = `${run.status.toUpperCase()} • ${formatTime(start)}${dur}`;

          row.appendChild(whoEl);
          row.appendChild(meta);

          row.addEventListener('click', async () => {
            await showRunDetails(run.id);
          });

          container.appendChild(row);
        }
      };

      await section(active, runsActive, 'Currently Active');
      await section(past, runsHistory, 'History');
    }

    async function showRunDetails(runId) {
      const id = getCurrentWorkflowId();
      if (!id) return;
      try {
        // Authentication handled via server-side session cookies
        const res = await fetch(`${API_URL}/workflows/${id}/runs/${runId}`);
        if (!res.ok) return;
        const data = await res.json();
        renderRunDetails(data);
      } catch {}
    }

    function renderRunDetails(run) {
      if (!runDetails) return;
      runDetails.style.display = 'block';
      runDetails.innerHTML = '';

      const title = document.createElement('div');
      title.style.color = '#E0E0E0';
      title.style.fontWeight = '700';
      title.style.margin = '0.5rem 0';
      title.textContent = `Run ${run.id} • ${String(run.status).toUpperCase()}`;
      runDetails.appendChild(title);

      const list = document.createElement('div');
      list.style.display = 'flex';
      list.style.flexDirection = 'column';
      list.style.gap = '.5rem';

      (run.steps || []).forEach((step) => {
        const row = document.createElement('div');
        row.style.border = '1px solid #263a35';
        row.style.borderRadius = '.5rem';
        row.style.padding = '.5rem .75rem';
        row.style.background = '#0e201c';
        row.innerHTML = `
          <div style="display:flex;align-items:center;gap:.5rem;">
            <div style="color:#E0E0E0;font-weight:600;">Step ${Number(step.index)+1}: ${escapeHtml(step.type)}</div>
            <div style="margin-left:auto;color:#9ca3af; font-size:.85rem;">${(step.status || '').toUpperCase()}</div>
          </div>
          ${step.message ? `<div style=\"margin-top:.25rem;color:#d1d5db;white-space:pre-wrap;\">${escapeHtml(step.message)}</div>` : ''}
        `;
        row.addEventListener('click', () => highlightStep(Number(step.index)));
        list.appendChild(row);
      });
      runDetails.appendChild(list);
    }

    function toggleErrorsPanel() {
      if (!errorsDrawer) return;
      const isOpen = errorsDrawer.style.display !== 'none';
      errorsDrawer.style.display = isOpen ? 'none' : 'block';
      if (!isOpen) refreshErrors();
    }

    function renderErrors(items) {
      if (!errorsList) return;
      errorsList.innerHTML = '';
      if (!items || items.length === 0) {
        const empty = document.createElement('div');
        empty.style.color = '#9ca3af';
        empty.textContent = 'No recent errors.';
        errorsList.appendChild(empty);
        return;
      }
      const sorted = items.sort((a,b)=>b.ts-a.ts);
      sorted.forEach(err => {
        const row = document.createElement('div');
        row.style.border = '1px solid #263a35';
        row.style.borderRadius = '.5rem';
        row.style.padding = '.75rem';
        row.style.background = '#10231f';
        row.style.cursor = 'pointer';
        row.innerHTML = `
          <div style="display:flex;align-items:center;gap:.5rem;">
            <span class="material-icons-outlined" style="color:#F87171;font-size:18px">error</span>
            <div style="color:#E0E0E0;font-weight:600;">Step ${Number(err.stepIndex)+1}: ${escapeHtml(err.stepType || 'Unknown')}</div>
            <div style="margin-left:auto;color:#9ca3af;font-size:.85rem;">${formatTime(err.ts)}</div>
          </div>
          <div style="margin-top:.5rem;color:#d1d5db; white-space:pre-wrap;">${escapeHtml(err.message || '')}</div>
        `;
        row.addEventListener('click', () => {
          try { highlightStep(Number(err.stepIndex)); } catch {}
        });
        errorsList.appendChild(row);
      });
    }

    function highlightStep(stepIndex) {
      if (isNaN(stepIndex)) return;
      // Steps do not include the trigger; find action nodes in order
      const actionNodes = nodes.filter(n => n.type !== 'trigger');
      if (stepIndex < 0 || stepIndex >= actionNodes.length) return;
      const node = actionNodes[stepIndex]?.element;
      if (!node) return;
      // Select and scroll into view
      container.querySelectorAll('.flowchart-node').forEach(n => n.classList.remove('selected'));
      node.classList.add('selected');
      node.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    function formatTime(ts) {
      try { return new Date(ts).toLocaleString(); } catch { return String(ts); }
    }

    function escapeHtml(s) {
      return String(s)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    // Autosave on name changes (debounced)
    (function initNameAutosave(){
      try {
        const el = document.getElementById('workflow-name');
        if (!el) return;
        let t = null;
        el.addEventListener('input', () => {
          clearTimeout(t);
          t = setTimeout(() => { 
            try { 
              const snap = HistoryManager.buildSnapshot();
              // Record and autosave immediately for name changes
              HistoryManager.recordSnapshot('name-change');
              if (window.__DEBUG_EDITOR__) console.debug('[AUTOSAVE] Name change queued');
            } catch {}
          }, 300);
        });
      } catch {}
    })();
  </script>
</body>
</html>
</html>