<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Workflow Editor - Calendarify</title>
  <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined" rel="stylesheet" />
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #1A2E29;
      color: #E0E0E0;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    .workflow-editor {
      display: flex;
      height: 100vh;
      width: 100vw;
    }

    .toolbar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      background: #1E3A34;
      border-bottom: 1px solid #2C4A43;
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
      justify-content: flex-start;
    }

    .workflow-name-input {
      background: #1E3A34 !important;
      border: 1px solid #2C4A43 !important;
      border-radius: 0.5rem;
      padding: 0.6rem 0.9rem;
      color: #E0E0E0 !important;
      width: 280px;
      max-width: 360px;
      flex: 0 0 auto;
      font-size: 0.875rem;
      transition: all 0.2s;
    }
    
    .workflow-name-input:focus {
      outline: none;
      border-color: #34D399;
      box-shadow: 0 0 0 3px rgba(52, 211, 153, 0.1);
    }
    
    .workflow-name-input::placeholder {
      color: #A3B3AF;
    }

    .save-btn {
      background: #34D399;
      color: #ffffff;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      font-weight: 600;
      border: none;
      cursor: pointer;
      transition: all 0.2s;
    }

    .save-btn:hover {
      background: #10b981;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(52, 211, 153, 0.3);
    }

    .context-btn {
      background: #111827;
      color: #E0E0E0;
      padding: 0.5rem 0.875rem;
      border-radius: 0.5rem;
      font-weight: 500;
      border: 1px solid #374151;
      cursor: pointer;
      transition: all 0.2s;
    }

    .context-btn:hover {
      background: #1f2937;
      border-color: #4b5563;
    }

    /* Compact branch switcher controls */
    #draft-branch-switcher { gap: 6px; }
    #draft-branch-switcher .context-btn {
      padding: 2px 8px;
      font-size: 0.8rem;
      line-height: 1;
      height: 28px;
      white-space: nowrap;
    }
    #draft-branch-switcher select {
      height: 28px;
      padding: 0 6px;
      font-size: 0.85rem;
      white-space: nowrap;
      max-width: 220px;
    }

    .toolbar-group {
      display: flex;
      gap: .5rem;
      align-items: center;
      flex: 0 1 auto;
      flex-wrap: wrap;
    }

    @media (max-width: 900px) {
      .workflow-name-input { flex-basis: 100%; width: 100%; max-width: 100%; }
      .toolbar { gap: .5rem; }
      .save-btn, .context-btn { padding: 0.45rem 0.75rem; }
      #draft-branch-switcher .context-btn { padding: 2px 6px; font-size: 0.75rem; }
      #draft-branch-switcher select { max-width: 240px; }
    }

    @media (max-width: 600px) {
      .workflow-name-input { min-width: 140px; }
      .toolbar { padding: 0.5rem 0.75rem; }
      .save-btn, .context-btn { font-size: 0.85rem; }
      #draft-branch-switcher .context-btn { padding: 1px 6px; font-size: 0.7rem; }
      #draft-branch-switcher select { max-width: 150px; }
    }

    .flowchart-canvas {
      flex: 1;
      background: #1a1a1a;
      position: relative;
      overflow: auto;
      cursor: grab;
      margin-top: 96px;
      scrollbar-width: thin;
      scrollbar-color: #374151 #1a1a1a;
    }
    
    .flowchart-canvas::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    
    .flowchart-canvas::-webkit-scrollbar-track {
      background: #1a1a1a;
    }
    
    .flowchart-canvas::-webkit-scrollbar-thumb {
      background: #374151;
      border-radius: 4px;
    }
    
    .flowchart-canvas::-webkit-scrollbar-thumb:hover {
      background: #34D399;
    }

    .flowchart-canvas:active {
      cursor: grabbing;
    }

    .flowchart-container {
      min-width: 100%;
      min-height: 100%;
      padding: 2rem;
      position: relative;
    }

    .flowchart-node {
      position: absolute;
      background: #1E3A34;
      border: 2px solid #2C4A43;
      border-radius: 0.75rem;
      padding: 1rem;
      width: 320px;
      box-sizing: border-box;
      cursor: pointer;
      transition: all 0.2s;
      z-index: 10;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);
    }

    .flowchart-node:hover {
      border-color: #34D399;
      box-shadow: 0 10px 15px -3px rgba(52, 211, 153, 0.3), 0 4px 6px -2px rgba(52, 211, 153, 0.2);
      /* Preserve horizontal centering while adding subtle vertical lift */
      transform: translate(-50%, -2px);
    }

    .flowchart-node.trigger {
      background: linear-gradient(135deg, #1E3A34 0%, #19342e 100%);
      border-color: #34D399;
      border-width: 3px;
    }
    
    .flowchart-node.trigger::after {
      content: 'Click to configure';
      position: absolute;
      bottom: -25px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.75rem;
      color: #34D399;
      font-weight: 500;
      white-space: nowrap;
    }
    
    .flowchart-node.trigger.configured::after {
      display: none;
    }

    .flowchart-node.action {
      background: linear-gradient(135deg, #1E3A34 0%, #223c36 100%);
      border-color: #2C4A43;
    }

    .flowchart-node.selected {
      border-color: #34D399;
      box-shadow: 0 0 25px rgba(52, 211, 153, 0.5);
    }

    .node-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
      position: relative;
    }
    
    .node-actions {
      display: flex;
      gap: 0.25rem;
      margin-left: auto;
    }
    
    .node-action-btn {
      background: none;
      border: none;
      color: #A3B3AF;
      cursor: pointer;
      padding: 0.25rem;
      border-radius: 0.25rem;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .node-action-btn:hover {
      background: rgba(52, 211, 153, 0.1);
      color: #34D399;
    }
    
    .node-action-btn .material-icons-outlined {
      font-size: 1rem;
    }

    .node-icon {
      color: #34D399;
      font-size: 1.25rem;
    }

    .node-title {
      font-weight: 600;
      color: #E0E0E0;
      font-size: 0.9rem;
    }

    .node-content {
      color: #A3B3AF;
      font-size: 0.8rem;
      line-height: 1.4;
    }

    .connection-line {
      position: absolute;
      background: #2C4A43;
      z-index: 5;
      height: 2px;
      transform-origin: 0 0;
    }

    .connection-line:hover {
      background: #34D399;
      box-shadow: 0 0 10px rgba(52, 211, 153, 0.5);
    }

    .add-action-orb {
      position: absolute;
      width: 40px;
      height: 40px;
      background: #34D399;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 15;
      box-shadow: 0 4px 12px rgba(52, 211, 153, 0.3);
    }

    .add-action-orb:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 20px rgba(52, 211, 153, 0.5);
    }

    .add-action-orb .material-icons-outlined {
      color: #1A2E29;
      font-size: 1.25rem;
    }

    .insert-action-orb {
      position: absolute;
      width: 32px;
      height: 32px;
      background: linear-gradient(135deg, #34D399 0%, #10B981 100%);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 25;
      box-shadow: 0 3px 8px rgba(52, 211, 153, 0.3);
      border: 2px solid rgba(255, 255, 255, 0.1);
    }

    .insert-action-orb:hover {
      transform: scale(1.1);
      box-shadow: 0 4px 12px rgba(52, 211, 153, 0.5);
    }

    .insert-action-orb .material-icons-outlined {
      color: #1A2E29;
      font-size: 1rem;
    }

    .modal-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .workflow-loading-screen {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #1a1a1a;
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1rem;
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid #374151;
      border-top: 3px solid #34D399;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .loading-text {
      color: #A3B3AF;
      font-size: 0.875rem;
      font-weight: 500;
    }

    .modal {
      background: #374151;
      border: 1px solid #4b5563;
      border-radius: 0.75rem;
      padding: 1.5rem;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
    }

    .modal-header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid #4b5563;
    }

    .modal-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: #E0E0E0;
    }

    .modal-close {
      margin-left: auto;
      background: none;
      border: none;
      color: #A3B3AF;
      cursor: pointer;
      padding: 0.25rem;
      border-radius: 0.25rem;
      transition: all 0.2s;
    }

    .modal-close:hover {
      color: #E0E0E0;
      background: #19342e;
    }

    .form-group {
      margin-bottom: 1rem;
    }

    .form-label {
      display: block;
      color: #A3B3AF;
      font-size: 0.875rem;
      margin-bottom: 0.5rem;
    }

    .form-select {
      width: 100%;
      background: #1E3A34 !important;
      border: 1px solid #2C4A43 !important;
      border-radius: 0.5rem;
      padding: 0.75rem;
      color: #E0E0E0 !important;
      font-size: 0.875rem;
      transition: all 0.2s;
    }

    .form-select:focus {
      outline: none;
      border-color: #34D399;
      box-shadow: 0 0 0 3px rgba(52, 211, 153, 0.1);
    }
    
    .form-select option {
      background: #1E3A34;
      color: #E0E0E0;
    }
    
    /* Ensure all form elements use dark theme */
    select.form-select {
      background: #1E3A34 !important;
      color: #E0E0E0 !important;
    }
    
    select.form-select option {
      background: #1E3A34 !important;
      color: #E0E0E0 !important;
    }
    
    /* Override browser defaults for select elements */
    select {
      background: #1E3A34 !important;
      color: #E0E0E0 !important;
    }
    
    select option {
      background: #1E3A34 !important;
      color: #E0E0E0 !important;
    }

    .multi-select {
      position: relative;
      width: 100%;
    }

    .multi-select-button {
      background: #1E3A34;
      border: 1px solid #2C4A43;
      border-radius: 0.5rem;
      padding: 0.75rem;
      color: #E0E0E0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      cursor: pointer;
      transition: all 0.2s;
    }

    .multi-select-button:hover {
      border-color: #34D399;
      background: #2C4A43;
    }

    .multi-select-options {
      position: absolute;
      left: 0;
      top: 100%;
      margin-top: 0.25rem;
      width: 100%;
      background: #1E3A34;
      border: 1px solid #2C4A43;
      border-radius: 0.5rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.2);
      z-index: 50;
      max-height: 200px;
      overflow-y: auto;
      display: none;
      padding: 0.5rem 0;
    }

    .multi-select-options.show {
      display: block;
    }

    .multi-select-option {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem;
      color: #E0E0E0;
      cursor: pointer;
      transition: all 0.2s;
      border-radius: 0.25rem;
      margin: 0 0.5rem;
    }

    .multi-select-option:hover {
      background: #2C4A43;
    }

    .multi-select-option input[type="checkbox"] {
      width: 1rem;
      height: 1rem;
      accent-color: #34D399;
    }

    .select-all-btn {
      background: #34D399;
      color: #ffffff;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      font-size: 0.875rem;
      font-weight: 500;
      border: none;
      cursor: pointer;
      transition: all 0.2s;
      margin: 0.5rem;
    }

    .select-all-btn:hover {
      background: #10b981;
      transform: translateY(-1px);
    }

    .modal-actions {
      display: flex;
      gap: 1rem;
      justify-content: flex-end;
      margin-top: 2rem;
      padding-top: 1rem;
      border-top: 1px solid #4b5563;
    }

    .btn-secondary {
      background: #6b7280;
      color: #E0E0E0;
      padding: 0.75rem 1.5rem;
      border-radius: 0.5rem;
      font-weight: 500;
      border: 1px solid #6b7280;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-secondary:hover {
      background: #4b5563;
      color: #E0E0E0;
    }

    .btn-primary {
      background: #34D399;
      color: #ffffff;
      padding: 0.75rem 1.5rem;
      border-radius: 0.5rem;
      font-weight: 600;
      border: none;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-primary:hover {
      background: #10b981;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(52, 211, 153, 0.3);
    }

    .btn-primary:disabled {
      background: #94a3b8;
      cursor: not-allowed;
      opacity: 0.6;
    }

    .coming-soon {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .coming-soon .form-select {
      cursor: not-allowed;
    }

    .coming-soon-badge {
      background: #f59e0b;
      color: white;
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.75rem;
      margin-left: 0.5rem;
      font-weight: 500;
    }

    /* Notification styles */
    .notification {
      position: fixed;
      top: 1rem;
      right: 1rem;
      z-index: 9999;
      padding: 1rem;
      border-radius: 0.5rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
      min-width: 300px;
      transform: translateX(100%);
      transition: transform 0.3s ease-in-out;
    }

    .notification.show {
      transform: translateX(0);
    }

    .notification.success {
      background: #34D399;
      color: white;
    }

    .notification.error {
      background: #EF4444;
      color: white;
    }
  </style>
</head>
<body>
  <div class="workflow-editor">
    <!-- Toolbar -->
    <div class="toolbar">
      <input type="text" id="workflow-name" class="workflow-name-input" placeholder="Enter workflow name...">
      <div class="toolbar-group">
        <div id="draft-branch-switcher" style="display:flex;align-items:center;gap:.6rem;background:#0b1715;border:1px solid #2C4A43;border-radius:8px;padding:6px 10px;">
          <span class="material-icons-outlined" style="font-size:18px;color:#A3B3AF">call_split</span>
          <div id="branch-dropdown" style="position:relative;display:flex;align-items:center;gap:8px;">
            <button id="branch-trigger" class="context-btn" style="height:32px;padding:4px 10px;white-space:nowrap;display:flex;align-items:center;gap:6px;max-width:480px;overflow:hidden;text-overflow:ellipsis">
              <span class="material-icons-outlined" style="font-size:16px;">arrow_drop_down</span>
              <span id="branch-current-label">Main</span>
            </button>
            <div id="branch-menu" style="position:absolute;top:38px;left:0;background:#0b1715;border:1px solid #2C4A43;border-radius:10px;display:none;z-index:1000;min-width:420px;box-shadow:0 12px 28px rgba(0,0,0,0.45);padding:8px;max-width:80vw">
              <div class="branch-item" data-branch="main" style="display:flex;align-items:center;justify-content:space-between;gap:8px;padding:8px 10px;border-radius:8px;cursor:pointer;">
                <span>Main</span>
              </div>
              <div style="height:1px;background:#223A35;margin:6px 0;"></div>
              <div id="branch-items" style="display:flex;flex-direction:column;gap:6px"></div>
            </div>
          </div>
          <button class="context-btn" id="create-branch-btn">New Draft</button>
          <button class="context-btn" id="apply-branch-to-main-btn" title="Apply current draft to Main">Apply to Main</button>
        </div>
        <a href="/editor/guide" target="_blank" class="save-btn" style="background:#12221E;border:1px solid #2C4A43;color:#E0E0E0;text-decoration:none;display:inline-flex;align-items:center;gap:.35rem">
          <span class="material-icons-outlined" style="font-size:18px;color:#A3B3AF">menu_book</span>
          Guide
        </a>
        <button id="save-workflow" class="save-btn" onclick="saveWorkflow()">Save Workflow</button>
      </div>
      <button id="open-context" class="context-btn" onclick="openContextModal()">Context</button>
      <button id="open-errors" class="context-btn" onclick="toggleErrorsPanel()">Errors</button>
      <button id="open-runs" class="context-btn" onclick="toggleRunsPanel()">Runs</button>
    </div>

    <!-- Flowchart Canvas -->
    <div class="flowchart-canvas" id="flowchart-canvas">
      <div class="workflow-loading-screen" id="workflow-loading-screen">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading workflow...</div>
        </div>
      <div class="flowchart-container" id="flowchart-container">
        <!-- Trigger node will be added here -->
      </div>
      
      <!-- Errors Drawer -->
      <div id="errors-drawer" style="position:absolute; right:0; top:0; bottom:0; width:420px; background:#0b1715; border-left:1px solid #2C4A43; display:none; z-index:200; padding:1rem; overflow:auto;">
        <div style="display:flex;align-items:center;gap:.5rem; margin-bottom:.75rem;">
          <span class="material-icons-outlined" style="color:#F87171">error</span>
          <div style="font-weight:600;color:#E0E0E0">Latest Workflow Errors</div>
          <div style="margin-left:auto; display:flex; gap:.5rem;">
            <button class="context-btn" onclick="refreshErrors()">Refresh</button>
            <button class="context-btn" onclick="toggleErrorsPanel()">Close</button>
          </div>
        </div>
        <div id="errors-list" style="display:flex; flex-direction:column; gap:.75rem;"></div>
      </div>
      
      <!-- Runs Drawer -->
      <div id="runs-drawer" style="position:absolute; right:0; top:0; bottom:0; width:480px; background:#0b1715; border-left:1px solid #2C4A43; display:none; z-index:200; padding:1rem; overflow:auto;">
        <div style="display:flex;align-items:center;gap:.5rem; margin-bottom:.75rem;">
          <span class="material-icons-outlined" style="color:#60A5FA">timeline</span>
          <div style="font-weight:600;color:#E0E0E0">Workflow Runs</div>
          <div style="margin-left:auto; display:flex; gap:.5rem;">
            <button class="context-btn" onclick="refreshRuns()">Refresh</button>
            <button class="context-btn" onclick="toggleRunsPanel()">Close</button>
          </div>
        </div>
        <div id="runs-active" style="margin-bottom:1rem;"></div>
        <div id="runs-history"></div>
        <div id="run-details" style="margin-top:1rem; display:none;"></div>
      </div>
    </div>
  </div>

  <!-- Confirm Modal (themed) -->
  <div id="confirm-modal" class="modal-backdrop hidden">
    <div class="modal" style="background:#0b1715;border:1px solid #2C4A43;color:#E0E0E0">
      <div class="modal-header">
        <span class="material-icons-outlined node-icon">help_outline</span>
        <h3 class="modal-title" id="confirm-title">Confirm</h3>
        <button class="modal-close" onclick="(function(){document.getElementById('confirm-modal').classList.add('hidden')})()">
          <span class="material-icons-outlined">close</span>
        </button>
      </div>
      <div class="form-group" style="padding: 0 .5rem 0 .5rem">
        <div id="confirm-message" style="white-space:pre-wrap; color:#CFE7E1"></div>
      </div>
      <div class="modal-actions">
        <button class="btn-secondary" id="confirm-cancel">Cancel</button>
        <button class="btn-primary" id="confirm-ok">Confirm</button>
      </div>
    </div>
  </div>

  <!-- Prompt Modal (themed) -->
  <div id="prompt-modal" class="modal-backdrop hidden">
    <div class="modal" style="background:#0b1715;border:1px solid #2C4A43;color:#E0E0E0">
      <div class="modal-header">
        <span class="material-icons-outlined node-icon">edit</span>
        <h3 class="modal-title" id="prompt-title">Rename</h3>
        <button class="modal-close" onclick="(function(){document.getElementById('prompt-modal').classList.add('hidden')})()">
          <span class="material-icons-outlined">close</span>
        </button>
      </div>
      <div class="form-group">
        <label class="form-label" id="prompt-label">New name</label>
        <input type="text" id="prompt-input" class="form-input" style="background:#0b1715;border:1px solid #2C4A43;color:#E0E0E0" />
      </div>
      <div class="modal-actions">
        <button class="btn-secondary" id="prompt-cancel">Cancel</button>
        <button class="btn-primary" id="prompt-ok">Save</button>
      </div>
    </div>
  </div>

  <!-- Trigger Modal -->
  <div id="trigger-modal" class="modal-backdrop hidden">
    <div class="modal">
      <div class="modal-header">
        <span class="material-icons-outlined node-icon">play_circle</span>
        <h3 class="modal-title">Configure Trigger</h3>
        <button class="modal-close" onclick="closeTriggerModal()">
          <span class="material-icons-outlined">close</span>
        </button>
      </div>
      
      <div class="form-group">
        <label class="form-label">Trigger Type</label>
        <select id="trigger-select" class="form-select">
          <option value="Meeting Scheduled">Meeting Scheduled</option>
          <option value="Tag Added">Tag Added</option>
          <option value="Attendee Rescheduled" disabled class="coming-soon">Attendee Rescheduled <span class="coming-soon-badge">Coming Soon</span></option>
          <option value="Host Rescheduled" disabled class="coming-soon">Host Rescheduled <span class="coming-soon-badge">Coming Soon</span></option>
          <option value="Attendee Canceled" disabled class="coming-soon">Attendee Canceled <span class="coming-soon-badge">Coming Soon</span></option>
          <option value="Host Canceled" disabled class="coming-soon">Host Canceled <span class="coming-soon-badge">Coming Soon</span></option>
          <option value="Meeting Ended" disabled class="coming-soon">Meeting Ended <span class="coming-soon-badge">Coming Soon</span></option>
        </select>
      </div>

      <div id="trigger-properties"></div>

      <div class="modal-actions">
        <button class="btn-secondary" onclick="closeTriggerModal()">Cancel</button>
        <button class="btn-primary" onclick="saveTrigger()">Save Trigger</button>
      </div>
    </div>
  </div>

  <!-- Action Modal -->
  <div id="action-modal" class="modal-backdrop hidden">
    <div class="modal">
      <div class="modal-header">
        <span class="material-icons-outlined node-icon">settings</span>
        <h3 class="modal-title">Add Action</h3>
        <button class="modal-close" onclick="closeActionModal()">
          <span class="material-icons-outlined">close</span>
        </button>
      </div>
      
      <div class="form-group">
        <label class="form-label">Action Type</label>
        <select id="action-select" class="form-select">
          <option value="Add Tag">Add Tag</option>
          <option value="Send Email">Send Email</option>
          <option value="If">If</option>
          <option value="Create Meeting" disabled class="coming-soon">Create Meeting <span class="coming-soon-badge">Coming Soon</span></option>
        </select>
      </div>

      <div id="action-properties"></div>

      <div class="modal-actions">
        <button class="btn-secondary" onclick="closeActionModal()">Cancel</button>
        <button class="btn-primary" onclick="saveAction()" id="action-save-btn">Add Action</button>
      </div>
    </div>
  </div>

  <!-- Context Modal -->
  <div id="context-modal" class="modal-backdrop hidden">
    <div class="modal" style="max-width: 760px; width: 95%">
      <div class="modal-header">
        <span class="material-icons-outlined node-icon">integration_instructions</span>
        <h3 class="modal-title">Execution Context</h3>
        <button class="modal-close" onclick="closeContextModal()">
          <span class="material-icons-outlined">close</span>
        </button>
      </div>

      <div class="form-group">
        <label class="form-label">Attach full contact/booking context to workflow runs</label>
        <label style="display:flex;align-items:center;gap:.5rem;color:#E0E0E0">
          <input type="checkbox" id="context-attach-full" />
          <span>Enable full context (contact + booking)</span>
        </label>
      </div>

      <div class="form-group">
        <label class="form-label">Schema Preview</label>
        <pre id="context-schema" style="background:#111827;border:1px solid #374151;border-radius:.5rem;padding:1rem;white-space:pre-wrap;max-height:240px;overflow:auto;color:#d1d5db"></pre>
        <div style="margin-top:.5rem;display:flex;gap:.5rem">
          <button class="context-btn" onclick="copyContextSchema()">Copy Schema</button>
          <span id="context-schema-copy-status" style="color:#A3B3AF"></span>
        </div>
      </div>

      <div class="form-group">
        <label class="form-label">Optional Sample Payload (JSON)</label>
        <textarea id="context-sample"
          placeholder='{"contact": {"id":"..."}, "booking": {"id":"..."}}'
          style="width:100%;min-height:140px;background:#111827;border:1px solid #374151;border-radius:.5rem;padding:.75rem;color:#E0E0E0;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace"></textarea>
        <div style="margin-top:.25rem;color:#9ca3af;font-size:.85rem">Saved with the workflow for testing and future evaluation. Optional.</div>
      </div>

      <div class="modal-actions">
        <button class="btn-secondary" onclick="closeContextModal()">Cancel</button>
        <button class="btn-primary" onclick="saveContextSpec()">Save Context</button>
      </div>
    </div>
  </div>

  <script defer>
    // Constants and utilities
    const API_URL = 'http://localhost:3001/api';
    const NODE_WIDTH = 320;          // px, matches .flowchart-node width
    const VERTICAL_SPACING = 120;    // px vertical spacing between nodes
    const ORB_SIZE = 40;             // px, action orb size
    const INSERT_ORB_SIZE = 32;      // px, insert orb size
    const DEBUG_LINE_PATHS = false;   // reduce noise; enable on demand

    // Context spec (versioned) persisted with workflows for future engine use
    let contextSpec = null;

    function getDefaultContextSchema() {
      return {
        contact: {
          id: 'string',
          firstName: 'string',
          lastName: 'string',
          fullName: 'string',
          email: 'string',
          phone: 'string',
          timezone: 'string',
          locale: 'string',
          tags: ['string'],
          company: 'string',
          title: 'string',
          notes: 'string',
          createdAt: 'string',
          updatedAt: 'string',
          customFields: 'object'
        },
        booking: {
          id: 'string',
          title: 'string',
          status: 'string',
          eventType: 'string',
          startTime: 'string',
          endTime: 'string',
          durationMinutes: 'number',
          timezone: 'string',
          location: 'string',
          meetingLink: 'string',
          attendees: [
            {
              name: 'string',
              email: 'string',
              role: 'string'
            }
          ],
          rescheduleCount: 'number',
          answers: 'object',
          metadata: 'object',
          createdAt: 'string',
          updatedAt: 'string'
        }
      };
    }

    function getDefaultContextSpec() {
      return {
        version: 1,
        attachFullContext: true,
        scope: 'full', // future: 'subset'
        schema: getDefaultContextSchema(),
        sample: null
      };
    }
    
    function getAnyToken() {
      return sessionStorage.getItem('calendarify-token') || localStorage.getItem('calendarify-token');
    }
    
    // Global variables
    let currentWorkflow = null;
    let currentNodeId = 0;
    let nodes = [];
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let canvasOffset = { x: 0, y: 0 };
    let selectedNode = null;
    let didFirstPanRefresh = false;
    let isLoadingWorkflow = false;
    let currentLoadSteps = null;

    // Production-grade Connection and Orb Management System
    const WorkflowManager = {
      connections: new Map(), // connectionId -> connection object
      orbs: new Map(), // nodeId -> orb element
      insertOrbs: new Map(), // connectionId -> insert orb element
      connectionCounter: 0,
      svg: null,
      // Helper: create midpoint insert orbs for all valid connections
      addInsertOrbsForConnections() {
        try {
          for (const connection of this.connections.values()) {
            const fromNode = connection.from;
            const toNode = connection.to;
            // Determine types
            const fromType = (fromNode.__nodeData && fromNode.__nodeData.data?.type) || nodes.find(n=>n.element===fromNode)?.data?.type || '';
            const toType = (toNode.__nodeData && toNode.__nodeData.data?.type) || nodes.find(n=>n.element===toNode)?.data?.type || '';
            // Never show an insert orb on the connections from IF to its True/False headers
            if (fromType === 'If' && (toType === 'True' || toType === 'False')) continue;
            // Skip orbs on If->True/False when a join node already exists for this IF
            try {
              const fromData = nodes.find(n => n.element === fromNode)?.data || {};
              const toData = nodes.find(n => n.element === toNode)?.data || {};
              const ifId = (fromType === 'If' && (toType === 'True' || toType === 'False'))
                ? (fromData.properties?.ifId)
                : ((toType === 'If' && (fromType === 'True' || fromType === 'False')) ? (toData.properties?.ifId) : null);
              if (ifId) {
                const hasJoin = nodes.some(n => n.data && n.data.properties && n.data.properties.joinForIfId === ifId);
                if (hasJoin) continue;
              }
              // Also never put midpoint orbs on connections leading into a join node
              if (toData && toData.properties && toData.properties.joinForIfId) continue;
            } catch {}
            // Otherwise add midpoint insert orb
            this.createInsertOrb(connection);
          }
        } catch (e) { console.warn('addInsertOrbsForConnections failed:', e); }
      },

      // Add a synthetic insert orb between last TRUE and FALSE branch nodes for each IF (if no join exists yet)
      addBranchJoinOrbs() {
        try {
          // Remove any prior synthetic join orbs
          for (const [id, orb] of Array.from(this.insertOrbs.entries())) {
            if (String(id).startsWith('join-')) {
              try { if (orb && orb.parentNode) orb.remove(); } catch {}
              this.insertOrbs.delete(id);
            }
          }
          // For each IF, compute last branch nodes and create a synthetic orb at their midpoint
          const ifNodes = nodes.filter(n => n.data && n.data.type === 'If');
          for (const ifNode of ifNodes) {
            const ifId = ifNode.data?.properties?.ifId;
            if (!ifId) continue;
            // Skip if a join node already exists
            const hasJoin = nodes.some(n => n.data && n.data.properties && n.data.properties.joinForIfId === ifId);
            if (hasJoin) continue;
            let lastTrue = null;
            let lastFalse = null;
            for (const n of nodes) {
              const d = n.data;
              if (!d || d.type === 'If' || d.type === 'True' || d.type === 'False') continue;
              if (d.properties && d.properties.parentIfId === ifId) {
                if (d.properties.branch === 'true') lastTrue = n;
                if (d.properties.branch === 'false') lastFalse = n;
              }
            }
            if (lastTrue && lastFalse) {
              const pseudo = { id: `join-${ifId}`, from: lastTrue.element, to: lastFalse.element };
              // Create and position orb
              try {
                // Remove existing synthetic orb if any
                const existing = this.insertOrbs.get(pseudo.id);
                if (existing && existing.parentNode) existing.remove();
                this.insertOrbs.delete(pseudo.id);
              } catch {}
              // Reuse createInsertOrb logic
              const insertOrb = document.createElement('div');
              insertOrb.className = 'insert-action-orb';
              insertOrb.dataset.connectionId = pseudo.id;
              insertOrb.style.cssText = `position: absolute; width: 32px; height: 32px; background: linear-gradient(135deg, #34D399 0%, #10B981 100%); border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; z-index: 25; opacity: 0; transform: scale(0.8); transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: 0 3px 8px rgba(52, 211, 153, 0.3); border: 2px solid rgba(255, 255, 255, 0.1);`;
              insertOrb.innerHTML = `<span class="material-icons-outlined" style="color: #1A2E29; font-size: 1rem;">add</span>`;
              insertOrb.addEventListener('click', (e) => {
                e.stopPropagation();
                // Use pseudo connection to drive insertion
                window.insertConnection = pseudo;
                openActionModal('insert');
              });
              insertOrb.addEventListener('mouseenter', () => { insertOrb.style.transform = 'scale(1.1)'; insertOrb.style.boxShadow = '0 4px 12px rgba(52, 211, 153, 0.5)'; });
              insertOrb.addEventListener('mouseleave', () => { insertOrb.style.transform = 'scale(1)'; insertOrb.style.boxShadow = '0 3px 8px rgba(52, 211, 153, 0.3)'; });
              container.appendChild(insertOrb);
              this.insertOrbs.set(pseudo.id, insertOrb);
              // Position it
              try { this.updateInsertOrbPosition(pseudo); } catch {}
              requestAnimationFrame(() => { insertOrb.style.opacity = '1'; insertOrb.style.transform = 'scale(1)'; });
            }
          }
        } catch (e) { console.warn('addBranchJoinOrbs failed:', e); }
      },
      
      // Initialize the system
      init() {
        this.connections.clear();
        this.orbs.clear();
        this.insertOrbs.clear();
        this.connectionCounter = 0;
        // Ensure an SVG overlay exists for pretty paths
        let svg = container.querySelector('#connections-svg');
        if (!svg) {
          svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          svg.setAttribute('id', 'connections-svg');
          svg.setAttribute('width', '100%');
          svg.setAttribute('height', '100%');
          svg.style.position = 'absolute';
          svg.style.left = '0';
          svg.style.top = '0';
          svg.style.pointerEvents = 'none';
          svg.style.zIndex = '4';
          container.appendChild(svg);
        }
        this.svg = svg;
        console.log('[WFLOW] Manager init');
      },
      
      // Create a connection between two nodes
      createConnection(fromNode, toNode, createInsertOrb = true) {
        if (!this.isValidConnection(fromNode, toNode)) {
          console.warn('Invalid connection attempt:', fromNode?.id, '->', toNode?.id);
          return null;
        }
        
        const connectionId = `conn-${++this.connectionCounter}`;
        
        // Remove any existing connection between these nodes
        this.removeConnectionBetween(fromNode, toNode);
        
        const line = this.createConnectionLine(connectionId);
        const connection = {
          id: connectionId,
          from: fromNode,
          to: toNode,
          line: line,
          created: Date.now()
        };
        
        this.connections.set(connectionId, connection);
        this.updateConnectionPosition(connection);
        
        // Make the line visible after positioning
        connection.line.style.opacity = '1';
        
        // Create insert orb in the middle of the connection (only if requested)
        if (createInsertOrb) {
          // Skip adding insert orbs on any connection that involves an If node
          const fromType = (fromNode.__nodeData && fromNode.__nodeData.data?.type) || nodes.find(n=>n.element===fromNode)?.data?.type || '';
          const toType = (toNode.__nodeData && toNode.__nodeData.data?.type) || nodes.find(n=>n.element===toNode)?.data?.type || '';
          if (!(fromType === 'If' || toType === 'If')) {
            this.createInsertOrb(connection);
          }
        }
        
        console.log('Created connection:', connectionId);
        return connection;
      },
      
      // Create the visual connection line element
      createConnectionLine(id) {
        // Use SVG path for smoother, orthogonal lines with rounded corners
        if (!this.svg) this.init();
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('id', id);
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke', '#34D399');
        path.setAttribute('stroke-width', '3');
        path.setAttribute('stroke-linecap', 'round');
        path.setAttribute('stroke-linejoin', 'round');
        path.style.opacity = '0';
        this.svg.appendChild(path);
        requestAnimationFrame(() => { path.style.opacity = '1'; });
        return path;
      },
      
      // Create insert orb in the middle of a connection
      createInsertOrb(connection) {
        if (!connection || !connection.from || !connection.to) {
          return;
        }
        
        const insertOrb = document.createElement('div');
        insertOrb.className = 'insert-action-orb';
        insertOrb.dataset.connectionId = connection.id;
        insertOrb.style.cssText = `
          position: absolute;
          width: 32px;
          height: 32px;
          background: linear-gradient(135deg, #34D399 0%, #10B981 100%);
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          z-index: 25;
          opacity: 0;
          transform: scale(0.8);
          transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
          box-shadow: 0 3px 8px rgba(52, 211, 153, 0.3);
          border: 2px solid rgba(255, 255, 255, 0.1);
        `;
        
        insertOrb.innerHTML = `
          <span class="material-icons-outlined" style="color: #1A2E29; font-size: 1rem;">add</span>
        `;
        
        // Add click handler
        insertOrb.addEventListener('click', (e) => {
          e.stopPropagation();
          this.handleInsertOrbClick(connection);
        });
        
        // Add hover effects
        insertOrb.addEventListener('mouseenter', () => {
          insertOrb.style.transform = 'scale(1.1)';
          insertOrb.style.boxShadow = '0 4px 12px rgba(52, 211, 153, 0.5)';
        });
        
        insertOrb.addEventListener('mouseleave', () => {
          insertOrb.style.transform = 'scale(1)';
          insertOrb.style.boxShadow = '0 3px 8px rgba(52, 211, 153, 0.3)';
        });
        
        container.appendChild(insertOrb);
        this.insertOrbs.set(connection.id, insertOrb);
        
        // Position the insert orb
        this.updateInsertOrbPosition(connection);
        
        // Animate in
        requestAnimationFrame(() => {
          insertOrb.style.opacity = '1';
          insertOrb.style.transform = 'scale(1)';
        });
        
        console.log('Created insert orb for connection:', connection.id);
      },
      
      // Update insert orb position
      updateInsertOrbPosition(connection) {
        const insertOrb = this.insertOrbs.get(connection.id);
        if (!insertOrb || !connection.from || !connection.to) {
          return;
        }
        
        try {
          // Midpoint orbs are allowed on If-related connections until a join node exists.
          // addInsertOrbsForConnections() already suppresses orbs when a join is present.

          const fromRect = connection.from.getBoundingClientRect();
          const toRect = connection.to.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          
          if (!fromRect || !toRect || !containerRect) {
            return;
          }
          
          // Calculate middle point of the connection
          const fromX = fromRect.left - containerRect.left + fromRect.width / 2;
          const fromY = fromRect.bottom - containerRect.top;
          const toX = toRect.left - containerRect.left + toRect.width / 2;
          const toY = toRect.top - containerRect.top;
          
          const middleX = (fromX + toX) / 2;
          const middleY = (fromY + toY) / 2;
          
          // Position the insert orb
          insertOrb.style.left = `${middleX - 16}px`; // 16 is half of orb width
          insertOrb.style.top = `${middleY - 16}px`; // 16 is half of orb height
          
        } catch (error) {
          console.error('Error updating insert orb position:', error);
        }
      },
      
      // Handle insert orb click
      handleInsertOrbClick(connection) {
        console.log('Insert orb clicked for connection:', connection.id);
        // Store the connection info for insertion
        window.insertConnection = connection;
        openActionModal('insert');
      },
      
      // Update connection position
      updateConnectionPosition(connection) {
        if (!connection || !connection.line || !connection.from || !connection.to) {
          return;
        }
        
        try {
          const fromRect = connection.from.getBoundingClientRect();
          const toRect = connection.to.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          
          if (!fromRect || !toRect || !containerRect) {
            return;
          }
          
          // Calculate anchor points: center bottom of from, center top of to
          const fromX = Math.round(fromRect.left - containerRect.left + fromRect.width / 2);
          const fromY = Math.round(fromRect.bottom - containerRect.top - 1);
          const toX = Math.round(toRect.left - containerRect.left + toRect.width / 2);
          const toY = Math.round(toRect.top - containerRect.top + 1);

          // Determine orthogonal path for branch headers; smooth curve for others
          const fromType = (connection.from.__nodeData && connection.from.__nodeData.data?.type) || nodes.find(n=>n.element===connection.from)?.data?.type || '';
          const toType = (connection.to.__nodeData && connection.to.__nodeData.data?.type) || nodes.find(n=>n.element===connection.to)?.data?.type || '';

          // Attach node data refs to DOM once for quicker lookup
          connection.from.__nodeData = nodes.find(n => n.element === connection.from) || connection.from.__nodeData || null;
          connection.to.__nodeData = nodes.find(n => n.element === connection.to) || connection.to.__nodeData || null;

          let d = '';
          const vDrop = 30; // vertical drop from source (default)
          const r = 12; // corner radius
          // Always render join-node targets with orthogonal rounded corners (mirror of IF->headers)
          if (this.toNodeHasJoin(toType, connection)) {
            // For join targets, drop further and shorten approach more to center visually
            const vDropJoin = 56;
            const approachShorten = 14;
            const midY = fromY + vDropJoin;
            const dir = (toX >= fromX) ? 1 : -1;
            d += `M ${fromX} ${fromY}`;
            d += ` L ${fromX} ${midY - r}`;
            d += ` Q ${fromX} ${midY} ${fromX + dir * r} ${midY}`;
            d += ` L ${toX - dir * (r + approachShorten)} ${midY}`;
            d += ` Q ${toX} ${midY} ${toX} ${midY + r}`;
            d += ` L ${toX} ${toY}`;
            // Ensure DOM path reflects rounded corners
            connection.line.setAttribute('stroke-linecap', 'round');
            connection.line.setAttribute('stroke-linejoin', 'round');
          } else if (fromType === 'If' && (toType === 'True' || toType === 'False')) {
            const midY = fromY + vDrop;
            // Horizontal toward destination x
            const hx1 = fromX;
            const hy1 = midY;
            const hx2 = toX;
            const hy2 = midY;
            // Build path with rounded corners using quadratic curves
            // Start
            d += `M ${fromX} ${fromY}`;
            // Vertical down to just before corner
            d += ` L ${fromX} ${hy1 - r}`;
            // Corner: down->right (or down->left)
            const dir = (toX >= fromX) ? 1 : -1;
            d += ` Q ${fromX} ${hy1} ${fromX + dir * r} ${hy1}`;
            // Horizontal toward near the destination x
            d += ` L ${hx2 - dir * r} ${hy2}`;
            // Corner: right/left -> down
            d += ` Q ${hx2} ${hy2} ${hx2} ${hy2 + r}`;
            // Vertical down to target
            d += ` L ${toX} ${toY}`;
          } else if ((fromType === 'True' || fromType === 'False')) {
              if (!(toType === 'True' || toType === 'False')) {
              // From branch header to first branch node: longer vertical drop for balance
              const ctrlY = fromY + 36;
              d = `M ${fromX} ${fromY} Q ${fromX} ${ctrlY} ${fromX} ${ctrlY} L ${toX} ${ctrlY} Q ${toX} ${ctrlY} ${toX} ${toY}`;
            } else {
              // Fallback generic curve
              const mx = Math.round((fromX + toX) / 2);
              d = `M ${fromX} ${fromY} C ${mx} ${fromY}, ${mx} ${toY}, ${toX} ${toY}`;
            }
          } else {
            // Generic smooth curve from from to to
            const mx = Math.round((fromX + toX) / 2);
            d = `M ${fromX} ${fromY} C ${mx} ${fromY}, ${mx} ${toY}, ${toX} ${toY}`;
          }

          connection.line.setAttribute('d', d);
          connection.line.style.display = 'block';
          if (DEBUG_LINE_PATHS) {
            const fromId = connection.from.id;
            const toId = connection.to.id;
            const hasJoin = this.toNodeHasJoin(toType, connection);
            console.log('[LINES]', {
              fromId, toId, fromType, toType, hasJoin,
              fromX, fromY, toX, toY, vDrop: 30, r: 12,
              path: d
            });
          }

          
          // Update insert orb position
          this.updateInsertOrbPosition(connection);
          
        } catch (error) {
          console.error('Error updating connection position:', error);
        }
      },

      // helper: detect join target
      toNodeHasJoin(toType, connection) {
        try {
          if (!connection || !connection.to) return false;
          const toData = (connection.to.__nodeData && connection.to.__nodeData.data) || (nodes.find(n => n.element === connection.to)?.data) || null;
          return !!(toData && toData.properties && toData.properties.joinForIfId);
        } catch { return false; }
      },

      isJoinNode(toEl) {
        try {
          const toData = (toEl && toEl.__nodeData && toEl.__nodeData.data) || (nodes.find(n => n.element === toEl)?.data) || null;
          return !!(toData && toData.properties && toData.properties.joinForIfId);
        } catch { return false; }
      },
      
      // Remove a specific connection
      removeConnection(connectionId) {
        const connection = this.connections.get(connectionId);
        if (connection) {
          if (connection.line && connection.line.parentNode) {
            connection.line.style.opacity = '0';
            setTimeout(() => {
              if (connection.line.parentNode) {
                connection.line.remove();
              }
            }, 300);
          }
          
          // Remove insert orb
          const insertOrb = this.insertOrbs.get(connectionId);
          if (insertOrb) {
            insertOrb.style.opacity = '0';
            insertOrb.style.transform = 'scale(0.8)';
            setTimeout(() => {
              if (insertOrb.parentNode) {
                insertOrb.remove();
              }
            }, 300);
            this.insertOrbs.delete(connectionId);
          }
          
          this.connections.delete(connectionId);
          console.log('Removed connection:', connectionId);
        }
      },
      
      // Remove connection between two specific nodes
      removeConnectionBetween(fromNode, toNode) {
        for (const [id, connection] of this.connections) {
          if ((connection.from === fromNode && connection.to === toNode) ||
              (connection.from === toNode && connection.to === fromNode)) {
            this.removeConnection(id);
            break;
          }
        }
      },
      
      // Remove all connections involving a node
      removeNodeConnections(node) {
        const connectionsToRemove = [];
        for (const [id, connection] of this.connections) {
          if (connection.from === node || connection.to === node) {
            connectionsToRemove.push(id);
          }
        }
        
        connectionsToRemove.forEach(id => this.removeConnection(id));
        console.log(`Removed ${connectionsToRemove.length} connections for node:`, node.id);
      },
      
      // Update all connection positions
      updateAllConnections() {
        for (const connection of this.connections.values()) {
          this.updateConnectionPosition(connection);
        }
      },
      
      // Validate if a connection is valid
      isValidConnection(fromNode, toNode) {
        if (!fromNode || !toNode) return false;
        if (!fromNode.parentNode || !toNode.parentNode) return false;
        if (fromNode === toNode) return false;
        
        // Check if connection already exists
        for (const connection of this.connections.values()) {
          if ((connection.from === fromNode && connection.to === toNode) ||
              (connection.from === toNode && connection.to === fromNode)) {
            return false;
          }
        }
        
        return true;
      },
      
      // Get connections for a specific node
      getNodeConnections(node) {
        const nodeConnections = [];
        for (const connection of this.connections.values()) {
          if (connection.from === node || connection.to === node) {
            nodeConnections.push(connection);
          }
        }
        return nodeConnections;
      },
      
      // Clean up all connections
      cleanup() {
        for (const connection of this.connections.values()) {
          if (connection.line && connection.line.parentNode) {
            connection.line.remove();
          }
        }
        
        for (const insertOrb of this.insertOrbs.values()) {
          if (insertOrb.parentNode) {
            insertOrb.remove();
          }
        }
        
        this.connections.clear();
        this.insertOrbs.clear();
        // Clear SVG paths
        if (this.svg) {
          while (this.svg.firstChild) this.svg.removeChild(this.svg.firstChild);
        }
        console.log('WorkflowManager connections and insert orbs cleaned up');
      }
    };
    
    // Production-grade Action Orb Management System
    const OrbManager = {
      orbs: new Map(), // key -> orb element; keys for regular: `${nodeId}:${position}`, for midpoints: `orb-${from}-${to}`
      
      // Initialize the orb system
      init() {
        this.orbs.clear();
        console.log('[ORB] Manager init');
      },
      
      // Add an orb to a node
      addOrb(node, position = 'bottom') {
        if (!this.isValidNode(node)) {
          console.warn('Invalid node for orb:', node?.id);
          return null;
        }
        
        console.log(`OrbManager.addOrb called for node: ${node.id}, position: ${position}`);
        // Never add a bottom orb under an If node
        try {
          const domElement = node.element || node;
          const stepType = (nodes.find(n => n.element === domElement)?.data?.type) || domElement?.dataset?.stepType || '';
          if (stepType === 'If' && position === 'bottom') {
            console.log('Skipping bottom orb for If node:', node.id);
            return null;
          }
        } catch {}
        
        // Remove existing orb at same position if present
        const key = `${node.id}:${position}`;
        this.removeOrbById(key);
        
        const orb = this.createOrbElement(node.id, position);
        this.orbs.set(key, orb);
        
        // Pass the DOM element to positionOrb (handle both node objects and DOM elements)
        const domElement = node.element || node;
        this.positionOrb(orb, domElement, position);
        container.appendChild(orb);
        
        console.log('Added orb to node:', node.id);
        return orb;
      },
      
      // Add orb at the exact midpoint between two nodes
      addOrbAtMidpoint(fromNode, toNode) {
        if (!this.isValidNode(fromNode) || !this.isValidNode(toNode)) {
          console.warn('OrbManager.addOrbAtMidpoint: Invalid nodes provided');
          return null;
        }
        
        const orbId = `orb-${fromNode.id}-${toNode.id}`;
        console.log(`OrbManager.addOrbAtMidpoint called between: ${fromNode.id} and ${toNode.id}`);
        
        // Remove existing orb if it exists
        this.removeOrbById(orbId);
        
        const orb = this.createOrbElement(orbId, 'midpoint');
        this.orbs.set(orbId, orb);
        
        // Pass the DOM elements to positionOrbAtMidpoint (handle both node objects and DOM elements)
        const fromDomElement = fromNode.element || fromNode;
        const toDomElement = toNode.element || toNode;
        this.positionOrbAtMidpoint(orb, fromDomElement, toDomElement);
        container.appendChild(orb);
        
        return orb;
      },
      
      // Create the orb element
      createOrbElement(nodeId, position) {
        const orb = document.createElement('div');
        orb.className = 'add-action-orb';
        orb.dataset.nodeId = nodeId;
        orb.dataset.position = position;
        orb.style.cssText = `
          position: absolute;
          width: 40px;
          height: 40px;
          background: linear-gradient(135deg, #34D399 0%, #10B981 100%);
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          z-index: 20;
          opacity: 0;
          transform: scale(1);
          transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
          box-shadow: 0 4px 12px rgba(52, 211, 153, 0.3);
          border: 2px solid rgba(255, 255, 255, 0.1);
        `;
        
        orb.innerHTML = `
          <span class="material-icons-outlined" style="color: #1A2E29; font-size: 1.25rem;">add</span>
        `;
        
        // Add click handler
        orb.addEventListener('click', (e) => {
          e.stopPropagation();
          this.handleOrbClick(nodeId, position);
        });
        
        // Add hover effects
        orb.addEventListener('mouseenter', () => {
          if (position === 'midpoint') {
            orb.style.transform = 'translate(-50%, -50%) scale(1.1)';
      } else {
            orb.style.transform = 'scale(1.1)';
          }
          orb.style.boxShadow = '0 6px 20px rgba(52, 211, 153, 0.5)';
        });
        
        orb.addEventListener('mouseleave', () => {
          if (position === 'midpoint') {
            orb.style.transform = 'translate(-50%, -50%) scale(1)';
          } else {
            orb.style.transform = 'scale(1)';
          }
          orb.style.boxShadow = '0 4px 12px rgba(52, 211, 153, 0.3)';
        });
        
        // Animate in
        requestAnimationFrame(() => {
          orb.style.opacity = '1';
          // Only apply translate for midpoint orbs, regular orbs use normal positioning
          if (position === 'midpoint') {
            orb.style.transform = 'translate(-50%, -50%) scale(1)';
          } else {
            orb.style.transform = 'scale(1)';
          }
        });
        
        return orb;
      },
      
      // Position the orb relative to its node with robust positioning
      positionOrb(orb, node, position) {
        if (!orb || !node) {
          console.warn('OrbManager.positionOrb: Missing orb or node');
          return;
        }
        
        try {
          // Get node position relative to container
          const nodeRect = node.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          
          if (!nodeRect || !containerRect) {
            console.warn('OrbManager.positionOrb: Could not get bounding rects');
            return;
          }
          
          // Calculate relative positions
          const nodeLeft = nodeRect.left - containerRect.left;
          const nodeTop = nodeRect.top - containerRect.top;
          const nodeWidth = nodeRect.width;
          const nodeHeight = nodeRect.height;
          
          // Orb dimensions
          const orbSize = 40;
          const orbHalfSize = orbSize / 2;
          
          // Calculate position based on placement
          let left, top;
          
          switch (position) {
            case 'bottom':
              // Center horizontally, place below node with proper spacing
              left = nodeLeft + (nodeWidth / 2) - orbHalfSize;
              top = nodeTop + nodeHeight + 20; // 20px spacing below node
              break;
              
            case 'top':
              // Center horizontally, place above node with proper spacing
              left = nodeLeft + (nodeWidth / 2) - orbHalfSize;
              top = nodeTop - orbSize - 20; // 20px spacing above node
              break;
              
            case 'right':
              // Center vertically, place to the right with proper spacing
              left = nodeLeft + nodeWidth + 20; // 20px spacing to the right
              top = nodeTop + (nodeHeight / 2) - orbHalfSize;
              break;
              
            case 'left':
              // Center vertically, place to the left with proper spacing
              left = nodeLeft - orbSize - 20; // 20px spacing to the left
              top = nodeTop + (nodeHeight / 2) - orbHalfSize;
              break;
              
            default:
              console.warn('OrbManager.positionOrb: Unknown position:', position);
              // Default to bottom
              left = nodeLeft + (nodeWidth / 2) - orbHalfSize;
              top = nodeTop + nodeHeight + 20;
          }
          
          // Ensure orb stays within container bounds (with padding)
          const containerPadding = 20;
          const maxLeft = containerRect.width - orbSize - containerPadding;
          const maxTop = containerRect.height - orbSize - containerPadding;
          
          left = Math.max(containerPadding, Math.min(left, maxLeft));
          top = Math.max(containerPadding, Math.min(top, maxTop));
          
          // Apply positioning
          orb.style.left = `${left}px`;
          orb.style.top = `${top}px`;
          
          // Debug logging
          console.log(`Orb positioned: ${position} at (${left}, ${top}) for node ${node.id}`);
          
        } catch (error) {
          console.error('OrbManager.positionOrb: Error positioning orb:', error);
          // Fallback positioning
          orb.style.left = '50%';
          orb.style.top = '50%';
          orb.style.transform = 'translate(-50%, -50%)';
        }
      },
      
      // Position orb at the exact midpoint of the connection line
      positionOrbAtMidpoint(orb, fromNode, toNode) {
        if (!orb || !fromNode || !toNode) {
          return;
        }
        
        try {
          // Get node positions relative to container (same logic as connection lines)
          const fromRect = fromNode.getBoundingClientRect();
          const toRect = toNode.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          
          if (!fromRect || !toRect || !containerRect) {
            return;
          }
          
          // Calculate connection points (exactly like connection lines)
          // Use Math.round to prevent sub-pixel positioning that can cause shifting
          const fromX = Math.round(fromRect.left - containerRect.left + fromRect.width / 2);
          const fromY = Math.round(fromRect.bottom - containerRect.top - 1);
          const toX = Math.round(toRect.left - containerRect.left + toRect.width / 2);
          const toY = Math.round(toRect.top - containerRect.top + 1);
          
          // Calculate midpoint of the connection line
          const midpointX = (fromX + toX) / 2;
          const midpointY = (fromY + toY) / 2;
          
          // Orb dimensions
          const orbSize = 40;
          const orbHalfSize = orbSize / 2;
          
          // Position orb at midpoint (centered on the connection line)
          // Use the exact midpoint coordinates and center the orb using transform
          // Add small visual offset to account for CSS rendering differences
          const finalLeft = midpointX - 1; // 1px left offset for visual centering
          const finalTop = midpointY;
          
          // Apply positioning - orb will be centered on these coordinates
          orb.style.left = `${finalLeft}px`;
          orb.style.top = `${finalTop}px`;
          orb.style.transform = 'translate(-50%, -50%)';
          
          
        } catch (error) {
          console.error('OrbManager.positionOrbAtMidpoint: Error positioning orb:', error);
          // Fallback positioning
          orb.style.left = '50%';
          orb.style.top = '50%';
          orb.style.transform = 'translate(-50%, -50%)';
        }
      },
      
      // Remove orb by ID
      removeOrbById(orbId) {
        const orb = this.orbs.get(orbId);
        if (orb) {
          orb.remove();
          this.orbs.delete(orbId);
        }
      },
      
      // Remove orb from a node
      removeOrb(node) {
        if (!node || !node.id) return;
        const keys = Array.from(this.orbs.keys()).filter(k => String(k).startsWith(`${node.id}:`));
        keys.forEach(k => {
          const orb = this.orbs.get(k);
          if (orb) {
            orb.style.opacity = '0';
            orb.style.transform = 'scale(0.8)';
            setTimeout(() => { if (orb.parentNode) orb.remove(); }, 300);
          }
          this.orbs.delete(k);
        });
        if (keys.length) console.log('Removed orbs from node:', node.id, keys);
      },
      
      // Remove all orbs
      removeAllOrbs() {
        for (const orb of this.orbs.values()) {
          if (orb.parentNode) {
            orb.remove();
          }
        }
        this.orbs.clear();
        console.log('Removed all orbs');
      },
      
      // Update orb positions for all nodes (handled comprehensively below)
      
      // Handle orb click
      handleOrbClick(nodeId, position) {
        console.log('Orb clicked for node:', nodeId, 'pos:', position);
        // For IF nodes, left orb = true path, right orb = false path
        try {
          const node = nodes.find(n => n.id === nodeId);
          if (node && node.data && node.data.type === 'If' && (position === 'left' || position === 'right')) {
            const prefix = position === 'left' ? 'branch-true-' : 'branch-false-';
            openActionModal(`${prefix}${nodeId}`);
            return;
          }
        } catch {}
        // Default: add after
        openActionModal(`add-after-${nodeId}`);
      },
      
      // Check if node is valid for orb
      isValidNode(node) {
        return node && node.id && (node.element || node.parentNode);
      },
      
      // Get orb for a node
      getOrb(node) {
        if (!node) return null;
        const key = Array.from(this.orbs.keys()).find(k => String(k).startsWith(`${node.id}:`));
        return key ? this.orbs.get(key) : null;
      },
      
      // Check if node has an orb
      hasOrb(node) {
        if (!node) return false;
        return Array.from(this.orbs.keys()).some(k => String(k).startsWith(`${node.id}:`));
      },
      
      // Update all orb positions (handles both regular and midpoint orbs)
      updateAllOrbPositions() {
        console.log('OrbManager: Updating all orb positions...');
        
        this.orbs.forEach((orb, orbId) => {
          const position = orb.dataset.position;
          
          if (position === 'midpoint') {
            // Handle midpoint orbs
            // orbId format: "orb-node-4-node-5"
            const nodeIdPart = orbId.replace('orb-', ''); // "node-4-node-5"
            const parts = nodeIdPart.split('-'); // ["node", "4", "node", "5"]
            
            if (parts.length >= 4) {
              // Reconstruct node IDs: "node-4" and "node-5"
              const fromNodeId = `${parts[0]}-${parts[1]}`;
              const toNodeId = `${parts[2]}-${parts[3]}`;
              const fromNode = document.getElementById(fromNodeId);
              const toNode = document.getElementById(toNodeId);
              
              if (fromNode && toNode) {
                this.positionOrbAtMidpoint(orb, fromNode, toNode);
            } else {
                console.warn(`OrbManager: Could not update midpoint orb ${orbId} - missing nodes: ${fromNodeId}(${!!fromNode}), ${toNodeId}(${!!toNode})`);
              }
            }
          } else {
            // Handle regular orbs
            const nodeId = String(orbId).includes(':') ? String(orbId).split(':')[0] : String(orbId);
            const node = document.getElementById(nodeId);
            if (node && position) {
              this.positionOrb(orb, node, position);
            } else {
              console.warn(`OrbManager: Could not update orb for key ${orbId}`);
            }
          }
        });

      },
      
      // Clean up all orbs
      cleanup() {
        this.removeAllOrbs();
      }
    };
    
    // Workflow Structure Manager - orchestrates connections and orbs
    const StructureManager = {
      rebuildTimeout: null,
      layoutApplied: false,
      
      // Rebuild the entire workflow structure with debouncing
      rebuild(callback = null) {
        // Clear any pending rebuild
        if (this.rebuildTimeout) {
          clearTimeout(this.rebuildTimeout);
        }
        
        // Debounce rebuilds to prevent multiple rapid calls
        this.rebuildTimeout = setTimeout(() => {
          this.performRebuild(callback);
        }, 50);
      },
      
      // Perform the actual rebuild
      performRebuild(callback = null) {
      console.log('[STRUCT] Rebuild start');
        
        // Don't rebuild if there are no nodes
        if (nodes.length === 0) {
        console.log('[STRUCT] Skip: no nodes');
          if (callback) callback();
          return;
        }

        // Apply deterministic layout before wiring connections/orbs
        LayoutManager.apply();

        // If there's only a trigger, just add an orb below it
        if (nodes.length === 1) {
        console.log('[STRUCT] Only trigger node; adding bottom orb');
          
          // Clean up existing orbs first to prevent duplicates
          OrbManager.cleanup();
          
          const triggerNode = nodes[0];
          if (triggerNode && triggerNode.element) {
            OrbManager.addOrb(triggerNode, 'bottom');
          }
          if (callback) callback();
          return;
        }
        
        // Clean up existing structure
        WorkflowManager.cleanup();
        OrbManager.cleanup();
        
        // Sort nodes by vertical position to ensure proper order
        const sortedNodes = [...nodes].sort((a, b) => {
          const aRect = a.element.getBoundingClientRect();
          const bRect = b.element.getBoundingClientRect();
          return aRect.top - bRect.top;
        });
        
      console.log('[STRUCT] Sorted nodes:', sortedNodes.map(n => ({ id: n.id, type: n.type })));
        
        // Rebuild connections honoring If branching with True/False headers
        const isControl = (n) => !!(n && n.data && (n.data.type === 'True' || n.data.type === 'False'));
        const findIfHeaders = (startIdx) => {
          let trueIdx = -1, falseIdx = -1;
          for (let j = startIdx + 1; j < sortedNodes.length; j++) {
            const t = sortedNodes[j]?.data?.type;
            if (t === 'If') break; // stop at next IF block
            if (t === 'True' && trueIdx === -1) trueIdx = j;
            if (t === 'False' && falseIdx === -1) falseIdx = j;
            if (trueIdx !== -1 && falseIdx !== -1) break;
          }
          return { trueIdx, falseIdx };
        };

        const visited = new Set();
        for (let i = 0; i < sortedNodes.length; i++) {
          if (visited.has(i)) continue;
          const node = sortedNodes[i];
          const type = node?.data?.type || '';
          // Handle If block with two branches
          if (type === 'If') {
            const { trueIdx, falseIdx } = findIfHeaders(i);
            // Connect If -> True/False headers when present
            if (trueIdx !== -1) WorkflowManager.createConnection(node.element, sortedNodes[trueIdx].element, false);
            if (falseIdx !== -1) WorkflowManager.createConnection(node.element, sortedNodes[falseIdx].element, false);

            // Chain within branches: find actions tagged with this IF
            const ifId = node.data?.properties?.ifId;
            if (ifId) {
              const trueBranch = [];
              const falseBranch = [];
              for (let j = i + 1; j < sortedNodes.length; j++) {
                const d = sortedNodes[j]?.data;
                if (!d) continue;
                if (d.type === 'If') break; // stop at next IF
                if (d.type === 'True' || d.type === 'False') continue;
                if (d.properties && d.properties.parentIfId === ifId) {
                  if (d.properties.branch === 'true') trueBranch.push(j);
                  if (d.properties.branch === 'false') falseBranch.push(j);
                }
              }
              // Connect headers to first branch node
              if (trueIdx !== -1 && trueBranch.length > 0) WorkflowManager.createConnection(sortedNodes[trueIdx].element, sortedNodes[trueBranch[0]].element, false);
              if (falseIdx !== -1 && falseBranch.length > 0) WorkflowManager.createConnection(sortedNodes[falseIdx].element, sortedNodes[falseBranch[0]].element, false);
              // Chain within
              for (let k = 0; k < trueBranch.length - 1; k++) WorkflowManager.createConnection(sortedNodes[trueBranch[k]].element, sortedNodes[trueBranch[k + 1]].element, false);
              for (let k = 0; k < falseBranch.length - 1; k++) WorkflowManager.createConnection(sortedNodes[falseBranch[k]].element, sortedNodes[falseBranch[k + 1]].element, false);

              // If a join node exists for this IF, connect last branch nodes to the join node
              try {
                const joinNodes = sortedNodes.filter(n => n && n.data && n.data.properties && n.data.properties.joinForIfId === ifId);
                if (joinNodes.length > 0) {
                  const lastTrueEl = (trueBranch.length > 0)
                    ? sortedNodes[trueBranch[trueBranch.length - 1]].element
                    : (trueIdx !== -1 ? sortedNodes[trueIdx].element : null);
                  const lastFalseEl = (falseBranch.length > 0)
                    ? sortedNodes[falseBranch[falseBranch.length - 1]].element
                    : (falseIdx !== -1 ? sortedNodes[falseIdx].element : null);
                  joinNodes.forEach(jn => {
                    if (lastTrueEl) WorkflowManager.createConnection(lastTrueEl, jn.element, false);
                    if (lastFalseEl) WorkflowManager.createConnection(lastFalseEl, jn.element, false);
                  });
                }
              } catch {}
            }
            continue;
          }

          // Skip branch headers here (handled by If)
          if (type === 'True' || type === 'False') continue;

          // Do not add default linear connections for nodes inside an IF branch;
          // branch chaining is handled when processing the IF block above
          try {
            const meta = node.data?.properties;
            if (meta && meta.parentIfId) continue;
          } catch {}

          // Default linear connection to the next non-control node, with IF-join handling
          let nextIdx = i + 1;
          while (nextIdx < sortedNodes.length && (sortedNodes[nextIdx].data?.type === 'True' || sortedNodes[nextIdx].data?.type === 'False')) {
            nextIdx++;
          }
          if (nextIdx < sortedNodes.length) {
            // If next node is a join for a previous IF, connect the last of each branch to it
            const nextNode = sortedNodes[nextIdx];
            const joinForIfId = nextNode?.data?.properties?.joinForIfId;
            if (joinForIfId) {
              // Find last true/false nodes for that IF
              let lastTrueEl = null;
              let lastFalseEl = null;
              for (let j = 0; j < sortedNodes.length; j++) {
                const d = sortedNodes[j]?.data;
                if (!d || d.type === 'If' || d.type === 'True' || d.type === 'False') continue;
                if (d.properties && d.properties.parentIfId === joinForIfId) {
                  if (d.properties.branch === 'true') lastTrueEl = sortedNodes[j].element;
                  if (d.properties.branch === 'false') lastFalseEl = sortedNodes[j].element;
                }
              }
              if (lastTrueEl) WorkflowManager.createConnection(lastTrueEl, nextNode.element, false);
              if (lastFalseEl) WorkflowManager.createConnection(lastFalseEl, nextNode.element, false);
            } else {
              WorkflowManager.createConnection(node.element, nextNode.element, false);
            }
          }
        }
        
        // Add orbs at connection midpoints and synthetic branch-join orbs
        try { WorkflowManager.addInsertOrbsForConnections(); } catch {}
        try { WorkflowManager.addBranchJoinOrbs(); } catch {}

        // Add orbs after the last node
        for (let i = 0; i < sortedNodes.length; i++) {
          const node = sortedNodes[i];
          const isLastNode = i === sortedNodes.length - 1;
          
          console.log('[STRUCT] Node:', { index: i, id: node.id, type: node.type, isLast: isLastNode });

          // Add orbs per-branch: IF nodes have no orbs; for True/False, place at last action in branch if present, otherwise on the header
          if (node.data && node.data.type === 'If') {
            // No orbs on the IF node itself
          }
          if (node.data && (node.data.type === 'True' || node.data.type === 'False')) {
            try {
              const header = node;
              const branch = node.data.type === 'True' ? 'true' : 'false';
              const parentIfId = node.data?.properties?.parentIfId;
              if (parentIfId) {
                // If a join node exists for this IF, do not add any bottom orbs for branch headers or last branch nodes
                const hasJoin = sortedNodes.some(n => n.data && n.data.properties && n.data.properties.joinForIfId === parentIfId);
                if (hasJoin) {
                  try { OrbManager.removeOrbById(`${header.element.id}:bottom`); } catch {}
                  // Skip adding orbs for this branch entirely
                } else {
                // Find all actions in this branch
                const branchNodes = sortedNodes.filter(n => {
                  const dt = n.data?.type;
                  const props = n.data?.properties;
                  return dt && dt !== 'If' && dt !== 'True' && dt !== 'False' && props && props.parentIfId === parentIfId && props.branch === branch;
                });
                if (branchNodes.length > 0) {
                  // Ensure header has no bottom orb
                  try { OrbManager.removeOrbById(`${header.element.id}:bottom`); } catch {}
                  // Add orb under the last node in this branch
                  const lastBranchNode = branchNodes[branchNodes.length - 1];
                  OrbManager.addOrb(lastBranchNode.element, 'bottom');
                } else {
                  // No actions yet: add orb under the header
                  OrbManager.addOrb(header.element, 'bottom');
                }
              }
              } else {
                // Fallback: if header lacks context, show orb under header
                OrbManager.addOrb(node.element, 'bottom');
              }
            } catch {
              // Fallback on error
              OrbManager.addOrb(node.element, 'bottom');
            }
          }
          
          if (!isLastNode) {
            // handled above using connections
        } else {
            // Add orb below the last node
            console.log('[STRUCT] Add bottom orb under:', node.id);
            // Never add a bottom orb under an If node
            if (node && node.data && node.data.type === 'If') {
              continue;
            }
            const stepType = (node.data && node.data.type) || node.element?.dataset?.stepType || '';
            if (!(stepType === 'If' || stepType === 'True' || stepType === 'False')) {
              OrbManager.addOrb(node.element, 'bottom');
            }
          }
        }

        // No cleanup: orbs are created deterministically and exclusively by the rules above
        
        // Update all orb positions to ensure proper alignment
        OrbManager.updateAllOrbPositions();
        
        // Final alignment pass to ensure no initial jitter
        try {
          LayoutManager.apply();
          WorkflowManager.updateAllConnections();
          OrbManager.updateAllOrbPositions();
        } catch (e) {
          console.warn('Post-rebuild alignment warning:', e);
        }
        
      console.log('[STRUCT] Rebuilt -> connections:', WorkflowManager.connections.size, 'orbs:', OrbManager.orbs.size);
        
        // Call callback if provided
        if (callback) {
          callback();
        }
      },
      
      // Initialize the structure
      init() {
        WorkflowManager.init();
        OrbManager.init();
        console.log('StructureManager initialized');
      },
      
      // Clean up everything
      cleanup() {
        // Clear any pending rebuild
        if (this.rebuildTimeout) {
          clearTimeout(this.rebuildTimeout);
          this.rebuildTimeout = null;
        }
        
        WorkflowManager.cleanup();
        OrbManager.cleanup();
        console.log('StructureManager cleaned up');
      }
    };

    // Deterministic layout manager for nodes (centers X and enforces vertical spacing)
    const LayoutManager = {
      apply() {
        try {
          if (!container) return;
          const containerRect = container.getBoundingClientRect();
          if (!containerRect) return;

          // Place trigger node (keep its configured top, center X)
          const trigger = nodes.find(n => n.type === 'trigger');
          if (!trigger || !trigger.element) return;

          const triggerEl = trigger.element;
          triggerEl.style.left = '50%';
          triggerEl.style.transform = 'translateX(-50%)';

          // Read trigger rect after possible CSS/layout changes
          const trigRect = triggerEl.getBoundingClientRect();

          // Position action nodes with support for horizontal If branching
          const actions = nodes.filter(n => n.type !== 'trigger');
          let currentTop = Math.round(trigRect.bottom - containerRect.top + VERTICAL_SPACING);

          const CONTROL_TYPES = new Set(['True', 'False']);
          const idxOf = (el) => nodes.findIndex(n => n.element === el);
          const getHeight = (el) => {
            const r = el.getBoundingClientRect();
            return Math.max(1, Math.round(r.height));
          };

          // Helper: determine if a global index lies within any IF block
          const inIfBlock = (gIndex) => {
            const d = nodes[gIndex]?.data;
            if (!d) return false;
            if (d.type === 'True' || d.type === 'False') return true;
            if (d.properties && d.properties.parentIfId) return true;
            return false;
          };

          for (let i = 0; i < actions.length; i++) {
            const n = actions[i];
            const el = n.element;
            if (!el) continue;
            const t = n.data?.type || '';

            if (t === 'If') {
              // Nest-aware IF placement: center under enclosing branch path if any
              const props = n.data?.properties || {};
              const baseCenter = Math.round(containerRect.width / 2);
              const NEST_STEP = 220; // widening per nest level
              // Compute nesting depth by walking parentIfId chain
              let depth = 0;
              let pid = props.parentIfId || null;
              while (pid) {
                const anc = nodes.find(x => x?.data?.type === 'If' && x?.data?.properties?.ifId === pid);
                if (!anc) break;
                depth += 1;
                pid = anc?.data?.properties?.parentIfId || null;
              }
              let center = baseCenter;
              if (props.parentIfId && props.branch) {
                const dir = props.branch === 'true' ? -1 : +1; // left for true, right for false
                center = baseCenter + (dir * (NEST_STEP * depth));
              }
              el.style.left = `${center}px`;
              el.style.transform = 'translateX(-50%)';
              el.style.top = `${currentTop}px`;
              const ifHeight = getHeight(el);
              const startY = currentTop + ifHeight + 80; // lower branch headers a bit

              // Locate True/False headers for this IF
              const globalIfIdx = idxOf(el);
              let trueIdx = -1, falseIdx = -1;
              for (let j = globalIfIdx + 1; j < nodes.length; j++) {
                const jt = nodes[j]?.data?.type;
                if (jt === 'If') break;
                if (jt === 'True' && trueIdx === -1) trueIdx = j;
                if (jt === 'False' && falseIdx === -1) falseIdx = j;
                if (trueIdx !== -1 && falseIdx !== -1) break;
              }

              // Layout branches: left column for TRUE, right column for FALSE
              let yTrue = startY;
              let yFalse = startY;
              const COLUMN_OFFSET = 280; // px from center
              // Branch columns relative to this IF's center
              const centerX = center;
              const place = (node, side, y) => {
                const e = node.element;
                const cx = side === 'left' ? (centerX - COLUMN_OFFSET) : (centerX + COLUMN_OFFSET);
                e.style.left = `${cx}px`;
                e.style.transform = 'translateX(-50%)';
                e.style.top = `${y}px`;
                return y + getHeight(e) + VERTICAL_SPACING;
              };
              // Place headers if present
              if (trueIdx !== -1) yTrue = place(nodes[trueIdx], 'left', yTrue);
              if (falseIdx !== -1) yFalse = place(nodes[falseIdx], 'right', yFalse);

              // Place branch actions by matching parentIfId
              const ifId = nodes[globalIfIdx]?.data?.properties?.ifId;
              if (ifId) {
                for (let j = globalIfIdx + 1; j < nodes.length; j++) {
                  const d = nodes[j]?.data;
                  if (!d) continue;
                  if (d.type === 'If') break; // next block
                  if (d.type === 'True' || d.type === 'False') continue;
                  if (d.properties && d.properties.parentIfId === ifId) {
                    if (d.properties.branch === 'true') {
                      yTrue = place(nodes[j], 'left', yTrue);
                    } else if (d.properties.branch === 'false') {
                      yFalse = place(nodes[j], 'right', yFalse);
                    }
                  }
                }
              }

              // Advance currentTop to below the deeper branch end
              currentTop = Math.max(yTrue, yFalse) + 20;
              
              continue;
            }

            // Non-IF nodes: if already inside an IF block, don't override branch placement
            const gIdx = idxOf(el);
            if (inIfBlock(gIdx)) {
              // Move currentTop down to not overlap whatever was positioned by branches
              currentTop = Math.max(currentTop, Math.round(el.getBoundingClientRect().bottom - containerRect.top) + VERTICAL_SPACING);
            } else {
              // Centered linear placement
              el.style.left = '50%';
              el.style.transform = 'translateX(-50%)';
              el.style.top = `${currentTop}px`;
              currentTop += getHeight(el) + VERTICAL_SPACING;
            }
          }
        } catch (e) {
          console.warn('LayoutManager.apply error:', e);
        }
      }
    };

    
    
    // Notification function
    function showNotification(message, type = 'success', durationMs = 5000) {
      const notification = document.createElement('div');
      notification.className = `fixed right-4 z-50 p-4 rounded-lg shadow-lg transition-all duration-300 transform translate-x-full`;
      notification.style.background = type === 'success' ? '#34D399' : '#EF4444';
      notification.style.color = '#ffffff';
      notification.style.minWidth = '300px';
      // Position below toolbar to avoid overlap
      try {
        const bar = document.querySelector('.toolbar');
        const topOffset = bar ? (bar.getBoundingClientRect().bottom + 12) : 16;
        notification.style.top = `${Math.max(0, Math.round(topOffset))}px`;
      } catch { notification.style.top = '16px'; }

      notification.innerHTML = `
        <div class="flex items-center justify-between">
          <span>${message}</span>
          <button class="button ml-4 text-white hover:text-gray-200"><span class="material-icons-outlined">close</span></button>
        </div>
      `;
      notification.querySelector('button')?.addEventListener('click', () => {
        notification.style.transform = 'translateX(100%)';
        setTimeout(() => { if (notification.parentElement) notification.remove(); }, 300);
      });
      document.body.appendChild(notification);
      requestAnimationFrame(() => { notification.style.transform = 'translateX(0)'; });
      if (durationMs && durationMs > 0) {
        setTimeout(() => {
          notification.style.transform = 'translateX(100%)';
          setTimeout(() => { if (notification.parentElement) notification.remove(); }, 300);
        }, durationMs);
      }
    }

    // DOM elements
    const canvas = document.getElementById('flowchart-canvas');
    const container = document.getElementById('flowchart-container');
    const workflowNameInput = document.getElementById('workflow-name');
    const saveBtn = document.getElementById('save-workflow');
    const triggerModal = document.getElementById('trigger-modal');
    const actionModal = document.getElementById('action-modal');
    const contextModal = document.getElementById('context-modal');
    const errorsDrawer = document.getElementById('errors-drawer');
    const errorsList = document.getElementById('errors-list');
    const runsDrawer = document.getElementById('runs-drawer');
    const runsActive = document.getElementById('runs-active');
    const runsHistory = document.getElementById('runs-history');
    const runDetails = document.getElementById('run-details');

    

    function initializeCanvas() {
      // Canvas dragging functionality
      canvas.addEventListener('mousedown', (e) => {
        if (e.target === canvas || e.target === container) {
          // Ensure structure is fully aligned before first pan to avoid any jump
          if (!didFirstPanRefresh) {
            refreshStructure();
            didFirstPanRefresh = true;
          }
          isDragging = true;
          dragStart = { x: e.clientX, y: e.clientY };
          canvas.style.cursor = 'grabbing';
        }
      });

      canvas.addEventListener('mousemove', (e) => {
        if (isDragging) {
          const deltaX = e.clientX - dragStart.x;
          const deltaY = e.clientY - dragStart.y;
          
          canvasOffset.x += deltaX;
          canvasOffset.y += deltaY;
          
          container.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px)`;
          
          dragStart = { x: e.clientX, y: e.clientY };
        }
      });

      canvas.addEventListener('mouseup', () => {
        isDragging = false;
        canvas.style.cursor = 'grab';
      });

      canvas.addEventListener('mouseleave', () => {
        isDragging = false;
        canvas.style.cursor = 'grab';
      });

      // Save button event
              // saveBtn.addEventListener('click', saveWorkflow); // Removed duplicate - onclick already handles this
    }

    // Themed confirm / prompt helpers
    function themedConfirm(message, title = 'Confirm') {
      return new Promise((resolve) => {
        const modal = document.getElementById('confirm-modal');
        document.getElementById('confirm-title').textContent = title;
        document.getElementById('confirm-message').textContent = message;
        const ok = document.getElementById('confirm-ok');
        const cancel = document.getElementById('confirm-cancel');
        const close = () => { modal.classList.add('hidden'); ok.onclick = cancel.onclick = null; };
        ok.onclick = () => { resolve(true); close(); };
        cancel.onclick = () => { resolve(false); close(); };
        modal.classList.remove('hidden');
      });
    }

    function themedPrompt(initial = '', title = 'Rename', label = 'New name') {
      return new Promise((resolve) => {
        const modal = document.getElementById('prompt-modal');
        document.getElementById('prompt-title').textContent = title;
        document.getElementById('prompt-label').textContent = label;
        const input = document.getElementById('prompt-input');
        input.value = initial || '';
        const ok = document.getElementById('prompt-ok');
        const cancel = document.getElementById('prompt-cancel');
        const close = () => { modal.classList.add('hidden'); ok.onclick = cancel.onclick = null; };
        ok.onclick = () => { resolve(input.value.trim()); close(); };
        cancel.onclick = () => { resolve(null); close(); };
        modal.classList.remove('hidden');
        setTimeout(() => { try { input.focus(); input.select(); } catch {} }, 50);
      });
    }

    // Force-align nodes, connections and orbs based on current DOM metrics
    function refreshStructure() {
      try {
        LayoutManager.apply();
        WorkflowManager.updateAllConnections();
        OrbManager.updateAllOrbPositions();
      } catch (e) {
        console.warn('refreshStructure error:', e);
      }
    }

    async function loadWorkflow() {
      const id = localStorage.getItem('calendarify-current-workflow');
      if (id) {
        try {
          const token = getAnyToken();
          if (!token) return;
          
          const clean = token.replace(/^"|"$/g, '');
          const res = await fetch(`${API_URL}/workflows/${id}`, { 
            headers: { Authorization: `Bearer ${clean}` } 
          });
          
          if (res.ok) {
            currentWorkflow = await res.json();
        console.log('[WF] Loaded workflow meta:', { id: currentWorkflow?.id, name: currentWorkflow?.name });
            
            const workflowData = currentWorkflow.data || currentWorkflow;
            console.log('[WF] Data payload keys:', Object.keys(workflowData || {}));
            
            if (workflowData.name || currentWorkflow.name) {
              const name = workflowData.name || currentWorkflow.name;
              workflowNameInput.value = name;
              console.log('[WF] Set name:', name);
            }
            
            // Load existing nodes and connections
            if (workflowData.steps && Array.isArray(workflowData.steps)) {
              console.log('[WF] Steps count:', Array.isArray(workflowData.steps) ? workflowData.steps.length : 0);
              
              // Clear existing nodes first - more thorough cleanup
              nodes.forEach(node => {
                if (node.element) {
                  node.element.remove();
                }
              });
              nodes = [];
              
              // Clear all orbs
              const existingOrbs = container.querySelectorAll('.add-action-orb, .insert-action-orb');
              existingOrbs.forEach(orb => orb.remove());
              
              // Clear all connection lines
              const existingLines = container.querySelectorAll('.connection-line');
              existingLines.forEach(line => line.remove());
              
              // Set loading guard to avoid auto-generating branch headers during load pass
              isLoadingWorkflow = true;
              currentLoadSteps = workflowData.steps;

              // Check if we have trigger data at the top level (for existing workflows)
              if (workflowData.trigger) {
                console.log('[WF] Trigger (top-level):', workflowData.trigger);
                const triggerData = {
                  type: workflowData.trigger,
                  properties: {
                    eventTypes: workflowData.triggerEventTypes || [],
                    tags: workflowData.triggerTags || []
                  }
                };
                updateTriggerNode(triggerData);
                
                // Remove guide text when loading existing workflow with configured trigger
                const helpText = container.querySelector('div[style*="Configure your trigger above"]');
                if (helpText) {
                  helpText.remove();
        } else {
                  // Try alternative selectors
                  const allDivs = container.querySelectorAll('div');
                  allDivs.forEach((div) => {
                    if (div.innerHTML && div.innerHTML.includes('Configure your trigger above')) {
                      div.remove();
                    }
                  });
                }
                
                // Also remove the CSS pseudo-element guide text by updating the trigger node
                const triggerNode = container.querySelector('.flowchart-node.trigger');
                if (triggerNode) {
                  triggerNode.classList.add('configured');
                }
                
                // Restore selected tags/event types for editing
                if (workflowData.trigger === 'Tag Added' && workflowData.triggerTags) {
                  window.selectedTags = [...workflowData.triggerTags];
                }
                if (workflowData.trigger === 'Meeting Scheduled') {
                  if (workflowData.triggerEventTypes) window.selectedEventTypes = [...workflowData.triggerEventTypes];
                  if (workflowData.triggerEventTypeIds) window.selectedEventTypeIds = [...workflowData.triggerEventTypeIds];
                }
        } else {
                // Try to find trigger in steps (for new format)
                const triggerStep = workflowData.steps.find(step => step.type === 'trigger');
                
                if (triggerStep) {
                  updateTriggerNode(triggerStep);
                  
                  // Restore selected tags/event types for editing
                  if (triggerStep.type === 'Tag Added' && triggerStep.properties?.tags) {
                    window.selectedTags = [...triggerStep.properties.tags];
                    console.log('Restored selected tags:', window.selectedTags);
                  }
                  if (triggerStep.type === 'Meeting Scheduled' && triggerStep.properties?.eventTypes) {
                    window.selectedEventTypes = [...triggerStep.properties.eventTypes];
                    if (triggerStep.properties?.eventTypeIds) window.selectedEventTypeIds = [...triggerStep.properties.eventTypeIds];
                  console.log('[WF] Restored event types length:', (window.selectedEventTypes||[]).length);
                  }
                }
              }

              // Load actions (skip trigger since it's already loaded)
              workflowData.steps.forEach((step, index) => {
                if (step.type !== 'trigger') {
                  const clean = { ...step };
                  // Ensure join nodes don't trigger IF auto-branching or unwanted UI
                  if (clean.properties && clean.properties.joinForIfId) {
                    // Explicitly clear branch markers on load; wiring will use joinForIfId only
                    delete clean.properties.branch;
                    delete clean.properties.parentIfId;
                  }
                  console.log('[WF] Load step:', clean?.type);
                  addActionNode(clean, index);
                } else {
                  console.log('Skipping trigger step in actions loop:', step);
                }
              });
              
              // Load context spec if available, otherwise apply default
              if (workflowData.contextSpec) {
                contextSpec = workflowData.contextSpec;
              } else {
                contextSpec = getDefaultContextSpec();
              }

              // Rebuild the workflow structure after loading all nodes
              setTimeout(() => {
                // End loading guard before rebuild so layout and orbs apply deterministically
                isLoadingWorkflow = false;
                currentLoadSteps = null;
                StructureManager.rebuild(() => {
                  // Hide loading screen after orbs are loaded and positioned
                  hideLoadingScreen();
                });
              }, 100);
              }
            }
          } catch (error) {
          console.error('[WF] Error loading workflow:', error);
        }
      }
    }

    function createInitialTriggerNode() {
      const triggerNode = createNode('trigger', 'Click to configure trigger', 'play_circle', 'Click to configure trigger');
      triggerNode.style.left = '50%';
      triggerNode.style.top = '50px';
      triggerNode.style.transform = 'translateX(-50%)';
      
      // Override the click handler for the trigger node specifically
      triggerNode.removeEventListener('click', (e) => selectNode(triggerNode));
      triggerNode.addEventListener('click', (e) => {
        e.stopPropagation();
        openTriggerModal();
      });
      
      container.appendChild(triggerNode);
      nodes.push({ id: triggerNode.id, type: 'trigger', element: triggerNode });
      
      // Rebuild to add the orb below the trigger and hide loading screen
      StructureManager.rebuild(() => {
        hideLoadingScreen();
      });
      
      // Add movement listeners
      addNodeMovementListeners();
      
      // Add helpful text
      const helpText = document.createElement('div');
      helpText.style.position = 'absolute';
      helpText.style.left = '50%';
      helpText.style.top = '200px';
      helpText.style.transform = 'translateX(-50%)';
                  helpText.style.color = '#9ca3af';
      helpText.style.fontSize = '0.875rem';
      helpText.style.textAlign = 'center';
      helpText.innerHTML = 'Configure your trigger above, then add actions below to build your workflow';
      container.appendChild(helpText);
    }

    function createNode(type, title, icon, content) {
      const node = document.createElement('div');
      node.className = `flowchart-node ${type}`;
      node.id = `node-${++currentNodeId}`;
      node.dataset.stepType = type;
      // Consistent horizontal centering for all nodes
      node.style.left = '50%';
      node.style.transform = 'translateX(-50%)';
      
      if (type !== 'trigger') {
        node.innerHTML = `
          <div class="node-header">
            <span class="material-icons-outlined node-icon">${icon}</span>
            <div class="node-title">${title}</div>
            ${(['True','False'].includes(type)) ? '' : `
            <div class="node-actions">
              <button class="node-action-btn edit-btn" title="Edit Action">
                <span class="material-icons-outlined">edit</span>
              </button>
              <button class="node-action-btn delete-btn" title="Delete Action">
                <span class="material-icons-outlined">delete</span>
              </button>
            </div>`}
          </div>
          <div class="node-content">${content}</div>
        `;
        
        // Add edit and delete handlers unless True/False header
        if (!(['True','False'].includes(type))) {
          const editBtn = node.querySelector('.edit-btn');
          const deleteBtn = node.querySelector('.delete-btn');
          if (editBtn) editBtn.addEventListener('click', (e) => { e.stopPropagation(); editAction(node); });
          if (deleteBtn) deleteBtn.addEventListener('click', (e) => { e.stopPropagation(); deleteAction(node); });
        }
      } else {
        node.innerHTML = `
          <div class="node-header">
            <span class="material-icons-outlined node-icon">${icon}</span>
            <div class="node-title">${title}</div>
          </div>
          <div class="node-content">${content}</div>
        `;
      }
      
      // Add click handler for selection
      node.addEventListener('click', (e) => {
        e.stopPropagation();
        selectNode(node);
      });
      
      return node;
    }
    
    function selectNode(node) {
      // Deselect previously selected node
      if (selectedNode) {
        selectedNode.classList.remove('selected');
      }
      
      // Select new node
      selectedNode = node;
      node.classList.add('selected');
    }
    
    // Deselect when clicking on canvas
    container.addEventListener('click', (e) => {
      if (e.target === container) {
        if (selectedNode) {
          selectedNode.classList.remove('selected');
          selectedNode = null;
              }
            }
          });


    function openTriggerModal() {
      triggerModal.classList.remove('hidden');
      
      // Check if we're editing an existing trigger
      const triggerNode = nodes.find(n => n.type === 'trigger');
      if (triggerNode && triggerNode.data) {
        // Pre-populate the trigger type
        const triggerSelect = document.getElementById('trigger-select');
        if (triggerSelect) {
          triggerSelect.value = triggerNode.data.type;
        }
        
        // Restore selected tags if it's a Tag Added trigger
        if (triggerNode.data.type === 'Tag Added' && triggerNode.data.properties?.tags) {
          window.selectedTags = [...triggerNode.data.properties.tags];
        }
        
        // Restore selected event types if it's a Meeting Scheduled trigger
        if (triggerNode.data.type === 'Meeting Scheduled' && triggerNode.data.properties?.eventTypes) {
          window.selectedEventTypes = [...triggerNode.data.properties.eventTypes];
        }
      } else {
        // Reset for new trigger
        window.selectedTags = [];
      }
      
      renderTriggerProperties();
    }

    function closeTriggerModal() {
      triggerModal.classList.add('hidden');
    }

    function openActionModal(parentNodeId) {
      actionModal.classList.remove('hidden');
      selectedNode = parentNodeId;
      
      // Check if this is an insert operation
      if (parentNodeId === 'insert') {
        const modalTitle = actionModal.querySelector('.modal-title');
        if (modalTitle) {
          modalTitle.textContent = 'Insert Action';
        }
        
        const actionSaveBtn = document.getElementById('action-save-btn');
        if (actionSaveBtn) {
          actionSaveBtn.textContent = 'Insert Action';
        }
      }
      
      // Check if this is an "add after" operation
      if (parentNodeId && parentNodeId.startsWith('add-after-')) {
        const modalTitle = actionModal.querySelector('.modal-title');
        if (modalTitle) {
          modalTitle.textContent = 'Add Action';
        }
        
        const actionSaveBtn = document.getElementById('action-save-btn');
        if (actionSaveBtn) {
          actionSaveBtn.textContent = 'Add Action';
        }
      }
      
      // Check if we're editing an existing action
      const existingNode = nodes.find(n => n.id === parentNodeId);
    if (existingNode && existingNode.type !== 'trigger') {
        // Set the modal title to indicate editing
        const modalTitle = actionModal.querySelector('.modal-title');
        if (modalTitle) {
          modalTitle.textContent = 'Edit Action';
        }
        
        // Update button text
        const actionSaveBtn = document.getElementById('action-save-btn');
        if (actionSaveBtn) {
          actionSaveBtn.textContent = 'Update Action';
        }
        
        // Pre-populate the action type
        const actionSelect = document.getElementById('action-select');
        if (actionSelect) {
          actionSelect.value = existingNode.data.type;
        }
      } else {
        // Reset modal title for new actions
        const modalTitle = actionModal.querySelector('.modal-title');
        if (modalTitle) {
          modalTitle.textContent = 'Add Action';
        }
        
        // Reset button text
        const actionSaveBtn = document.getElementById('action-save-btn');
        if (actionSaveBtn) {
          actionSaveBtn.textContent = 'Add Action';
        }
      }
      
      // Reset selected action tag
      window.selectedActionTag = '';
      renderActionProperties();
    }

    function closeActionModal() {
      actionModal.classList.add('hidden');
      selectedNode = null;
      
      // Reset insert state
      window.insertConnection = null;
      
      // Reset modal title
      const modalTitle = actionModal.querySelector('.modal-title');
      if (modalTitle) {
        modalTitle.textContent = 'Add Action';
      }
      
      // Reset button text
      const actionSaveBtn = document.getElementById('action-save-btn');
      if (actionSaveBtn) {
        actionSaveBtn.textContent = 'Add Action';
      }
    }

    // Context modal handlers
    function openContextModal() {
      try {
        if (!contextSpec) contextSpec = getDefaultContextSpec();
        document.getElementById('context-attach-full').checked = !!contextSpec.attachFullContext;
        const schemaEl = document.getElementById('context-schema');
        schemaEl.textContent = JSON.stringify(contextSpec.schema || getDefaultContextSchema(), null, 2);
        const sampleEl = document.getElementById('context-sample');
        sampleEl.value = contextSpec.sample ? JSON.stringify(contextSpec.sample, null, 2) : '';
      } catch (e) {
        console.warn('Error opening context modal:', e);
      }
      contextModal.classList.remove('hidden');
    }

    function closeContextModal() {
      contextModal.classList.add('hidden');
    }

    function saveContextSpec() {
      const attachFull = document.getElementById('context-attach-full').checked;
      const sampleText = document.getElementById('context-sample').value.trim();
      let sample = null;
      if (sampleText) {
        try {
          sample = JSON.parse(sampleText);
        } catch (e) {
          showNotification('Invalid JSON in sample payload', 'error');
          return;
        }
      }
      contextSpec = {
        ...(contextSpec || {}),
        version: 1,
        attachFullContext: attachFull,
        scope: attachFull ? 'full' : (contextSpec?.scope || 'full'),
        schema: contextSpec?.schema || getDefaultContextSchema(),
        sample: sample || null
      };
      closeContextModal();
      showNotification('Context settings saved');
    }

    async function copyContextSchema() {
      try {
        const schema = (contextSpec && contextSpec.schema) ? contextSpec.schema : getDefaultContextSchema();
        await navigator.clipboard.writeText(JSON.stringify(schema, null, 2));
        const s = document.getElementById('context-schema-copy-status');
        if (s) {
          s.textContent = 'Copied';
          setTimeout(() => { s.textContent = ''; }, 1500);
        }
      } catch (e) {
        console.warn('Copy schema failed:', e);
        showNotification('Failed to copy schema', 'error');
      }
    }

    function renderTriggerProperties() {
      const container = document.getElementById('trigger-properties');
      const triggerType = document.getElementById('trigger-select').value;
      
      let html = '';
      
      if (triggerType === 'Meeting Scheduled') {
        html = `
          <div class="form-group">
            <label class="form-label">Event Types</label>
            <div class="multi-select">
              <button type="button" class="multi-select-button" onclick="toggleMultiSelect('event-type')">
                <span>Select event types...</span>
                <span class="material-icons-outlined">expand_more</span>
                    </button>
              <div class="multi-select-options" id="event-type-options">
                <!-- Event types will be populated here -->
                  </div>
              <button type="button" class="select-all-btn" onclick="selectAllEventTypes()">Select All</button>
                  </div>
                </div>
        `;
      } else if (triggerType === 'Tag Added') {
        html = `
          <div class="form-group">
            <label class="form-label">Tags</label>
            <div class="multi-select">
              <button type="button" class="multi-select-button" onclick="toggleMultiSelect('tag')">
                <span id="tag-display">Select tags...</span>
                <span class="material-icons-outlined">expand_more</span>
              </button>
              <div class="multi-select-options" id="tag-options">
                <!-- Tags will be populated here -->
                  </div>
              <button type="button" class="select-all-btn" onclick="selectAllTags()">Select All</button>
                </div>
            <div class="mt-3" id="tag-confirm" style="display: none;">
              <button type="button" class="btn-primary w-full" onclick="confirmTagSelection()">
                Confirm Tag Selection
              </button>
              </div>
            </div>
        `;
      }
      
      container.innerHTML = html;
      
      // Reset selected tags when changing trigger type
      if (triggerType === 'Tag Added') {
        window.selectedTags = [];
        // Hide confirm button initially
        setTimeout(() => {
          const confirmBtn = document.getElementById('tag-confirm');
          if (confirmBtn) {
            confirmBtn.style.display = 'none';
          }
        }, 100);
      }
      
      // Populate options
      if (triggerType === 'Meeting Scheduled') {
        populateEventTypes();
      } else if (triggerType === 'Tag Added') {
        populateTags();
      }
      
      // Reset selected arrays when changing trigger type
      if (triggerType === 'Tag Added') {
        // Don't reset if we're editing and have existing tags
        if (!window.selectedTags || window.selectedTags.length === 0) {
          window.selectedTags = [];
        }
        window.selectedEventTypes = [];
      } else if (triggerType === 'Meeting Scheduled') {
        // Don't reset if we're editing and have existing event types
        if (!window.selectedEventTypes || window.selectedEventTypes.length === 0) {
          window.selectedEventTypes = [];
        }
        window.selectedTags = [];
      } else {
        window.selectedTags = [];
        window.selectedEventTypes = [];
      }
    }

    function renderActionProperties() {
      const container = document.getElementById('action-properties');
      const actionType = document.getElementById('action-select').value;
      
      let html = '';
      
      if (actionType === 'Add Tag') {
        html = `
          <div class="form-group">
            <label class="form-label">Tag to Add</label>
              <div class="multi-select">
              <button type="button" class="multi-select-button" onclick="toggleMultiSelect('action-tag')">
                <span id="action-tag-display">Select tag...</span>
                <span class="material-icons-outlined">expand_more</span>
                </button>
              <div class="multi-select-options" id="action-tag-options">
                <!-- Available tags will be populated here -->
                </div>
              </div>
            <div class="mt-3" id="action-tag-confirm" style="display: none;">
              <button type="button" class="btn-primary w-full" onclick="confirmActionTag()">
                Confirm Tag Selection
              </button>
            </div>
            <div class="form-group" style="margin-top:.75rem">
              <label class="form-label">Create New Tag</label>
              <div style="display:flex;gap:.5rem;align-items:center">
                <input id="action-new-tag-name" class="form-select" placeholder="New tag name" />
                <button type="button" class="context-btn" onclick="createActionTag()">Create</button>
              </div>
              <div id="action-create-tag-status" style="margin-top:.25rem;color:#9ca3af;font-size:.85rem"></div>
            </div>
          </div>
        `;
        
        // Reset selected tag when changing action type
        window.selectedActionTag = '';
        
        // Hide confirm button initially
        setTimeout(() => {
          const confirmBtn = document.getElementById('action-tag-confirm');
          if (confirmBtn) {
            confirmBtn.style.display = 'none';
          }
        }, 100);
        
        // Populate the action tag options after rendering
        setTimeout(() => populateActionTags(), 100);
      }
      
      if (actionType === 'Send Email') {
        html = `
          <div class="form-group">
            <label class="form-label" style="display:flex;align-items:center;gap:.5rem">
              <input type="checkbox" id="email-manual-recipient" /> Specify recipient manually
            </label>
            <div id="email-to-wrapper" style="margin-top:.5rem;display:none">
              <label class="form-label">To</label>
              <input id="email-to" class="form-select" placeholder="email1@example.com, email2@example.com" />
            </div>
            <div style="margin-top:.25rem;color:#9ca3af;font-size:.85rem">When unchecked, the email is sent to the contact who triggered the workflow.</div>
          </div>
          <div class="form-group">
            <label class="form-label">CC</label>
            <input id="email-cc" class="form-select" placeholder="Optional: comma-separated" />
          </div>
          <div class="form-group">
            <label class="form-label">BCC</label>
            <input id="email-bcc" class="form-select" placeholder="Optional: comma-separated" />
          </div>
          <div class="form-group">
            <label class="form-label">Subject</label>
            <input id="email-subject" class="form-select" placeholder="Subject line" />
          </div>
          <div class="form-group">
            <label class="form-label" style="display:flex;align-items:center;gap:.5rem">
              <input type="checkbox" id="email-is-html" /> Use HTML body
            </label>
          </div>
          <div class="form-group">
            <label class="form-label">Body</label>
            <textarea id="email-body" style="width:100%;min-height:160px;background:#1E3A34;border:1px solid #2C4A43;border-radius:.5rem;padding:.75rem;color:#E0E0E0"></textarea>
            <div style="margin-top:.25rem;color:#9ca3af;font-size:.85rem">Tip: Future versions support tokens like {{contact.fullName}}.</div>
          </div>
        `;
      }

      if (actionType === 'If') {
        const triggerNode = nodes.find(n => n.type === 'trigger');
        const triggerType = triggerNode?.data?.type || 'Meeting Scheduled';
        const contactFields = [
          ['contact.id','ID'],
          ['contact.firstName','First name'],
          ['contact.lastName','Last name'],
          ['contact.fullName','Full name'],
          ['contact.email','Email'],
          ['contact.phone','Phone'],
          ['contact.timezone','Timezone'],
          ['contact.locale','Locale'],
          ['contact.company','Company'],
          ['contact.title','Title'],
          ['contact.tags','Tags'],
          ['contact.notes','Notes'],
          ['contact.createdAt','Created at'],
          ['contact.updatedAt','Updated at']
        ];
        const bookingFields = [
          ['booking.id','ID'],
          ['booking.title','Title'],
          ['booking.status','Status'],
          ['booking.eventType','Event type'],
          ['booking.startTime','Start time'],
          ['booking.endTime','End time'],
          ['booking.durationMinutes','Duration (minutes)'],
          ['booking.timezone','Timezone'],
          ['booking.location','Location'],
          ['booking.meetingLink','Meeting link'],
          ['booking.rescheduleCount','Reschedule count'],
          ['booking.createdAt','Created at'],
          ['booking.updatedAt','Updated at']
        ];
        const defaultField = 'contact.email';
        // Build event-type-aware answer keys for the selected trigger configuration
        let dynamicAnswersOptions = '';
        try {
          const cache = Array.isArray(window.eventTypesCache) ? window.eventTypesCache : [];
          const slugifyKey = (s) => (s || '').toString().trim().toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '').substring(0,64);
          let subset = [];
          if (triggerType === 'Meeting Scheduled') {
            const ids = (window.selectedEventTypeIds && window.selectedEventTypeIds.length)
              ? window.selectedEventTypeIds
              : (triggerNode?.data?.properties?.eventTypeIds || []);
            if (Array.isArray(ids) && ids.length > 0) subset = cache.filter(et => ids.includes(et.id));
          } else if (triggerType === 'Tag Added') {
            subset = cache;
          }
          const seen = new Set();
          const list = [];
          subset.forEach(et => {
            if (Array.isArray(et?.questions)) {
              et.questions.forEach(q => {
                const label = (q && (q.text || q.label)) ? (q.text || q.label) : null;
                if (!label) return;
                const key = slugifyKey(label);
                if (key && !seen.has(key)) {
                  seen.add(key);
                  list.push({ key, label, etTitle: et.title });
                }
              });
            }
          });
          if (list.length > 0) {
            dynamicAnswersOptions += list.map(q => `
              <label class="multi-select-option" data-category="answers" data-text="${('booking.answers.'+q.key).toLowerCase()} ${q.label.toLowerCase()} ${q.etTitle.toLowerCase()}" onclick="selectIfField('booking.answers.${q.key}')">
                <span>${q.label} <span style=\"color:#6b7280\">(${q.etTitle})</span></span>
              </label>
            `).join('');
          }
        } catch (e) {
          // Non-fatal: fall back to manual entry only
        }
        if (!window.eventTypesCache) {
          // Lazy-load event types and re-render the If form once ready
          try {
            populateEventTypes().then(() => {
              const sel = document.getElementById('action-select');
              if (sel && sel.value === 'If') {
                renderActionProperties();
              }
            });
          } catch (_) {}
        }

        html = `
          ${triggerType === 'Tag Added' ? `
          <div style="background:#2c1f1f;border:1px solid #7f1d1d;color:#fca5a5;padding:.75rem;border-radius:.5rem;margin-bottom:.75rem">
            Warning: For Tag Added triggers, this condition can reference any event type's data. If the contact lacks the required data, evaluation will error and default to the false path.
          </div>` : ''}

          <div class="form-group">
            <label class="form-label">Field</label>
            <div class="multi-select">
              <button type="button" class="multi-select-button" onclick="toggleMultiSelect('if-field')">
                <span id="if-field-display">${defaultField}</span>
                <span class="material-icons-outlined">expand_more</span>
              </button>
              <div class="multi-select-options" id="if-field-options" style="max-height:340px;overflow:auto">
                <div style="padding:.5rem .75rem;border-bottom:1px solid #2C4A43;position:sticky;top:0;background:#0b1916;z-index:1">
                  <input id="if-field-search" class="form-select" placeholder="Search fields..." oninput="filterIfFieldOptions()" />
                  <div id="if-field-categories" style="display:flex;gap:.5rem;margin-top:.5rem;flex-wrap:wrap">
                    <button type="button" class="context-btn" data-cat="all" onclick="setIfFieldCategory('all')">All</button>
                    <button type="button" class="context-btn" data-cat="contact" onclick="setIfFieldCategory('contact')">Contact</button>
                    <button type="button" class="context-btn" data-cat="booking" onclick="setIfFieldCategory('booking')">Booking</button>
                    <button type="button" class="context-btn" data-cat="answers" onclick="setIfFieldCategory('answers')">Answers</button>
                    <button type="button" class="context-btn" data-cat="custom" onclick="setIfFieldCategory('custom')">Custom</button>
                  </div>
                </div>
                <div id="if-field-list" style="padding-top:.5rem">
                  <div class="if-cat-header" data-category="contact" style="padding:.5rem .75rem;color:#9ca3af;font-size:.8rem">Contact</div>
                  ${contactFields.map(([f,label]) => `<label class=\"multi-select-option\" data-category=\"contact\" data-text=\"${(label+' '+f).toLowerCase()}\" onclick=\"selectIfField('${f}')\"><span>${label} <span style=\\"color:#6b7280\\">(${f})</span></span></label>`).join('')}
                  <div class="if-cat-header" data-category="booking" style="padding:.5rem .75rem;color:#9ca3af;font-size:.8rem">Booking</div>
                  ${bookingFields.map(([f,label]) => `<label class=\"multi-select-option\" data-category=\"booking\" data-text=\"${(label+' '+f).toLowerCase()}\" onclick=\"selectIfField('${f}')\"><span>${label} <span style=\\"color:#6b7280\\">(${f})</span></span></label>`).join('')}
                  <div class="if-cat-header" data-category="answers" style="padding:.5rem .75rem;color:#9ca3af;font-size:.8rem">Available Answers</div>
                  ${dynamicAnswersOptions}
                  <div class="if-cat-header" data-category="custom" style="padding:.5rem .75rem;color:#9ca3af;font-size:.8rem">Custom Answers</div>
                  <div id="if-custom-answers-container" data-category="custom" style="padding:.5rem .75rem">
                    <input id="if-custom-answer-key" class="form-select" placeholder="answers.<questionKey> or booking.answers.<key>" />
                    <div style="margin-top:.25rem;text-align:right">
                      <button type="button" class="context-btn" onclick="applyIfCustomAnswer()">Use</button>
                    </div>
                    <div style="margin-top:.35rem;color:#9ca3af;font-size:.85rem">
                      Not sure which key to use? See the <a href="/editor/guide#custom-keys" target="_blank" style="color:#34D399;text-decoration:none">Custom Keys guide</a>.
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="form-group">
            <label class="form-label">Operator</label>
            <select id="if-operator" class="form-select">
              <option value="equals">Equals</option>
              <option value="not_equals">Does not equal</option>
              <option value="contains">Contains</option>
              <option value="not_contains">Does not contain</option>
              <option value="gt">Greater than</option>
              <option value="lt">Less than</option>
              <option value="exists">Exists</option>
              <option value="not_exists">Does not exist</option>
              <option value="in">In list (comma separated)</option>
            </select>
          </div>

          <div class="form-group" id="if-value-group">
            <label class="form-label">Value</label>
            <input id="if-value" class="form-select" placeholder="Value or CSV for 'in'" />
            <div style="margin-top:.25rem;color:#9ca3af;font-size:.85rem">Numbers compare numerically; others compare as strings. Use ISO dates for lexicographic comparisons.</div>
          </div>

          <input type="hidden" id="if-field" value="${defaultField}" />
        `;
      }
      
      container.innerHTML = html;

      // If editing, prefill Send Email fields
      if (actionType === 'Send Email' && selectedNode) {
        const existingNode = nodes.find(n => n.id === selectedNode);
        if (existingNode && existingNode.data && existingNode.data.type === 'Send Email') {
          const p = existingNode.data.properties || {};
          const set = (id, val) => { const el = document.getElementById(id); if (el && val !== undefined && val !== null) el.value = val; };
          const manualEl = document.getElementById('email-manual-recipient');
          const toWrap = document.getElementById('email-to-wrapper');
          const manual = !(p.useTriggerRecipient === true || (!p.to || (Array.isArray(p.to) && p.to.length === 0)));
          if (manualEl) manualEl.checked = manual;
          if (toWrap) toWrap.style.display = manual ? 'block' : 'none';
          set('email-to', Array.isArray(p.to) ? p.to.join(', ') : (p.to || ''));
          set('email-cc', Array.isArray(p.cc) ? p.cc.join(', ') : (p.cc || ''));
          set('email-bcc', Array.isArray(p.bcc) ? p.bcc.join(', ') : (p.bcc || ''));
          set('email-subject', p.subject || '');
          const bodyEl = document.getElementById('email-body');
          if (bodyEl) bodyEl.value = p.body || '';
          const htmlEl = document.getElementById('email-is-html');
          if (htmlEl) htmlEl.checked = !!p.isHtml;
        }
      }

      // Wire up manual recipient toggle (for create/edit)
      if (actionType === 'Send Email') {
        const manualEl = document.getElementById('email-manual-recipient');
        const toWrap = document.getElementById('email-to-wrapper');
        if (manualEl && toWrap) {
          const sync = () => { toWrap.style.display = manualEl.checked ? 'block' : 'none'; };
          manualEl.addEventListener('change', sync);
          sync();
        }
      }

      if (actionType === 'If') {
        // Toggle visibility of value field for exists/not_exists
        const opEl = document.getElementById('if-operator');
        const valueGroup = document.getElementById('if-value-group');
        if (opEl && valueGroup) {
          const sync = () => {
            const op = opEl.value;
            valueGroup.style.display = ['exists','not_exists'].includes(op) ? 'none' : 'block';
          };
          opEl.addEventListener('change', sync);
          sync();
        }

        // Prefill If when editing
        if (selectedNode) {
          const nodeData = nodes.find(n => n.id === selectedNode);
          if (nodeData && nodeData.data && nodeData.data.type === 'If') {
            const p = nodeData.data.properties || {};
            const field = p.field || 'contact.email';
            const operator = p.operator || 'equals';
            const value = p.value ?? '';
            const fieldDisplay = document.getElementById('if-field-display');
            const fieldHidden = document.getElementById('if-field');
            const opSelect = document.getElementById('if-operator');
            const valueEl = document.getElementById('if-value');
            if (fieldDisplay) fieldDisplay.textContent = field;
            if (fieldHidden) fieldHidden.value = field;
            if (opSelect) opSelect.value = operator;
            if (valueEl && value !== undefined) valueEl.value = Array.isArray(value) ? value.join(', ') : value;
          }
        }

        // Initialize category and search state
        setIfFieldCategory('all');
        filterIfFieldOptions();
      }
    }

    async function populateEventTypes() {
      try {
        const token = getAnyToken();
        if (!token) return;
        
        const clean = token.replace(/^"|"$/g, '');
        const res = await fetch(`${API_URL}/event-types`, { 
          headers: { Authorization: `Bearer ${clean}` } 
        });
        
        if (res.ok) {
          const eventTypes = await res.json();
          // Cache event types for conditional builder (If action)
          window.eventTypesCache = Array.isArray(eventTypes) ? eventTypes : [];
          const container = document.getElementById('event-type-options');
          
          container.innerHTML = eventTypes.map(et => `
            <label class="multi-select-option" onclick="selectEventType('${et.id}', '${et.title.replace(/'/g, "&#39;")}')">
              <span>${et.title}</span>
            </label>
          `).join('');
          
          // Restore selected event types if they exist
          if (window.selectedEventTypes && window.selectedEventTypes.length > 0) {
            const display = document.querySelector('#event-type-options').previousElementSibling.querySelector('span');
            if (display) {
              display.textContent = window.selectedEventTypes.join(', ');
            }
          }
        }
      } catch (error) {
        console.error('Error fetching event types:', error);
      }
    }

    async function populateTags() {
      try {
        const token = getAnyToken();
        if (!token) return;
        
        const clean = token.replace(/^"|"$/g, '');
        const res = await fetch(`${API_URL}/tags`, { 
          headers: { Authorization: `Bearer ${clean}` } 
        });
        
        if (res.ok) {
          const tags = await res.json();
          const container = document.getElementById('tag-options');
          
          container.innerHTML = tags.map(tag => `
            <label class="multi-select-option" onclick="selectTag('${tag.name}')">
              <span>${tag.name}</span>
            </label>
          `).join('');
          
          // Restore selected tags if they exist
          if (window.selectedTags && window.selectedTags.length > 0) {
            const display = document.getElementById('tag-display');
            if (display) {
              display.textContent = window.selectedTags.join(', ');
              display.style.color = '#34D399';
            }
            
            // Show confirm button if tags are selected
            const confirmBtn = document.getElementById('tag-confirm');
            if (confirmBtn) {
              confirmBtn.style.display = 'block';
            }
          }
        }
      } catch (error) {
        console.error('Error fetching tags:', error);
      }
    }

    async function populateActionTags() {
      try {
        const token = getAnyToken();
        if (!token) return;
        
        const clean = token.replace(/^"|"$/g, '');
        const res = await fetch(`${API_URL}/tags`, { 
          headers: { Authorization: `Bearer ${clean}` } 
        });
        
        if (res.ok) {
          const tags = await res.json();
          const container = document.getElementById('action-tag-options');
          
          container.innerHTML = tags.map(tag => `
            <label class="multi-select-option" onclick="selectActionTag('${tag.name}')">
              <span>${tag.name}</span>
            </label>
          `).join('');
        }
      } catch (error) {
        console.error('Error fetching action tags:', error);
      }
    }

    function toggleMultiSelect(type) {
      const options = document.getElementById(`${type}-options`);
      if (options) {
        options.classList.toggle('show');
        
        // Close other open dropdowns
        document.querySelectorAll('.multi-select-options').forEach(other => {
          if (other !== options) {
            other.classList.remove('show');
          }
        });
      }
    }
    
    // Close dropdowns when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.multi-select')) {
        document.querySelectorAll('.multi-select-options').forEach(dropdown => {
          dropdown.classList.remove('show');
        });
      }
    });

    function selectEventType(eventTypeId, eventTypeName) {
      if (!window.selectedEventTypes) window.selectedEventTypes = [];
      if (!window.selectedEventTypeIds) window.selectedEventTypeIds = [];
      
      const idxName = window.selectedEventTypes.indexOf(eventTypeName);
      const idxId = window.selectedEventTypeIds.indexOf(eventTypeId);
      const isSelected = idxName > -1 || idxId > -1;
      if (isSelected) {
        if (idxName > -1) window.selectedEventTypes.splice(idxName, 1);
        if (idxId > -1) window.selectedEventTypeIds.splice(idxId, 1);
      } else {
        window.selectedEventTypes.push(eventTypeName);
        window.selectedEventTypeIds.push(eventTypeId);
      }
      
      // Update display
      const display = document.querySelector('#event-type-options').previousElementSibling.querySelector('span');
      if (display) {
        if (window.selectedEventTypes.length > 0) {
          display.textContent = window.selectedEventTypes.join(', ');
        } else {
          display.textContent = 'Select event types...';
        }
      }
      
      // Close the dropdown
      const options = document.getElementById('event-type-options');
      if (options) {
        options.classList.remove('show');
      }
    }
    
    function selectAllEventTypes() {
      // Get all available event types from the options
      const eventTypeOptions = document.querySelectorAll('#event-type-options .multi-select-option span');
      if (eventTypeOptions.length > 0) {
        window.selectedEventTypes = Array.from(eventTypeOptions).map(span => span.textContent);
        
        // Update display
        const display = document.querySelector('#event-type-options').previousElementSibling.querySelector('span');
        if (display) {
          display.textContent = window.selectedEventTypes.join(', ');
        }
      }
    }

    function selectAllTags() {
      // Get all available tags from the options
      const tagOptions = document.querySelectorAll('#tag-options .multi-select-option span');
      if (tagOptions.length > 0) {
        window.selectedTags = Array.from(tagOptions).map(span => span.textContent);
        
        // Update display
        const display = document.getElementById('tag-display');
        if (display) {
          display.textContent = window.selectedTags.join(', ');
        }
        
        // Show confirm button
        const confirmBtn = document.getElementById('tag-confirm');
        if (confirmBtn) {
          confirmBtn.style.display = 'block';
        }
      }
    }

        function selectActionTag(tagName) {
      const display = document.getElementById('action-tag-display');
      if (display) {
        display.textContent = tagName;
      }
      
      // Close the dropdown
      const options = document.getElementById('action-tag-options');
      if (options) {
        options.classList.remove('show');
      }
      
      // Store the selected tag for later use
      window.selectedActionTag = tagName;

      // Show confirm button
      const confirmBtn = document.getElementById('action-tag-confirm');
      if (confirmBtn) {
        confirmBtn.style.display = 'block';
      }
    }
    
    function confirmTagSelection() {
      // Hide confirm button after confirmation
      const confirmBtn = document.getElementById('tag-confirm');
      if (confirmBtn) {
        confirmBtn.style.display = 'none';
      }
      
      // Update display to show confirmed selection
      const display = document.getElementById('tag-display');
      if (display && window.selectedTags && window.selectedTags.length > 0) {
        display.textContent = ` ${window.selectedTags.join(', ')}`;
        display.style.color = '#34D399';
      }
    }
    
    function selectTag(tagName) {
      // Initialize selectedTags array if it doesn't exist
      if (!window.selectedTags) {
        window.selectedTags = [];
      }
      
      // Toggle tag selection
      const index = window.selectedTags.indexOf(tagName);
      if (index > -1) {
        window.selectedTags.splice(index, 1);
      } else {
        window.selectedTags.push(tagName);
      }
      
      // Update display
      const display = document.getElementById('tag-display');
      if (display) {
        if (window.selectedTags.length > 0) {
          display.textContent = window.selectedTags.join(', ');
          // Show confirm button
          const confirmBtn = document.getElementById('tag-confirm');
          if (confirmBtn) {
            confirmBtn.style.display = 'block';
          }
          } else {
          display.textContent = 'Select tags...';
          // Hide confirm button
          const confirmBtn = document.getElementById('tag-confirm');
          if (confirmBtn) {
            confirmBtn.style.display = 'none';
          }
        }
      }
      
      // Close the dropdown
      const options = document.getElementById('tag-options');
      if (options) {
        options.classList.remove('show');
      }
    }

    function confirmActionTag() {
      // Hide confirm button after confirmation
      const confirmBtn = document.getElementById('action-tag-confirm');
      if (confirmBtn) {
        confirmBtn.style.display = 'none';
      }
      
      // Update display to show confirmed selection
      const display = document.getElementById('action-tag-display');
      if (display && window.selectedActionTag) {
        display.textContent = ` ${window.selectedActionTag}`;
        display.style.color = '#34D399';
      }
    }

    async function createActionTag() {
      const input = document.getElementById('action-new-tag-name');
      const status = document.getElementById('action-create-tag-status');
      if (!input) return;
      const name = (input.value || '').trim();
      if (!name) {
        if (status) status.textContent = 'Please enter a tag name.';
        return;
      }
      try {
        const token = getAnyToken();
        if (!token) throw new Error('No token');
        const clean = token.replace(/^"|"$/g, '');
        const res = await fetch(`${API_URL}/tags`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${clean}` },
          body: JSON.stringify({ name })
        });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        // Clear input and update status
        input.value = '';
        if (status) status.textContent = `Created tag "${name}"`;
        // Refresh tag options so the new tag appears
        await populateActionTags();
        // Auto-select the newly created tag
        selectActionTag(name);
        confirmActionTag();
      } catch (e) {
        if (status) status.textContent = 'Failed to create tag';
        console.error('createActionTag error:', e);
      }
    }

    // IF action helpers
    function selectIfField(fieldPath) {
      const display = document.getElementById('if-field-display');
      const hidden = document.getElementById('if-field');
      if (display) display.textContent = fieldPath;
      if (hidden) hidden.value = fieldPath;
      const options = document.getElementById('if-field-options');
      if (options) options.classList.remove('show');
    }

    function applyIfCustomAnswer() {
      const input = document.getElementById('if-custom-answer-key');
      if (!input) return;
      let key = input.value.trim();
      if (!key) return;
      // Normalize to booking.answers.<key> if user typed shorthand answers.<key>
      if (key.startsWith('answers.')) key = `booking.${key}`;
      if (!key.startsWith('booking.answers.')) key = `booking.answers.${key}`;
      selectIfField(key);
    }

    // Category + search for IF field dropdown
    window.currentIfFieldCategory = 'all';
    function setIfFieldCategory(cat) {
      window.currentIfFieldCategory = cat;
      // Update button active styles
      const btns = document.querySelectorAll('#if-field-categories .context-btn');
      btns.forEach(b => {
        if (b.getAttribute('data-cat') === cat) {
          b.style.background = '#34D399';
          b.style.color = '#1A2E29';
        } else {
          b.style.background = '';
          b.style.color = '';
        }
      });
      filterIfFieldOptions();
    }

    function filterIfFieldOptions() {
      const searchEl = document.getElementById('if-field-search');
      const q = (searchEl ? searchEl.value : '').toLowerCase().trim();
      const cat = window.currentIfFieldCategory || 'all';
      const list = document.getElementById('if-field-options');
      if (!list) return;
      const items = list.querySelectorAll('label.multi-select-option, .if-cat-header, #if-custom-answers-container');

      // First pass: show/hide by category
      items.forEach(el => {
        const elCat = el.getAttribute('data-category');
        let showByCat = cat === 'all' || (elCat ? elCat === cat : true);
        // Always keep sticky header (search/categories wrapper) visible
        if (el.id === 'if-field-categories' || el.id === 'if-field-search') showByCat = true;
        el.style.display = showByCat ? '' : 'none';
      });

      // Second pass: apply search filter within visible category
      if (q) {
        items.forEach(el => {
          if (el.tagName.toLowerCase() === 'label') {
            if (el.style.display === 'none') return; // already hidden by category
            const text = (el.getAttribute('data-text') || el.textContent || '').toLowerCase();
            el.style.display = text.includes(q) ? '' : 'none';
          }
        });
        // Hide headers with no following visible items of same category
        const headers = list.querySelectorAll('.if-cat-header');
        headers.forEach(h => {
          if (h.style.display === 'none') return;
          const hCat = h.getAttribute('data-category');
          let hasVisible = false;
          let next = h.nextElementSibling;
          while (next && !next.classList.contains('if-cat-header')) {
            if (next.style.display !== 'none') { hasVisible = true; break; }
            next = next.nextElementSibling;
          }
          h.style.display = hasVisible ? '' : 'none';
        });
      } else {
        // No search: show headers relevant to selected category
        const headers = list.querySelectorAll('.if-cat-header');
        headers.forEach(h => {
          const hCat = h.getAttribute('data-category');
          h.style.display = (cat === 'all' || hCat === cat) ? '' : 'none';
        });
      }
    }

    function saveTrigger() {
      const triggerType = document.getElementById('trigger-select').value;
      const triggerNode = nodes.find(n => n.type === 'trigger');
      
      if (!triggerNode) return;
      
      let properties = {};
      
      if (triggerType === 'Meeting Scheduled') {
        properties.eventTypes = window.selectedEventTypes || [];
        properties.eventTypeIds = window.selectedEventTypeIds || [];
        console.log('Saving trigger with event types:', properties.eventTypes, properties.eventTypeIds);
      } else if (triggerType === 'Tag Added') {
        properties.tags = window.selectedTags || [];
        console.log('Saving trigger with tags:', properties.tags);
      }
      
      // Update trigger node
      updateTriggerNode({ type: triggerType, properties });
      
      // Remove guide text when trigger is configured
      const helpText = container.querySelector('div[style*="Configure your trigger above"]');
      if (helpText) {
        helpText.remove();
      } else {
        // Try alternative selectors
        const allDivs = container.querySelectorAll('div');
        allDivs.forEach((div) => {
          if (div.innerHTML && div.innerHTML.includes('Configure your trigger above')) {
            div.remove();
          }
        });
      }
      
      // Also remove the CSS pseudo-element guide text by updating the trigger node
      const triggerNodeElement = container.querySelector('.flowchart-node.trigger');
      if (triggerNodeElement) {
        triggerNodeElement.classList.add('configured');
      }
      
      closeTriggerModal();
    }

    function saveAction() {
      const actionType = document.getElementById('action-select').value;
      const parentNodeId = selectedNode;
      
      if (!parentNodeId) return;
      
      let properties = {};
      
      if (actionType === 'Add Tag') {
        properties.tag = window.selectedActionTag || '';
      }
      if (actionType === 'Send Email') {
        const val = id => {
          const el = document.getElementById(id);
          return el ? el.value.trim() : '';
        };
        const csv = s => s ? s.split(',').map(x => x.trim()).filter(Boolean) : [];
        const manual = !!(document.getElementById('email-manual-recipient')?.checked);
        const toList = csv(val('email-to'));
        properties = {
          useTriggerRecipient: !manual,
          to: manual ? toList : [],
          cc: csv(val('email-cc')),
          bcc: csv(val('email-bcc')),
          subject: val('email-subject'),
          body: val('email-body'),
          isHtml: !!(document.getElementById('email-is-html')?.checked)
        };
        if (manual && !toList.length) {
          alert('Please provide at least one recipient in To');
          return;
        }
        if (!properties.subject) {
          alert('Please provide an email subject');
          return;
        }
        if (!properties.body) {
          alert('Please provide an email body');
          return;
        }
      }
      if (actionType === 'If') {
        const field = document.getElementById('if-field')?.value?.trim();
        const operator = document.getElementById('if-operator')?.value;
        const rawValue = document.getElementById('if-value')?.value ?? '';
        if (!field || !operator) {
          alert('Please select a field and operator for the If condition');
          return;
        }
        let value = rawValue;
        if (['gt','lt'].includes(operator)) {
          const n = Number(rawValue);
          if (!Number.isFinite(n)) {
            alert('Please enter a valid number for the comparison');
            return;
          }
          value = n;
        } else if (operator === 'in') {
          value = (rawValue || '').split(',').map(s => s.trim()).filter(Boolean);
          if (value.length === 0) {
            alert('Please provide at least one list item for the "in" operator');
            return;
          }
        }
        const triggerType = nodes.find(n => n.type === 'trigger')?.data?.type || 'Meeting Scheduled';
        properties = { field, operator };
        if (!['exists','not_exists'].includes(operator)) properties.value = value;
        properties.triggerType = triggerType;
        if (triggerType === 'Tag Added') properties.missingDataBehavior = 'default_false_path_on_error';
      }
      
      if (actionType === 'Add Tag' && !properties.tag) {
        alert('Please select a tag');
        return;
      }
      
      // Check if this is an insert operation
      if (parentNodeId === 'insert' && window.insertConnection) {
        const inserted = insertActionBetween({ type: actionType, properties }, window.insertConnection);
        // If IF, auto-create True/False headers
        if (actionType === 'If' && inserted && inserted.element) {
          if (!inserted.data.properties) inserted.data.properties = {};
          if (!inserted.data.properties.ifId) inserted.data.properties.ifId = `if_${Date.now()}_${Math.random().toString(36).slice(2)}`;
          const trueNode = addControlNodeAfterElement(inserted.element, 'True');
          const falseNode = addControlNodeAfterElement(inserted.element, 'False');
          if (trueNode && trueNode.element) trueNode.data = { type: 'True', properties: { parentIfId: inserted.data.properties.ifId, ifDomId: inserted.element.id, branch: 'true' } };
          if (falseNode && falseNode.element) falseNode.data = { type: 'False', properties: { parentIfId: inserted.data.properties.ifId, ifDomId: inserted.element.id, branch: 'false' } };
        }
        window.insertConnection = null;
        closeActionModal();
        return;
      }
      // Branch insertions from IF node (True / False columns)
      if (parentNodeId && parentNodeId.startsWith('branch-true-')) {
        const ifId = parentNodeId.replace('branch-true-', '');
        const { ifIndex, trueIndex } = findIfHeaders(ifId);
        if (ifIndex === -1 || trueIndex === -1) { closeActionModal(); return; }
        const actionNode = createNode(actionType, actionType, 'settings', getActionContent({ type: actionType, properties }));
        actionNode.style.left = 'calc(50% - 280px)';
        actionNode.style.transform = 'translateX(-50%)';
        const trueEl = nodes[trueIndex].element;
        const containerRect = container.getBoundingClientRect();
        let y = trueEl.getBoundingClientRect().bottom - containerRect.top + 60;
        const ifStepId = nodes[ifIndex]?.data?.properties?.ifId;
        for (let i = 0; i < nodes.length; i++) {
          const d = nodes[i]?.data;
          if (d && d.properties && d.properties.parentIfId === ifStepId && d.properties.branch === 'true') {
            const r = nodes[i].element.getBoundingClientRect();
            y = Math.max(y, r.bottom - containerRect.top + 60);
          }
        }
        actionNode.style.top = `${y}px`;
        container.appendChild(actionNode);
        const nodeData = { id: actionNode.id, type: 'action', element: actionNode, data: { type: actionType, properties: { ...properties, parentIfId: ifStepId, ifDomId: ifId, branch: 'true' } } };
        nodes.push(nodeData);
        StructureManager.rebuild();
        try { HistoryManager.recordSnapshot('branch-true-insert'); } catch {}
        closeActionModal();
        return;
      }
      if (parentNodeId && parentNodeId.startsWith('branch-false-')) {
        const ifId = parentNodeId.replace('branch-false-', '');
        const { ifIndex, falseIndex } = findIfHeaders(ifId);
        if (ifIndex === -1 || falseIndex === -1) { closeActionModal(); return; }
        const actionNode = createNode(actionType, actionType, 'settings', getActionContent({ type: actionType, properties }));
        actionNode.style.left = 'calc(50% + 280px)';
        actionNode.style.transform = 'translateX(-50%)';
        const falseEl = nodes[falseIndex].element;
        const containerRect = container.getBoundingClientRect();
        let y = falseEl.getBoundingClientRect().bottom - containerRect.top + 60;
        const ifStepId = nodes[ifIndex]?.data?.properties?.ifId;
        for (let i = 0; i < nodes.length; i++) {
          const d = nodes[i]?.data;
          if (d && d.properties && d.properties.parentIfId === ifStepId && d.properties.branch === 'false') {
            const r = nodes[i].element.getBoundingClientRect();
            y = Math.max(y, r.bottom - containerRect.top + 60);
          }
        }
        actionNode.style.top = `${y}px`;
        container.appendChild(actionNode);
        const nodeData = { id: actionNode.id, type: 'action', element: actionNode, data: { type: actionType, properties: { ...properties, parentIfId: ifStepId, ifDomId: ifId, branch: 'false' } } };
        nodes.push(nodeData);
        StructureManager.rebuild();
        try { HistoryManager.recordSnapshot('branch-false-insert'); } catch {}
        closeActionModal();
        return;
      }
      
      // Check if this is an "add after" operation
      if (parentNodeId && parentNodeId.startsWith('add-after-')) {
        const afterNodeId = parentNodeId.replace('add-after-', '');
        
        // Create the action node
        const actionNode = createNode(actionType, actionType, 'settings', getActionContent({ type: actionType, properties }));
        
        // Find the node to add after
        const afterNode = nodes.find(n => n.id === afterNodeId);
        if (!afterNode) {
          console.error('Could not find node to add after:', afterNodeId);
          closeActionModal();
          return;
        }
        
        // Determine if we are in a branch (True/False) and position accordingly
        const containerRect = container.getBoundingClientRect();
        const afterType = afterNode.data?.type;
        const afterProps = afterNode.data?.properties || {};
        let branchCtx = null;
        if (afterType === 'True' || afterType === 'False') {
          branchCtx = { parentIfId: afterProps.parentIfId, ifDomId: afterProps.ifDomId, branch: (afterType === 'True' ? 'true' : 'false') };
        } else if (afterProps && afterProps.parentIfId) {
          branchCtx = { parentIfId: afterProps.parentIfId, ifDomId: afterProps.ifDomId, branch: afterProps.branch };
        }
        
        if (branchCtx && branchCtx.parentIfId) {
          const columnLeft = branchCtx.branch === 'true' ? 'calc(50% - 280px)' : 'calc(50% + 280px)';
          actionNode.style.left = columnLeft;
          actionNode.style.transform = 'translateX(-50%)';
          // Place below the last item in this branch
          let y;
          // Try to anchor from header if present
          const headerType = branchCtx.branch === 'true' ? 'True' : 'False';
          const header = nodes.find(n => n.data?.type === headerType && n.data?.properties?.parentIfId === branchCtx.parentIfId);
          if (header && header.element) {
            const headerRect = header.element.getBoundingClientRect();
            y = headerRect.bottom - containerRect.top + 60;
          } else {
            const afterRect = afterNode.element.getBoundingClientRect();
            y = afterRect.bottom - containerRect.top + 60;
          }
          for (const n of nodes) {
            const d = n.data;
            if (!d || d.type === 'If') continue;
            if (d.properties && d.properties.parentIfId === branchCtx.parentIfId && d.properties.branch === branchCtx.branch) {
              const r = n.element.getBoundingClientRect();
              y = Math.max(y, r.bottom - containerRect.top + 60);
            }
          }
          actionNode.style.top = `${y}px`;
          // Merge branch context into properties so connections build correctly
          properties = { ...properties, ...branchCtx };
        } else {
          // Not in a branch: position below the after node, centered
          const afterRect = afterNode.element.getBoundingClientRect();
          const topPosition = afterRect.bottom - containerRect.top + 120;
          actionNode.style.left = '50%';
          actionNode.style.top = `${topPosition}px`;
          actionNode.style.transform = 'translateX(-50%)';
        }
        
        container.appendChild(actionNode);
        
        // Add to nodes array
        const nodeData = { 
          id: actionNode.id, 
          type: 'action', 
          element: actionNode, 
          data: { type: actionType, properties } 
        };
        nodes.push(nodeData);
        
        // Rebuild the entire workflow structure to ensure all connections are created
        StructureManager.rebuild();
        try { HistoryManager.recordSnapshot('add-after'); } catch {}

        // If IF, auto-create True/False headers
        if (actionType === 'If') {
          if (!properties) properties = {};
          if (!properties.ifId) properties.ifId = `if_${Date.now()}_${Math.random().toString(36).slice(2)}`;
          // Update node data to include ifId
          nodeData.data = { type: actionType, properties };
          const trueNode = addControlNodeAfterElement(actionNode, 'True');
          const falseNode = addControlNodeAfterElement(actionNode, 'False');
          if (trueNode && trueNode.element) trueNode.data = { type: 'True', properties: { parentIfId: properties.ifId, ifDomId: actionNode.id, branch: 'true' } };
          if (falseNode && falseNode.element) falseNode.data = { type: 'False', properties: { parentIfId: properties.ifId, ifDomId: actionNode.id, branch: 'false' } };
        }
        
        // Add movement listeners to the new node
        addNodeMovementListeners();
        
        closeActionModal();
        return;
      }
      
      // Check if we're editing an existing action
      const existingNode = nodes.find(n => n.id === parentNodeId);
      if (existingNode && existingNode.type !== 'trigger') {
        // Update existing action
        existingNode.data = { type: actionType, properties };
        existingNode.element.querySelector('.node-title').textContent = actionType;
        existingNode.element.querySelector('.node-content').textContent = getActionContent({ type: actionType, properties });
        updateWorkflowFromNodes();
      } else {
        // Add new action node
        addActionNode({ type: actionType, properties }, nodes.length);
      }
      
      try { HistoryManager.recordSnapshot(existingNode ? 'editAction' : 'newAction'); } catch {}
      closeActionModal();
    }

    function updateTriggerNode(triggerData) {
      console.log('Updating trigger node with data:', triggerData);
      
      let triggerNode = nodes.find(n => n.type === 'trigger');
      
      if (!triggerNode) {
        console.log('Creating new trigger node');
        // Create new trigger node if it doesn't exist
        const node = createNode('trigger', triggerData.type, 'play_circle', 'Click to configure trigger');
        node.style.left = '50%';
        node.style.top = '50px';
        node.style.transform = 'translateX(-50%)';
        
        // Override the click handler for the trigger node specifically
        node.removeEventListener('click', (e) => selectNode(node));
        node.addEventListener('click', (e) => {
          e.stopPropagation();
          openTriggerModal();
        });
        
        container.appendChild(node);
        
        triggerNode = { 
          id: node.id, 
          type: 'trigger', 
          element: node 
        };
        nodes.push(triggerNode);
        
      // Rebuild workflow structure to ensure proper connections
      StructureManager.rebuild();
      
      // Add movement listeners
      addNodeMovementListeners();
      }
      
      const node = triggerNode.element;
      const title = triggerData.type;
      let content = '';
      
      if (triggerData.type === 'Meeting Scheduled' && triggerData.properties?.eventTypes) {
        content = `Triggers when meetings are scheduled for: ${triggerData.properties.eventTypes.join(', ')}`;
      } else if (triggerData.type === 'Tag Added' && triggerData.properties?.tags) {
        content = `Triggers when tags are added: ${triggerData.properties.tags.join(', ')}`;
      } else {
        content = `Triggers on: ${triggerData.type}`;
      }
      
      node.querySelector('.node-title').textContent = title;
      node.querySelector('.node-content').textContent = content;
      
      // Store trigger data
      triggerNode.data = triggerData;
    try { HistoryManager.recordSnapshot('updateTriggerNode'); } catch {}
    }

    function addActionNode(actionData, index) {
      console.log('Adding action node:', actionData);
      
      // Avoid duplicating True/False branch headers on load or rebuild
      if (actionData.type === 'True' || actionData.type === 'False') {
        const parentIfId = actionData.properties?.parentIfId;
        const branch = actionData.properties?.branch;
        if (parentIfId && branch) {
          const exists = nodes.some(n => n.data?.type === actionData.type && n.data?.properties?.parentIfId === parentIfId && n.data?.properties?.branch === branch);
          if (exists) {
            console.log('Branch header already exists, skipping:', actionData.type, parentIfId, branch);
            return;
          }
        }
      }
      
      // Find the trigger node (should be the first one)
      const triggerNode = nodes.find(n => n.type === 'trigger');
      if (!triggerNode) {
        console.error('No trigger node found when adding action');
        return;
      }
      
        const actionNode = createNode(actionData.type, actionData.type, 'settings', getActionContent(actionData));
        // Mark join nodes on the DOM for reliable detection in path rendering
        try {
          if (actionData && actionData.properties && actionData.properties.joinForIfId) {
            actionNode.dataset.joinForIfId = actionData.properties.joinForIfId;
          }
        } catch {}
      
      // Decide placement: if the action is in a branch, place in that column; otherwise center
      const containerRect = container.getBoundingClientRect();
      const branch = actionData.properties?.branch;
      const parentIfId = actionData.properties?.parentIfId;
      let topPosition;
      if (branch && parentIfId) {
        // Find the header for this branch to anchor below
        const headerType = branch === 'true' ? 'True' : 'False';
        const header = nodes.find(n => n.data?.type === headerType && n.data?.properties?.parentIfId === parentIfId);
        const columnLeft = branch === 'true' ? 'calc(50% - 280px)' : 'calc(50% + 280px)';
        actionNode.style.left = columnLeft;
        actionNode.style.transform = 'translateX(-50%)';
        if (header && header.element) {
          // Place below the header or last item in this branch
          const headerRect = header.element.getBoundingClientRect();
          topPosition = headerRect.bottom - containerRect.top + 60;
          for (const n of nodes) {
            const d = n.data;
            if (!d || d.type === 'If') continue;
            if (d.properties && d.properties.parentIfId === parentIfId && d.properties.branch === branch) {
              const r = n.element.getBoundingClientRect();
              topPosition = Math.max(topPosition, r.bottom - containerRect.top + 60);
            }
          }
        } else {
          // Fallback: position relative to trigger
          const parentRect = triggerNode.element.getBoundingClientRect();
          topPosition = parentRect.bottom - containerRect.top + 120;
        }
        actionNode.style.top = `${topPosition}px`;
      } else {
        // Centered linear placement (not in a branch)
        let parentNode = triggerNode;
        const lastActionNode = nodes.filter(n => n.type !== 'trigger').pop();
        if (lastActionNode) parentNode = lastActionNode;
        const parentRect = parentNode.element.getBoundingClientRect();
        topPosition = parentRect.bottom - containerRect.top + 120;
        actionNode.style.left = '50%';
        actionNode.style.top = `${topPosition}px`;
        actionNode.style.transform = 'translateX(-50%)';
      }
      
      container.appendChild(actionNode);
      
      const nodeData = { 
        id: actionNode.id, 
        type: 'action', 
        element: actionNode, 
        data: actionData 
      };
      nodes.push(nodeData);
      
      // Rebuild the entire workflow structure to ensure consistency
      StructureManager.rebuild();

      // If we just added an IF, auto-create True/False headers
      if (actionData.type === 'If') {
        // If loading from persisted data that already includes True/False, do not auto-create
        if (isLoadingWorkflow) {
          addNodeMovementListeners();
          return;
        }
        if (!actionData.properties) actionData.properties = {};
        if (!actionData.properties.ifId) actionData.properties.ifId = `if_${Date.now()}_${Math.random().toString(36).slice(2)}`;
        nodeData.data = actionData;
        const trueNode = addControlNodeAfterElement(actionNode, 'True');
        const falseNode = addControlNodeAfterElement(actionNode, 'False');
        if (trueNode && trueNode.element) trueNode.data = { type: 'True', properties: { parentIfId: actionData.properties.ifId, ifDomId: actionNode.id, branch: 'true' } };
        if (falseNode && falseNode.element) falseNode.data = { type: 'False', properties: { parentIfId: actionData.properties.ifId, ifDomId: actionNode.id, branch: 'false' } };
      }
      
      // Add movement listeners to the new node
      addNodeMovementListeners();

    try { HistoryManager.recordSnapshot('addActionNode'); } catch {}
    }

    function insertActionBetween(actionData, connection) {
      console.log('Inserting action between nodes:', connection.from.id, 'and', connection.to.id);
      
      // Create the new action node
      // Determine if this insertion is intended to join True/False branches of the same IF
      let joinForIfId = null;
      try {
        const fromNodeData = nodes.find(n => n.element === connection.from);
        const toNodeData = nodes.find(n => n.element === connection.to);
        const fromProps = fromNodeData?.data?.properties;
        const toProps = toNodeData?.data?.properties;
        const fromIf = fromProps?.parentIfId || (fromNodeData?.data?.type === 'If' ? (fromNodeData.data.properties?.ifId) : null);
        const toIf = toProps?.parentIfId || (toNodeData?.data?.type === 'If' ? (toNodeData.data.properties?.ifId) : null);
        if (fromIf && toIf && fromIf === toIf) joinForIfId = fromIf;
        else if (fromIf) joinForIfId = fromIf;
        else if (toIf) joinForIfId = toIf;
      } catch {}
      const actionNode = createNode(actionData.type, actionData.type, 'settings', getActionContent(actionData));
      try {
        if (actionData && actionData.properties && actionData.properties.joinForIfId) {
          actionNode.dataset.joinForIfId = actionData.properties.joinForIfId;
        }
      } catch {}
      
      const containerRect = container.getBoundingClientRect();
      if (joinForIfId) {
        // Place centered horizontally and below the deeper of the two branches
        const centerX = containerRect.width / 2;
        // Find deepest Y among true/false branch nodes for this IF
        let maxBottom = 0;
        for (const n of nodes) {
          const d = n.data;
          if (!d || d.type === 'If' || d.type === 'True' || d.type === 'False') continue;
          if (d.properties && d.properties.parentIfId === joinForIfId) {
            const r = n.element.getBoundingClientRect();
            maxBottom = Math.max(maxBottom, r.bottom - containerRect.top);
          }
        }
        // If no branch actions, anchor under headers
        if (maxBottom === 0) {
          const headers = nodes.filter(n => (n.data?.type === 'True' || n.data?.type === 'False') && n.data?.properties?.parentIfId === joinForIfId);
          headers.forEach(h => { const r = h.element.getBoundingClientRect(); maxBottom = Math.max(maxBottom, r.bottom - containerRect.top); });
        }
        actionNode.style.left = `${centerX}px`;
        actionNode.style.transform = 'translateX(-50%)';
        actionNode.style.top = `${Math.round(maxBottom + 60)}px`;
        // Mark as join node (do not set branch) so rebuild can wire both branches to it;
        // also remove any existing midpoint orbs for this IF block
        actionData.properties = { ...(actionData.properties || {}), joinForIfId: joinForIfId };
        try {
          // Remove insert orbs on If->True/False for this IF
          const conns = Array.from(WorkflowManager.connections.values());
          conns.forEach(c => {
            const fData = nodes.find(n => n.element === c.from)?.data || {};
            const tData = nodes.find(n => n.element === c.to)?.data || {};
            if ((fData?.type === 'If' && fData?.properties?.ifId === joinForIfId) || (tData?.type === 'If' && tData?.properties?.ifId === joinForIfId)) {
              const orb = WorkflowManager.insertOrbs.get(c.id);
              if (orb) { orb.remove(); WorkflowManager.insertOrbs.delete(c.id); }
            }
          });
        } catch {}
      } else {
        // Default: position the action node in the middle of the connection
        const fromRect = connection.from.getBoundingClientRect();
        const toRect = connection.to.getBoundingClientRect();
        const middleX = (fromRect.left + toRect.left) / 2 - containerRect.left;
        const middleY = (fromRect.bottom + toRect.top) / 2 - containerRect.top;
        actionNode.style.left = `${middleX - 100}px`; // 100 is half of node width
        actionNode.style.top = `${middleY - 25}px`; // 25 is half of node height
      }
      
      container.appendChild(actionNode);
      
      const nodeData = { 
        id: actionNode.id, 
        type: 'action', 
        element: actionNode, 
        data: actionData 
      };
      
      // Insert the node into the nodes array at the correct position
      const fromNodeIndex = nodes.findIndex(n => n.element === connection.from);
      const toNodeIndex = nodes.findIndex(n => n.element === connection.to);
      
      if (fromNodeIndex !== -1 && toNodeIndex !== -1) {
        // Insert between the two nodes
        const insertIndex = Math.min(fromNodeIndex, toNodeIndex) + 1;
        nodes.splice(insertIndex, 0, nodeData);
      } else {
        // Fallback: add to end
        nodes.push(nodeData);
      }
      
        // Rebuild the entire workflow structure
        StructureManager.rebuild();
      
      // Add movement listeners
      addNodeMovementListeners();
      
      console.log('Action inserted successfully');
    try { HistoryManager.recordSnapshot('insertActionBetween'); } catch {}
      return nodeData;
    }

    // Helper: add a lightweight branch header node (True/False) immediately after a given node element
    function addControlNodeAfterElement(afterNodeElement, type) {
      const content = type;
      const actionNode = createNode(type, type, 'settings', content);
      const afterRect = afterNodeElement.getBoundingClientRect();
      const containerRect = container.getBoundingClientRect();
      const topPosition = afterRect.bottom - containerRect.top + 80;
      actionNode.style.left = '50%';
      actionNode.style.top = `${topPosition}px`;
      actionNode.style.transform = 'translateX(-50%)';
      container.appendChild(actionNode);
      const afterIndex = nodes.findIndex(n => n.element === afterNodeElement);
      const ifNode = nodes.find(n => n.element === afterNodeElement);
      const ifId = ifNode?.data?.properties?.ifId || null;
      const branch = type === 'True' ? 'true' : (type === 'False' ? 'false' : undefined);
      const nodeData = { id: actionNode.id, type: 'action', element: actionNode, data: { type, properties: { parentIfId: ifId, ifDomId: afterNodeElement.id, branch } } };
      if (afterIndex >= 0) {
        nodes.splice(afterIndex + 1, 0, nodeData);
      } else {
        nodes.push(nodeData);
      }
      StructureManager.rebuild();
      addNodeMovementListeners();
      return nodeData;
    }

    function getActionContent(actionData) {
      if (actionData.type === 'Add Tag') {
        return `Adds tag: ${actionData.properties.tag}`;
      }
      if (actionData.type === 'Send Email') {
        const p = actionData.properties || {};
        const auto = p.useTriggerRecipient === true || (!p.to || (Array.isArray(p.to) && p.to.length === 0));
        const to = auto ? 'Contact' : (Array.isArray(p.to) ? p.to.join(', ') : (p.to || ''));
        const subj = p.subject || '';
        const mode = p.isHtml ? 'HTML' : 'Text';
        return `Email (${mode}) to ${to}  Subject: ${subj}`;
      }
      if (actionData.type === 'If') {
        const p = actionData.properties || {};
        const needsValue = !['exists','not_exists'].includes(p.operator);
        const val = Array.isArray(p.value) ? p.value.join(', ') : (p.value ?? '');
        const core = `If ${p.field} ${p.operator}${needsValue ? ' ' : ''}${needsValue ? val : ''}`;
        const warn = p.triggerType === 'Tag Added' ? '  missing data -> false path' : '';
        return core + warn + '    Use buttons to add to True/False paths';
      }
      if (actionData.type === 'True') return 'True  actions in this branch run when the If condition evaluates to TRUE.';
      if (actionData.type === 'False') return 'False  actions in this branch run when the If condition evaluates to FALSE.';
      return `Action: ${actionData.type}`;
    }
    
    function editAction(actionNode) {
      const nodeData = nodes.find(n => n.element === actionNode);
      if (!nodeData) return;
      
      // If IF node: present branch controls instead of opening modal
      if (nodeData.data && nodeData.data.type === 'If') {
        try { decorateIfNodeForBranches(actionNode); } catch {}
        // Do not open modal for IF itself on click; let user choose branch buttons
        return;
      }

      // Open action modal with existing data
      selectedNode = actionNode.id;
      openActionModal(actionNode.id);
      
      // Pre-populate the form
      const actionSelect = document.getElementById('action-select');
      if (actionSelect) {
        actionSelect.value = nodeData.data.type;
        renderActionProperties();
        
        // Set the selected tag if it's an Add Tag action
        if (nodeData.data.type === 'Add Tag' && nodeData.data.properties?.tag) {
          window.selectedActionTag = nodeData.data.properties.tag;
          const display = document.getElementById('action-tag-display');
          if (display) {
            display.textContent = ` ${nodeData.data.properties.tag}`;
            display.style.color = '#34D399';
          }
        }

        // Prefill Send Email fields when editing
        if (nodeData.data.type === 'Send Email' && nodeData.data.properties) {
          const p = nodeData.data.properties;
          const set = (id, val) => { const el = document.getElementById(id); if (el && val !== undefined && val !== null) el.value = val; };
          const manualEl = document.getElementById('email-manual-recipient');
          const toWrap = document.getElementById('email-to-wrapper');
          const manual = !(p.useTriggerRecipient === true || (!p.to || (Array.isArray(p.to) && p.to.length === 0)));
          if (manualEl) manualEl.checked = manual;
          if (toWrap) toWrap.style.display = manual ? 'block' : 'none';
          set('email-to', Array.isArray(p.to) ? p.to.join(', ') : (p.to || ''));
          set('email-cc', Array.isArray(p.cc) ? p.cc.join(', ') : (p.cc || ''));
          set('email-bcc', Array.isArray(p.bcc) ? p.bcc.join(', ') : (p.bcc || ''));
          set('email-subject', p.subject || '');
          const bodyEl = document.getElementById('email-body');
          if (bodyEl) bodyEl.value = p.body || '';
          const htmlEl = document.getElementById('email-is-html');
          if (htmlEl) htmlEl.checked = !!p.isHtml;
        }
      }
    }
    
    function deleteAction(actionNode) {
      if (!confirm('Are you sure you want to delete this action?')) return;
      
      const nodeData = nodes.find(n => n.element === actionNode);
      if (!nodeData) return;
      
      console.log('Deleting action node:', nodeData);
      
      // If deleting an IF node, cascade delete its True/False headers and branch actions
      try {
        if (nodeData.data && nodeData.data.type === 'If') {
          const ifId = nodeData.data.properties?.ifId;
          if (ifId) {
            const toRemove = nodes.filter(n => n.element !== actionNode && n.data && (
              ((n.data.type === 'True' || n.data.type === 'False') && n.data.properties?.parentIfId === ifId) ||
              (n.data.properties && n.data.properties.parentIfId === ifId)
            ));
            toRemove.forEach(n => {
              try { WorkflowManager.removeNodeConnections(n.element); } catch {}
              try { OrbManager.removeOrb(n.element); } catch {}
              if (n.element && n.element.parentNode) {
                n.element.remove();
              }
              const idx = nodes.findIndex(x => x.id === n.id);
              if (idx > -1) nodes.splice(idx, 1);
            });
            if (toRemove.length) console.log(`Cascaded delete of ${toRemove.length} IF-branch nodes for`, ifId);
          }
        }
      } catch (e) {
        console.warn('IF cascade delete warning:', e);
      }
      
      // Remove all connections involving this node
      WorkflowManager.removeNodeConnections(actionNode);
      
      // Remove the node's orb
      OrbManager.removeOrb(actionNode);
      
      // Remove the node from the DOM
      if (actionNode.parentNode) {
        actionNode.remove();
      }
      
      // Remove from nodes array
      const index = nodes.findIndex(n => n.element === actionNode);
      if (index > -1) {
        nodes.splice(index, 1);
        console.log('Removed node from array, remaining nodes:', nodes.length);
      }
      
      // Rebuild the entire workflow structure
      StructureManager.rebuild();
      
      // Update the workflow data
      updateWorkflowFromNodes();
      
      console.log('After delete - remaining nodes:', nodes.length);
      console.log('After delete - currentWorkflow.data:', currentWorkflow?.data);
    try { HistoryManager.recordSnapshot('deleteAction'); } catch {}
    }
    
    
    function validateWorkflowStructure() {
      try {
        // Check if we have a valid trigger
        const triggerNode = nodes.find(n => n.type === 'trigger');
        if (!triggerNode || !triggerNode.data || !triggerNode.data.type) {
          console.error('Invalid trigger node');
          return false;
        }
        
        // Check if trigger has required properties
        if (triggerNode.data.type === 'Meeting Scheduled' && (!triggerNode.data.properties?.eventTypes || triggerNode.data.properties.eventTypes.length === 0)) {
          console.error('Meeting Scheduled trigger requires event types');
          return false;
        }
        
        if (triggerNode.data.type === 'Tag Added' && (!triggerNode.data.properties?.tags || triggerNode.data.properties.tags.length === 0)) {
          console.error('Tag Added trigger requires tags');
          return false;
        }
        
        // Check if all action nodes have valid data
        const actionNodes = nodes.filter(n => n.type !== 'trigger');
        for (const actionNode of actionNodes) {
          if (!actionNode.data || !actionNode.data.type) {
            console.error('Invalid action node:', actionNode);
            return false;
          }
          
          // Check if Add Tag action has required properties
          if (actionNode.data.type === 'Add Tag' && (!actionNode.data.properties?.tag || actionNode.data.properties.tag === '')) {
            console.error('Add Tag action requires a tag');
            return false;
          }
        }
        // No End If/Else validation needed in True/False branching model

        console.log('Workflow structure validation passed');
        return true;
      } catch (error) {
        console.error('Error validating workflow structure:', error);
        return false;
      }
    }
    
    function updateWorkflowFromNodes() {
      // Rebuild the workflow steps array from current nodes
      const steps = [];
      
      nodes.forEach(node => {
        // Only add non-trigger nodes to steps array
        if (node.type !== 'trigger' && node.data) {
          steps.push(node.data);
        }
      });
      
      console.log('Updated workflow steps:', steps);
      console.log('Current nodes count:', nodes.length);
      console.log('Nodes:', nodes.map(n => ({ type: n.type, id: n.id })));
      
      // Update the current workflow data structure
      if (currentWorkflow) {
        const triggerNode = nodes.find(n => n.type === 'trigger');
        if (triggerNode && triggerNode.data) {
          currentWorkflow.data = {
            trigger: triggerNode.data.type,
            triggerEventTypes: triggerNode.data.properties?.eventTypes || [],
            triggerEventTypeIds: triggerNode.data.properties?.eventTypeIds || [],
            triggerTags: triggerNode.data.properties?.tags || [],
            steps: steps,
            status: true
          };
          console.log('Updated currentWorkflow.data:', currentWorkflow.data);
          } else {
          console.log('No trigger node found or no trigger data');
        }
      } else {
        console.log('No currentWorkflow to update');
      }
    }


    async function saveWorkflow() {
      console.log('=== SAVE WORKFLOW CALLED ===');
      const workflowNameInput = document.getElementById('workflow-name');
      const name = workflowNameInput.value.trim() || 'Untitled Workflow';
      
      if (nodes.length === 0) {
        alert('Please configure at least a trigger for your workflow');
        return;
      }
      
      const triggerNode = nodes.find(n => n.type === 'trigger');
      if (!triggerNode || !triggerNode.data) {
        alert('Please configure the trigger for your workflow');
        return;
      }
      
      // Validate workflow structure before saving
      if (!validateWorkflowStructure()) {
        alert('Workflow structure is invalid. Please check your configuration.');
        return;
      }
      
      // Always rebuild the workflow data from current nodes to ensure accuracy
      // Only include non-trigger nodes in steps array
      const steps = nodes
        .filter(node => node.type !== 'trigger')
        .map(node => node.data);
      
      console.log('Current nodes:', nodes);
      console.log('Mapped steps:', steps);
      
      // Prepare the workflow data structure - always use current node state
      const workflowData = {
        trigger: triggerNode.data.type,
        triggerEventTypes: triggerNode.data.properties?.eventTypes || [],
        triggerEventTypeIds: triggerNode.data.properties?.eventTypeIds || [],
        triggerTags: triggerNode.data.properties?.tags || [],
        steps: steps, // Include trigger in steps for consistency
        status: true,
        contextSpec: contextSpec || getDefaultContextSpec()
      };
      
      // Update currentWorkflow.data to match what we're saving
      if (currentWorkflow) {
        currentWorkflow.data = workflowData;
        console.log('Updated currentWorkflow.data before saving:', currentWorkflow.data);
      }
      
      console.log('Prepared workflow data for saving:', workflowData);
      
      console.log('Saving workflow with data:', workflowData);
      console.log('Trigger node data:', triggerNode.data);
      
      try {
                const token = getAnyToken();
      if (!token) {
          console.error('No token found');
          alert('Please log in to save workflows');
        return;
      }
      
        console.log('Token found, cleaning...');
        const clean = token.replace(/^"|"$/g, '');
        console.log('Token cleaned, length:', clean.length);
        
        if (currentWorkflow) {
          console.log('Updating existing workflow:', currentWorkflow.id);
          // Update existing workflow
          const updateData = {
            name,
            description: currentWorkflow.description || '',
            data: workflowData
          };
          console.log('Update data:', updateData);
          
          const res = await fetch(`${API_URL}/workflows/${currentWorkflow.id}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${clean}` },
            body: JSON.stringify(updateData)
          });
          
          console.log('Update response status:', res.status);
          
          if (res.ok) {
            console.log('Workflow updated successfully');
            localStorage.removeItem('calendarify-current-workflow');
            localStorage.setItem('calendarify-redirect-to', 'workflows');
            localStorage.setItem('calendarify-notification', 'Workflow updated successfully!');
            window.location.href = '/dashboard';
          } else {
            const errorData = await res.json();
            console.error('Failed to update workflow:', errorData);
            showNotification('Failed to update workflow', 'error');
          }
        } else {
          console.log('Creating new workflow...');
          // Create new workflow
          const createData = {
            name,
            description: '',
            data: workflowData
          };
          console.log('Create data:', createData);
          
          const res = await fetch(`${API_URL}/workflows`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${clean}` },
            body: JSON.stringify(createData)
          });
          
          console.log('Create response status:', res.status);
          
          if (res.ok) {
            const newWorkflow = await res.json();
            console.log('Workflow created successfully:', newWorkflow);
            localStorage.removeItem('calendarify-current-workflow');
            localStorage.setItem('calendarify-redirect-to', 'workflows');
            localStorage.setItem('calendarify-notification', 'Workflow created successfully!');
            window.location.href = '/dashboard';
          } else {
            const errorData = await res.json();
            console.error('Failed to create workflow:', errorData);
            showNotification('Failed to create workflow', 'error');
          }
        }
      } catch (error) {
        console.error('Error saving workflow:', error);
        showNotification('Failed to save workflow', 'error');
      }
    }

    // Close modals when clicking outside
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('modal-backdrop')) {
        e.target.classList.add('hidden');
      }
    });

    // Handle trigger type change
    document.getElementById('trigger-select').addEventListener('change', renderTriggerProperties);
    
    // Handle action type change
    document.getElementById('action-select').addEventListener('change', renderActionProperties);
    
    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Delete' && selectedNode) {
        deleteSelectedNode();
      } else if (e.key === 'Escape') {
        if (triggerModal.classList.contains('hidden') && actionModal.classList.contains('hidden')) {
          // Deselect node
          if (selectedNode) {
            selectedNode.classList.remove('selected');
            selectedNode = null;
          }
        } else {
          // Close modals
          closeTriggerModal();
          closeActionModal();
        }
      }
    });
    
    function deleteSelectedNode() {
      if (!selectedNode || selectedNode.type === 'trigger') return;
      // Delegate to main deletion flow to ensure cascading IF cleanup
      deleteAction(selectedNode);
    }
    
    // Add movement listeners to all nodes (simplified - no automatic updates)
    function addNodeMovementListeners() {
      const nodes = container.querySelectorAll('.flowchart-node');
      nodes.forEach(node => {
        // Remove any existing transition listeners that might cause issues
        node.removeEventListener('transitionend', () => {});
        // No automatic position updates - PositionManager handles stability
      });
    }
    
    // Loading screen functions
    function showLoadingScreen() {
      const loadingScreen = document.getElementById('workflow-loading-screen');
      if (loadingScreen) {
        loadingScreen.style.display = 'flex';
      }
    }

    function hideLoadingScreen() {
      const loadingScreen = document.getElementById('workflow-loading-screen');
      if (loadingScreen) {
        loadingScreen.style.display = 'none';
      }
    }

    // Production-grade position management system
    const PositionManager = {
      isInitialized: false,
      isUpdating: false,
      
      init() {
        if (this.isInitialized) return;
        this.isInitialized = true;
        
        // Disable all CSS transitions on connection lines and orbs
        this.disableProblematicTransitions();
        
        // Set up stable positioning system
        this.setupStablePositioning();
        
      console.log('[POS] PositionManager initialized');
      },
      
      disableProblematicTransitions() {
        // Remove all transitions from connection lines and orbs
        const style = document.createElement('style');
        style.textContent = `
          .connection-line,
          .add-action-orb,
          .insert-action-orb {
            transition: none !important;
            animation: none !important;
          }
          
          .flowchart-node {
            transition: box-shadow 0.2s, transform 0.2s !important;
          }
          
          .flowchart-node * {
            transition: none !important;
          }
        `;
        document.head.appendChild(style);
      },
      
      setupStablePositioning() {
        // Override the connection positioning to be completely stable
        this.originalUpdateConnectionPosition = WorkflowManager.updateConnectionPosition;
        WorkflowManager.updateConnectionPosition = this.stableUpdateConnectionPosition.bind(this);
        
        // Override orb positioning to be completely stable
        this.originalPositionOrbAtMidpoint = OrbManager.positionOrbAtMidpoint;
        OrbManager.positionOrbAtMidpoint = this.stablePositionOrbAtMidpoint.bind(this);
        
        this.originalPositionOrb = OrbManager.positionOrb;
        OrbManager.positionOrb = this.stablePositionOrb.bind(this);
      },
      
      stableUpdateConnectionPosition(connection) {
        if (!connection || !connection.line || !connection.from || !connection.to) {
        return;
      }
        
        try {
          const fromRect = connection.from.getBoundingClientRect();
          const toRect = connection.to.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          
          if (!fromRect || !toRect || !containerRect) {
          return;
        }
        
          // Calculate connection points (center bottom of from, center top of to)
          const fromX = Math.round(fromRect.left - containerRect.left + fromRect.width / 2);
          const fromY = Math.round(fromRect.bottom - containerRect.top - 1);
          const toX = Math.round(toRect.left - containerRect.left + toRect.width / 2);
          const toY = Math.round(toRect.top - containerRect.top + 1);

          // If using SVG path, draw an orthogonal rounded path; otherwise keep legacy div behavior
          const el = connection.line;
          if (el && el.tagName && el.tagName.toLowerCase() === 'path') {
            const fromType = (connection.from.__nodeData && connection.from.__nodeData.data?.type) || nodes.find(n=>n.element===connection.from)?.data?.type || '';
            const toType = (connection.to.__nodeData && connection.to.__nodeData.data?.type) || nodes.find(n=>n.element===connection.to)?.data?.type || '';
            connection.from.__nodeData = nodes.find(n => n.element === connection.from) || connection.from.__nodeData || null;
            connection.to.__nodeData = nodes.find(n => n.element === connection.to) || connection.to.__nodeData || null;

            let d = '';
            const vDrop = 30;
            const r = 12;
            // Always render lines targeting a join node with orthogonal rounded corners
            if (WorkflowManager.toNodeHasJoin && WorkflowManager.toNodeHasJoin(toType, connection)) {
              const vDropJoin = 56;
              const approachShorten = 14;
              const midY = fromY + vDropJoin;
              const dir = (toX >= fromX) ? 1 : -1;
              d += `M ${fromX} ${fromY}`;
              d += ` L ${fromX} ${midY - r}`;
              d += ` Q ${fromX} ${midY} ${fromX + dir * r} ${midY}`;
              d += ` L ${toX - dir * (r + approachShorten)} ${midY}`;
              d += ` Q ${toX} ${midY} ${toX} ${midY + r}`;
              d += ` L ${toX} ${toY}`;
              el.setAttribute('stroke-linecap', 'round');
              el.setAttribute('stroke-linejoin', 'round');
            } else if (fromType === 'If' && (toType === 'True' || toType === 'False')) {
              const midY = fromY + vDrop;
              d += `M ${fromX} ${fromY}`;
              d += ` L ${fromX} ${midY - r}`;
              const dir = (toX >= fromX) ? 1 : -1;
              d += ` Q ${fromX} ${midY} ${fromX + dir * r} ${midY}`;
              d += ` L ${toX - dir * r} ${midY}`;
              d += ` Q ${toX} ${midY} ${toX} ${midY + r}`;
              d += ` L ${toX} ${toY}`;
            } else if ((fromType === 'True' || fromType === 'False')) {
              if (WorkflowManager.isJoinNode && WorkflowManager.isJoinNode(connection.to)) {
                const midY = fromY + vDrop;
                const dir = (toX >= fromX) ? 1 : -1;
                d += `M ${fromX} ${fromY}`;
                d += ` L ${fromX} ${midY - r}`;
                d += ` Q ${fromX} ${midY} ${fromX + dir * r} ${midY}`;
                d += ` L ${toX - dir * r} ${midY}`;
                d += ` Q ${toX} ${midY} ${toX} ${midY + r}`;
                d += ` L ${toX} ${toY}`;
              } else if (!(toType === 'True' || toType === 'False')) {
                const ctrlY = fromY + 20;
                d = `M ${fromX} ${fromY} Q ${fromX} ${ctrlY} ${fromX} ${ctrlY} L ${toX} ${ctrlY} Q ${toX} ${ctrlY} ${toX} ${toY}`;
              } else {
                const mx = Math.round((fromX + toX) / 2);
                d = `M ${fromX} ${fromY} C ${mx} ${fromY}, ${mx} ${toY}, ${toX} ${toY}`;
              }
            } else {
              const mx = Math.round((fromX + toX) / 2);
              d = `M ${fromX} ${fromY} C ${mx} ${fromY}, ${mx} ${toY}, ${toX} ${toY}`;
            }
            el.setAttribute('d', d);
            el.style.display = 'block';
            if (DEBUG_LINE_PATHS) {
              const toIsJoin = (WorkflowManager.isJoinNode && WorkflowManager.isJoinNode(connection.to)) || false;
              console.log('[LINES/stable]', { fromId: connection.from.id, toId: connection.to.id, fromType, toType, fromX, fromY, toX, toY, toIsJoin, d });
            }
          } else {
            // Legacy fallback (div line rotated)
            const deltaX = toX - fromX;
            const deltaY = toY - fromY;
            const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const angle = Math.atan2(deltaY, deltaX);
            el.style.left = `${fromX}px`;
            el.style.top = `${fromY}px`;
            el.style.width = `${length}px`;
            el.style.transform = `rotate(${angle}rad)`;
            el.style.display = 'block';
          }
          connection.line.style.opacity = '1';
          
          // Update insert orb position if it exists
          this.updateInsertOrbPosition(connection);
          
      } catch (error) {
          console.error('Error in stable connection positioning:', error);
        }
      },
      
      stablePositionOrbAtMidpoint(orb, fromNode, toNode) {
        if (!orb || !fromNode || !toNode) {
          return;
        }
        
        try {
          const fromRect = fromNode.getBoundingClientRect();
          const toRect = toNode.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          
          if (!fromRect || !toRect || !containerRect) {
            return;
          }
          
          // Calculate connection points (exactly like connection lines)
          const fromX = Math.round(fromRect.left - containerRect.left + fromRect.width / 2);
          const fromY = Math.round(fromRect.bottom - containerRect.top - 1);
          const toX = Math.round(toRect.left - containerRect.left + toRect.width / 2);
          const toY = Math.round(toRect.top - containerRect.top + 1);
          
          // Calculate midpoint with pixel-perfect precision
          const midpointX = (fromX + toX) / 2;
          const midpointY = (fromY + toY) / 2;
          
          // Position orb at exact midpoint
          const finalLeft = Math.round(midpointX - 1); // 1px offset for visual centering
          const finalTop = Math.round(midpointY);
          
          orb.style.left = `${finalLeft}px`;
          orb.style.top = `${finalTop}px`;
          orb.style.transform = 'translate(-50%, -50%)';
          orb.style.opacity = '1';
          
        } catch (error) {
          // Fallback positioning
          orb.style.left = '50%';
          orb.style.top = '50%';
          orb.style.transform = 'translate(-50%, -50%)';
        }
      },
      
      stablePositionOrb(orb, node, position) {
        if (!orb || !node) {
          return;
        }
        
        try {
          const nodeRect = node.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          
          if (!nodeRect || !containerRect) {
            return;
          }
          
          // Calculate relative positions (same as original approach)
          const nodeLeft = nodeRect.left - containerRect.left;
          const nodeTop = nodeRect.top - containerRect.top;
          const nodeWidth = nodeRect.width;
          const nodeHeight = nodeRect.height;
          
          // Orb dimensions
          const orbSize = 40;
          const orbHalfSize = orbSize / 2;
          
          let finalLeft, finalTop;
          
          if (position === 'bottom') {
            // Center horizontally by subtracting half orb size (original approach)
            finalLeft = Math.round(nodeLeft + (nodeWidth / 2) - orbHalfSize);
            finalTop = Math.round(nodeTop + nodeHeight + 20); // 20px below the node
            orb.style.transform = 'scale(1)'; // No centering transform for bottom orbs
          } else if (position === 'top') {
            // Center horizontally by subtracting half orb size (original approach)
            finalLeft = Math.round(nodeLeft + (nodeWidth / 2) - orbHalfSize);
            finalTop = Math.round(nodeTop - orbSize - 20); // 20px above the node
            orb.style.transform = 'scale(1)'; // No centering transform for top orbs
          } else {
            // Default to bottom positioning
            finalLeft = Math.round(nodeLeft + (nodeWidth / 2) - orbHalfSize);
            finalTop = Math.round(nodeTop + nodeHeight + 20);
            orb.style.transform = 'scale(1)';
          }
          
          orb.style.left = `${finalLeft}px`;
          orb.style.top = `${finalTop}px`;
          orb.style.opacity = '1';
          
        } catch (error) {
          // Fallback positioning
          orb.style.left = '50%';
          orb.style.top = '50%';
          orb.style.transform = 'translate(-50%, -50%)';
        }
      },
      
      updateInsertOrbPosition(connection) {
        if (!connection.insertOrb) return;
        
        try {
          const fromRect = connection.from.getBoundingClientRect();
          const toRect = connection.to.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          
          if (!fromRect || !toRect || !containerRect) {
            return;
          }
          
          const fromX = Math.round(fromRect.left - containerRect.left + fromRect.width / 2);
          const fromY = Math.round(fromRect.bottom - containerRect.top - 1);
          const toX = Math.round(toRect.left - containerRect.left + toRect.width / 2);
          const toY = Math.round(toRect.top - containerRect.top + 1);
          
          const midpointX = (fromX + toX) / 2;
          const midpointY = (fromY + toY) / 2;
          
          connection.insertOrb.style.left = `${Math.round(midpointX)}px`;
          connection.insertOrb.style.top = `${Math.round(midpointY)}px`;
          connection.insertOrb.style.transform = 'translate(-50%, -50%)';
          
        } catch (error) {
          console.error('Error updating insert orb position:', error);
        }
      },
      
      // Clean up and restore original functions
      cleanup() {
        if (this.originalUpdateConnectionPosition) {
          WorkflowManager.updateConnectionPosition = this.originalUpdateConnectionPosition;
        }
        if (this.originalPositionOrbAtMidpoint) {
          OrbManager.positionOrbAtMidpoint = this.originalPositionOrbAtMidpoint;
        }
        if (this.originalPositionOrb) {
          OrbManager.positionOrb = this.originalPositionOrb;
        }
        this.isInitialized = false;
      }
    };

  // --- Persistent History (Undo/Redo up to 50) and Draft Autosave ---
  const HistoryManager = {
    maxSize: 50,
    stack: [],
    index: -1,
    workflowKey: null,
    lastSnapshotHash: null,
    isApplying: false,

    initForCurrentWorkflow() {
      const id = localStorage.getItem('calendarify-current-workflow');
      this.workflowKey = id ? String(id) : 'new-workflow';
      this.loadPersistent();
      // Seed initial snapshot from current UI state
      this.recordSnapshot('initial');
    },

    buildSnapshot() {
      // Serialize minimal UI state: name + trigger + steps
      const triggerNode = nodes.find(n => n.type === 'trigger');
      const triggerData = triggerNode?.data || null;
      const steps = nodes.filter(n => n.type !== 'trigger').map(n => n.data);
      let name = '';
      try { name = (document.getElementById('workflow-name')?.value || '').trim(); } catch {}
      return { meta: { name }, trigger: triggerData, steps };
    },

    applySnapshot(snapshot) {
      if (!snapshot) return;
      this.isApplying = true;
      try {
        // Clear current UI
        try {
          nodes.forEach(n => { try { if (n.element && n.element.parentNode) n.element.remove(); } catch {} });
          nodes = [];
          const existingOrbs = container.querySelectorAll('.add-action-orb, .insert-action-orb');
          existingOrbs.forEach(orb => orb.remove());
          const existingPaths = container.querySelectorAll('#connections-svg');
          existingPaths.forEach(p => p.remove());
          // Ensure WorkflowManager will recreate the SVG overlay on next draw
          try { WorkflowManager.svg = null; } catch {}
        } catch {}

        // Recreate trigger
        if (snapshot.trigger) {
          updateTriggerNode(snapshot.trigger);
        } else {
          createInitialTriggerNode();
        }

        // Recreate actions
        if (Array.isArray(snapshot.steps)) {
          snapshot.steps.forEach((step, idx) => {
            if (step && step.type !== 'trigger') {
              addActionNode(step, idx);
            }
          });
        }

        // Final rebuild (force re-init of WorkflowManager to recreate overlay if needed)
        try { WorkflowManager.init(); } catch {}
        StructureManager.rebuild();
      } finally {
        this.isApplying = false;
      }
    },

    hashSnapshot(snapshot) {
      try { return JSON.stringify(snapshot); } catch { return String(Date.now()); }
    },

    async recordSnapshot(reason = 'change') {
      if (this.isApplying) return;
      try { if (typeof isLoadingWorkflow !== 'undefined' && isLoadingWorkflow) return; } catch {}
      const snap = this.buildSnapshot();
      const hash = this.hashSnapshot(snap);
      if (hash === this.lastSnapshotHash) return; // ignore duplicates
      this.lastSnapshotHash = hash;

      // If we undid some, truncate forward history
      if (this.index < this.stack.length - 1) {
        this.stack = this.stack.slice(0, this.index + 1);
      }

      this.stack.push(snap);
      if (this.stack.length > this.maxSize) {
        this.stack.shift();
      } else {
        this.index++;
      }
      this.persist();
      if (reason !== 'initial') {
        await DraftManager.autosaveDraft(snap);
      }
    },

    undo() {
      if (this.index <= 0) return;
      this.index--;
      const snap = this.stack[this.index];
      this.persist();
      this.applySnapshot(snap);
    },

    redo() {
      if (this.index >= this.stack.length - 1) return;
      this.index++;
      const snap = this.stack[this.index];
      this.persist();
      this.applySnapshot(snap);
    },

    persist() {
      if (!this.workflowKey) return;
      const key = `calendarify-history-${this.workflowKey}`;
      const data = { stack: this.stack, index: this.index, last: this.lastSnapshotHash };
      try { localStorage.setItem(key, JSON.stringify(data)); } catch {}
    },

    loadPersistent() {
      if (!this.workflowKey) return;
      const key = `calendarify-history-${this.workflowKey}`;
      try {
        const raw = localStorage.getItem(key);
        if (raw) {
          const data = JSON.parse(raw);
          if (data && Array.isArray(data.stack)) {
            this.stack = data.stack;
            this.index = typeof data.index === 'number' ? data.index : data.stack.length - 1;
            this.lastSnapshotHash = data.last || null;
          }
        }
      } catch {}
    }
  };

  const DraftManager = {
    debounceTimer: null,
    debounceMs: 0,
    getDraftKey() {
      const id = localStorage.getItem('calendarify-current-workflow');
      const key = id ? `calendarify-draft-${id}` : 'calendarify-draft-new-workflow';
      return key;
    },
    // Display name mapping helpers
    setDisplayName(branchId, name) {
      try { localStorage.setItem(`calendarify-branch-name-${branchId}`, name || ''); } catch {}
    },
    getDisplayName(branchId) {
      try { return localStorage.getItem(`calendarify-branch-name-${branchId}`) || ''; } catch { return ''; }
    },
    getActiveDisplayName() {
      try { const lbl = document.getElementById('branch-current-label'); return (lbl && lbl.textContent) ? lbl.textContent.trim() : ''; } catch { return ''; }
    },
    async ensureDraftBranch(initialSnapshot) {
      const current = this.currentBranch();
      if (current && current !== 'main') return current;
      // Create stable branch id + human readable display name
      const branchId = `draft-${Date.now()}-${Math.random().toString(36).slice(2,8)}`;
      const name = `Draft ${new Date().toLocaleString(undefined, { dateStyle: 'medium', timeStyle: 'short' })}`;
      try {
        const id = localStorage.getItem('calendarify-current-workflow');
        const token = getAnyToken();
        if (!id || !token) return 'main';
        const clean = token.replace(/^"|"$/g, '');
        const seed = initialSnapshot || (typeof HistoryManager?.buildSnapshot === 'function' ? HistoryManager.buildSnapshot() : null);
        await fetch(`${API_URL}/workflows/${id}/drafts`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${clean}` },
          body: JSON.stringify({ branch: branchId, name, data: seed || {} }),
        });
        localStorage.setItem('calendarify-current-branch', branchId);
        try { const lbl = document.getElementById('branch-current-label'); if (lbl) lbl.textContent = name; } catch {}
        this.setDisplayName(branchId, name);
        return branchId;
      } catch {
        return 'main';
      }
    },
    async autosaveDraft(snapshot) {
      let branch = this.currentBranch();
      if (!branch || branch === 'main') {
        branch = await this.ensureDraftBranch(snapshot);
        if (!branch || branch === 'main') return;
      }
      try { localStorage.setItem(this.getDraftKey(), JSON.stringify({ snapshot, ts: Date.now() })); } catch {}
      try {
        const id = localStorage.getItem('calendarify-current-workflow');
        if (!id) return;
        const token = getAnyToken();
        if (!token) return;
        const clean = token.replace(/^"|"$/g, '');
        const displayName = this.getDisplayName(branch) || this.getActiveDisplayName();
        await fetch(`${API_URL}/workflows/${id}/drafts`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${clean}` },
          body: JSON.stringify({ branch, name: displayName || undefined, data: snapshot }),
        });
      } catch {}
    },
    currentBranch() {
      try { return localStorage.getItem('calendarify-current-branch') || 'main'; } catch { return 'main'; }
    },
    getDraft() {
      try {
        const raw = localStorage.getItem(this.getDraftKey());
        if (!raw) return null;
        return JSON.parse(raw);
      } catch { return null; }
    },
    clearDraft() {
      try { localStorage.removeItem(this.getDraftKey()); } catch {}
    },
    async checkAndOfferDraft() {
      const currentBranch = this.currentBranch();
      const draft = this.getDraft();
      let showBanner = false;
      try {
        const id = localStorage.getItem('calendarify-current-workflow');
        const token = getAnyToken();
        if (id && token) {
          const clean = token.replace(/^"|"$/g, '');
          const res = await fetch(`${API_URL}/workflows/${id}/draft-branches`, { headers: { Authorization: `Bearer ${clean}` } });
          const branches = res.ok ? await res.json() : [];
          try { refreshBranchMenu(branches); } catch {}
          if (currentBranch && currentBranch !== 'main') {
            // Compare latest server draft for current branch with current UI state
            try {
              const res2 = await fetch(`${API_URL}/workflows/${id}/drafts?branch=${encodeURIComponent(currentBranch)}`, { headers: { Authorization: `Bearer ${clean}` } });
              if (res2.ok) {
                const list = await res2.json();
                const serverSnap = (Array.isArray(list) && list.length > 0) ? list[0]?.data : null;
                const currentSnap = (typeof HistoryManager?.buildSnapshot === 'function') ? HistoryManager.buildSnapshot() : null;
                const eq = (a,b) => { try { return JSON.stringify(a) === JSON.stringify(b); } catch { return false; } };
                if (serverSnap && currentSnap && !eq(serverSnap, currentSnap)) showBanner = true;
              }
            } catch {}
          }
        }
      } catch {}
      // Also consider local draft only if different from current UI and on a draft branch
      if (!showBanner && currentBranch && currentBranch !== 'main' && draft && draft.snapshot) {
        const currentSnap = (typeof HistoryManager?.buildSnapshot === 'function') ? HistoryManager.buildSnapshot() : null;
        const eq = (a,b) => { try { return JSON.stringify(a) === JSON.stringify(b); } catch { return false; } };
        if (currentSnap && !eq(draft.snapshot, currentSnap)) showBanner = true;
      }
      if (!showBanner) return;
      let banner = document.getElementById('draft-banner');
      if (!banner) {
        banner = document.createElement('div');
        banner.id = 'draft-banner';
        banner.style.cssText = 'position:fixed;left:50%;top:12px;transform:translateX(-50%);background:#0f172a;color:#e2e8f0;padding:10px 14px;border-radius:8px;z-index:1000;display:flex;gap:10px;align-items:center;box-shadow:0 6px 18px rgba(0,0,0,0.25)';
        banner.innerHTML = '<span>Draft changes detected from a previous session.</span>'+
          '<button id="apply-draft" style="background:#34D399;color:#0b1320;border:none;padding:6px 10px;border-radius:6px;cursor:pointer">Apply Draft</button>'+
          '<button id="discard-draft" style="background:#334155;color:#e2e8f0;border:none;padding:6px 10px;border-radius:6px;cursor:pointer">Discard</button>';
        document.body.appendChild(banner);
        const apply = document.getElementById('apply-draft');
        const discard = document.getElementById('discard-draft');
        apply?.addEventListener('click', async () => {
          try {
            const id = localStorage.getItem('calendarify-current-workflow');
            const token = getAnyToken();
            if (id && token) {
              const clean = token.replace(/^"|"$/g, '');
              const branch = this.currentBranch() || 'main';
              const res = await fetch(`${API_URL}/workflows/${id}/drafts?branch=${encodeURIComponent(branch)}`, { headers: { Authorization: `Bearer ${clean}` } });
              let serverSnap = null;
              if (res.ok) {
                const drafts = await res.json();
                if (Array.isArray(drafts) && drafts.length > 0) serverSnap = drafts[0].data;
              }
              const snap = serverSnap || (draft && draft.snapshot);
              if (snap) HistoryManager.applySnapshot(snap);
            }
          } catch {}
          this.clearDraft();
          banner.remove();
        });
        discard?.addEventListener('click', () => { this.clearDraft(); banner.remove(); });
      }
    }
  };

  // Branch switcher wiring
  (function initBranchSwitcher(){
    const sel = null; // removed native select
    const btn = document.getElementById('create-branch-btn');
    const applyBtn = document.getElementById('apply-branch-to-main-btn');
    const triggerBtn = document.getElementById('branch-trigger');
    const menu = document.getElementById('branch-menu');
    const itemsRoot = document.getElementById('branch-items');
    const currentLabel = document.getElementById('branch-current-label');
    function refreshBranchMenu(branches = []) {
      if (!itemsRoot) return;
      itemsRoot.innerHTML = '';
      const seen = new Set();
      branches.forEach(b => {
        const branchId = b && b.branch;
        const displayName = (b && (b.name || b.branch)) || '';
        if (!branchId || branchId === 'main' || seen.has(branchId)) return;
        seen.add(branchId);
        const row = document.createElement('div');
        row.className = 'branch-item';
        row.dataset.branch = branchId;
        row.style.cssText = 'display:flex;align-items:center;justify-content:space-between;gap:12px;padding:10px 12px;border-radius:8px;cursor:pointer;max-width:100%;';
        const span = document.createElement('span');
        span.textContent = displayName;
        span.style.cssText = 'flex:1 1 auto;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;';
        const actionsWrap = document.createElement('div');
        actionsWrap.style.cssText = 'display:flex;gap:4px;align-items:center';
        const rename = document.createElement('button');
        rename.className = 'context-btn';
        rename.style.cssText = 'padding:2px 6px;height:24px;';
        rename.textContent = 'Rename';
        const del = document.createElement('button');
        del.className = 'context-btn';
        del.style.cssText = 'padding:2px 6px;height:24px;';
        del.textContent = 'Delete';
        actionsWrap.appendChild(rename);
        actionsWrap.appendChild(del);
        rename.addEventListener('click', async (e) => {
          e.stopPropagation();
          const newName = await themedPrompt(displayName, 'Rename Draft', 'Draft name');
          if (!newName || newName.trim() === displayName) return;
          try {
            const id = localStorage.getItem('calendarify-current-workflow');
            const token = getAnyToken();
            if (!id || !token) return;
            const clean = token.replace(/^"|"$/g, '');
            console.log('[DRAFT][UI] rename start', { branchId: row.dataset.branch, newName: newName.trim() });
            // Find newest draft (server returns newest first)
            const resFind = await fetch(`${API_URL}/workflows/${id}/drafts?branch=${encodeURIComponent(row.dataset.branch)}`, { headers: { Authorization: `Bearer ${clean}` } });
            const list = resFind.ok ? await resFind.json() : [];
            const latest = Array.isArray(list) && list.length ? list[0] : null;
            if (!latest) return;
            console.log('[DRAFT][UI] rename PATCH target', { draftId: latest.id });
            const res = await fetch(`${API_URL}/workflows/${id}/drafts/${latest.id}`, { method: 'PATCH', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${clean}` }, body: JSON.stringify({ name: newName.trim() }) });
            console.log('[DRAFT][UI] rename PATCH status', res.status);
            if (res.ok) {
              // Refresh branches to pull back saved names
              try {
                const resB = await fetch(`${API_URL}/workflows/${id}/draft-branches`, { headers: { Authorization: `Bearer ${clean}` } });
                const branches = resB.ok ? await resB.json() : [];
                console.log('[DRAFT][UI] refreshed branches', branches);
                refreshBranchMenu(branches);
                // Update the trigger label with the server display name
                const active = branches.find(b => b.branch === row.dataset.branch);
                if (active) {
                  const lbl = document.getElementById('branch-current-label');
                  if (lbl) lbl.textContent = (active.name || active.branch);
                  // Persist display name locally so autosaves keep it
                  try { DraftManager.setDisplayName(row.dataset.branch, (active.name || active.branch)); } catch {}
                }
              } catch {}
              // Update current label if active
            if (DraftManager.currentBranch() === row.dataset.branch) {
              const lbl = document.getElementById('branch-current-label'); if (lbl) lbl.textContent = newName.trim();
              }
              showNotification('Draft renamed');
            } else {
              showNotification('Failed to rename draft', 'error');
            }
          } catch { showNotification('Failed to rename draft', 'error'); }
        });
        del.addEventListener('click', async (e) => {
          e.stopPropagation();
          const branch = name;
          const ok = await themedConfirm(`Delete draft branch "${branch}"? This cannot be undone.`, 'Delete Draft');
          if (!ok) return;
          const originalAutosave = DraftManager.autosaveDraft; DraftManager.autosaveDraft = async () => {};
          try {
            const id = localStorage.getItem('calendarify-current-workflow');
            const token = getAnyToken();
            if (!id || !token) return;
            const clean = token.replace(/^"|"$/g, '');
            const res = await fetch(`${API_URL}/workflows/${id}/drafts?branch=${encodeURIComponent(branch)}`, { method: 'DELETE', headers: { Authorization: `Bearer ${clean}` } });
            if (res.ok) {
              showNotification('Draft branch deleted');
              row.remove();
              if (DraftManager.currentBranch() === branch) {
                localStorage.setItem('calendarify-current-branch', 'main');
                if (currentLabel) currentLabel.textContent = 'Main';
                await loadWorkflow();
              }
            } else {
              showNotification('Failed to delete draft branch', 'error');
            }
          } finally { DraftManager.autosaveDraft = originalAutosave; }
        });
        row.addEventListener('click', async () => {
          localStorage.setItem('calendarify-current-branch', branchId);
          if (currentLabel) currentLabel.textContent = displayName;
          if (menu) menu.style.display = 'none';
          setTimeout(async () => {
            try {
              const id = localStorage.getItem('calendarify-current-workflow');
              const token = getAnyToken();
              if (id && token) {
                const clean = token.replace(/^"|"$/g, '');
                const res = await fetch(`${API_URL}/workflows/${id}/drafts?branch=${encodeURIComponent(branchId)}`, { headers: { Authorization: `Bearer ${clean}` } });
                if (res.ok) {
                  const drafts = await res.json();
                  if (Array.isArray(drafts) && drafts.length > 0) {
                    HistoryManager.applySnapshot(drafts[0].data);
                    requestAnimationFrame(() => { try { LayoutManager.apply(); WorkflowManager.updateAllConnections(); OrbManager.updateAllOrbPositions(); } catch {} });
                  }
                }
              }
            } catch {}
          }, 0);
        });
        row.appendChild(span);
        row.appendChild(actionsWrap);
        itemsRoot.appendChild(row);
        // spacer
        const spacer = document.createElement('div');
        spacer.style.cssText = 'height:1px;background:#223A35;margin:4px 0;';
        itemsRoot.appendChild(spacer);
      });
    }

    if (triggerBtn) triggerBtn.addEventListener('click', async (e) => {
      e.stopPropagation();
      if (menu) menu.style.display = menu.style.display === 'none' || !menu.style.display ? 'block' : 'none';
      // Load branches when opening
      try {
        const id = localStorage.getItem('calendarify-current-workflow');
        const token = getAnyToken();
        if (id && token) {
          const clean = token.replace(/^"|"$/g, '');
          const res = await fetch(`${API_URL}/workflows/${id}/draft-branches`, { headers: { Authorization: `Bearer ${clean}` } });
          const branches = res.ok ? await res.json() : [];
          refreshBranchMenu(branches);
        }
      } catch {}
    });
    document.addEventListener('click', () => { if (menu) menu.style.display = 'none'; });
    // Handle selecting Main
    try {
      const mainItem = document.querySelector('#branch-menu .branch-item[data-branch="main"]');
      if (mainItem) mainItem.addEventListener('click', async () => {
        localStorage.setItem('calendarify-current-branch', 'main');
        if (currentLabel) currentLabel.textContent = 'Main';
        if (menu) menu.style.display = 'none';
        await loadWorkflow();
      });
    } catch {}
    if (btn) btn.addEventListener('click', async () => {
      const name = prompt('Enter new draft branch name');
      if (!name) return;
      try {
        const id = localStorage.getItem('calendarify-current-workflow');
        const token = getAnyToken();
        if (!id || !token) return;
        const clean = token.replace(/^"|"$/g, '');
        // Create an initial draft snapshot for the new branch from current UI state
        const snap = HistoryManager.buildSnapshot();
        await fetch(`${API_URL}/workflows/${id}/drafts`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${clean}` },
          body: JSON.stringify({ branch: name, data: snap }),
        });
        localStorage.setItem('calendarify-current-branch', name);
        // Refresh branch list
        await DraftManager.checkAndOfferDraft();
        // Switch to it
        if (currentLabel) currentLabel.textContent = name;
      } catch {}
    });
    if (applyBtn) applyBtn.addEventListener('click', async () => {
      const branch = DraftManager.currentBranch();
      if (!branch || branch === 'main') { showNotification('Select a draft branch first'); return; }
      try {
        const id = localStorage.getItem('calendarify-current-workflow');
        const token = getAnyToken();
        if (!id || !token) return;
        const clean = token.replace(/^"|"$/g, '');
        // Get latest draft in branch
        const res = await fetch(`${API_URL}/workflows/${id}/drafts?branch=${encodeURIComponent(branch)}`, { headers: { Authorization: `Bearer ${clean}` } });
        if (!res.ok) { showNotification('Failed to fetch drafts', 'error'); return; }
        const drafts = await res.json();
        if (!Array.isArray(drafts) || drafts.length === 0) { showNotification('No drafts to apply', 'error'); return; }
        const latest = drafts[0];
        const apply = await fetch(`${API_URL}/workflows/${id}/drafts/${latest.id}/apply`, { method: 'POST', headers: { Authorization: `Bearer ${clean}` } });
        if (apply.ok) {
          showNotification('Applied draft to Main');
          // After successful apply, delete the entire draft branch on server
          try {
            const del = await fetch(`${API_URL}/workflows/${id}/drafts?branch=${encodeURIComponent(branch)}`, { method: 'DELETE', headers: { Authorization: `Bearer ${clean}` } });
            if (del.ok) {
              // Remove local display name mapping
              try { localStorage.removeItem(`calendarify-branch-name-${branch}`); } catch {}
              // If branch menu is open, refresh it
              try {
                const resB = await fetch(`${API_URL}/workflows/${id}/draft-branches`, { headers: { Authorization: `Bearer ${clean}` } });
                const branches = resB.ok ? await resB.json() : [];
                if (Array.isArray(branches)) refreshBranchMenu(branches);
              } catch {}
            }
          } catch {}
          localStorage.setItem('calendarify-current-branch', 'main');
          if (currentLabel) currentLabel.textContent = 'Main';
          await loadWorkflow();
        } else {
          showNotification('Failed to apply draft', 'error');
        }
      } catch { showNotification('Failed to apply draft', 'error'); }
    });
    // legacy actions menu handlers removed after custom dropdown migration
  })();

  // Keyboard shortcuts for undo/redo
  document.addEventListener('keydown', (e) => {
    const isMac = navigator.platform.toUpperCase().includes('MAC');
    const mod = isMac ? e.metaKey : e.ctrlKey;
    if (!mod) return;
    if (e.key.toLowerCase() === 'z' && !e.shiftKey) { e.preventDefault(); HistoryManager.undo(); }
    if ((e.key.toLowerCase() === 'z' && e.shiftKey) || e.key.toLowerCase() === 'y') { e.preventDefault(); HistoryManager.redo(); }
  });

    // Initialize the workflow editor when the page loads
    document.addEventListener('DOMContentLoaded', async () => {
      try {
        console.log('[BOOT] Editor init');
        showLoadingScreen();
        
        // Initialize canvas
        initializeCanvas();
        
        // Load existing workflow if editing
        await loadWorkflow();

        // After workflow load, auto-select the newest edited draft if present
        try {
          const id = localStorage.getItem('calendarify-current-workflow');
          const token = getAnyToken();
          if (id && token) {
            const clean = token.replace(/^"|"$/g, '');
            const res = await fetch(`${API_URL}/workflows/${id}/draft-branches`, { headers: { Authorization: `Bearer ${clean}` } });
            if (res.ok) {
              const branches = await res.json();
              if (Array.isArray(branches) && branches.length > 0) {
                // Sort by updated_at desc if not already
                branches.sort((a,b) => new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime());
                const newest = branches.find(b => b.branch && b.branch !== 'main');
                if (newest && newest.branch) {
                  localStorage.setItem('calendarify-current-branch', newest.branch);
                  const lbl = document.getElementById('branch-current-label');
                  if (lbl) lbl.textContent = (newest.name || newest.branch);
                  // Load newest draft snapshot
                  try {
                    const res2 = await fetch(`${API_URL}/workflows/${id}/drafts?branch=${encodeURIComponent(newest.branch)}`, { headers: { Authorization: `Bearer ${clean}` } });
                    if (res2.ok) {
                      const list = await res2.json();
                      if (Array.isArray(list) && list.length > 0) {
                        HistoryManager.applySnapshot(list[0].data);
                        // Notify with auto-hide
                        showNotification(`Auto-selected latest draft: ${newest.branch}`);
                        setTimeout(() => {
                          const notif = document.querySelector('.notification.show, .fixed.top-4.right-4.z-50');
                          if (notif && notif.parentElement) try { notif.parentElement.removeChild(notif); } catch {}
                        }, 5000);
                      }
                    }
                  } catch {}
                }
              }
            }
          }
        } catch {}

        // Initialize history and drafts after initial load
        try { HistoryManager.initForCurrentWorkflow(); } catch {}
        // Since we auto-select the newest draft, suppress the old mismatch banner
        try { /* DraftManager.checkAndOfferDraft(); */ } catch {}
        
        // Create initial trigger node if no workflow loaded
        if (nodes.length === 0) {
          createInitialTriggerNode();
        }
        
        // Add movement listeners
        addNodeMovementListeners();
        
        // Initialize production-grade position management system
        PositionManager.init();
        
        // Preload errors if an id is present
        try { await refreshErrors(); } catch {}
        try { await refreshRuns(); } catch {}

        // After fonts and layout settle, do a final alignment pass
        const settle = () => {
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              refreshStructure();
            });
          });
        };
        if (document.fonts && document.fonts.ready) {
          document.fonts.ready.then(settle).catch(settle);
        } else {
          settle();
        }
        
        console.log('[BOOT] Editor ready');
      } catch (error) {
        console.error('[BOOT] Init error:', error);
        hideLoadingScreen();
      }
    });

    // Cleanup position manager when page is unloaded
    window.addEventListener('beforeunload', () => {
      PositionManager.cleanup();
    });

    // Keep layout fresh on resize
    window.addEventListener('resize', () => {
      StructureManager.rebuild();
    });

  // Errors panel logic
    async function refreshErrors(limit = 25) {
      const id = localStorage.getItem('calendarify-current-workflow');
      if (!id) return [];
      try {
        const token = getAnyToken();
        if (!token) return [];
        const clean = token.replace(/^"|"$/g, '');
        const res = await fetch(`${API_URL}/workflows/${id}/errors?limit=${limit}`, {
          headers: { Authorization: `Bearer ${clean}` }
        });
        if (!res.ok) return [];
        const items = await res.json();
        renderErrors(items || []);
        return items;
      } catch (e) {
        console.warn('Failed to load workflow errors', e);
        return [];
  }

  // Branch helpers (defined after DOM and utils)
    function findIfHeaders(ifNodeId) {
      const idx = nodes.findIndex(n => n.id === ifNodeId || n.element?.id === ifNodeId);
      let trueIndex = -1, falseIndex = -1;
      if (idx >= 0) {
        for (let i = idx + 1; i < nodes.length; i++) {
          const t = nodes[i]?.data?.type;
          if (t === 'True' && trueIndex === -1) trueIndex = i;
          if (t === 'False') { falseIndex = i; break; }
        }
      }
      return { ifIndex: idx, trueIndex, falseIndex };
    }

  function decorateIfNodeForBranches(actionNodeEl) {
    const content = actionNodeEl.querySelector('.node-content');
    if (!content) return;
    const existing = content.querySelector('.branch-controls');
    if (existing) existing.remove();
    const controls = document.createElement('div');
    controls.className = 'branch-controls';
    controls.style.marginTop = '.5rem';
    controls.style.display = 'flex';
    controls.style.gap = '.5rem';
    controls.innerHTML = `
      <button class="context-btn" title="Add to TRUE path">+ True path</button>
      <button class="context-btn" title="Add to FALSE path">+ False path</button>
    `;
    const [btnTrue, btnFalse] = controls.querySelectorAll('button');
    btnTrue.addEventListener('click', (e) => { e.stopPropagation(); openActionModal(`branch-true-${actionNodeEl.id}`); });
    btnFalse.addEventListener('click', (e) => { e.stopPropagation(); openActionModal(`branch-false-${actionNodeEl.id}`); });
    content.appendChild(controls);
  }
    }

    // Runs panel logic
    const contactCache = new Map();
    const bookingCache = new Map();

    async function fetchContact(contactId) {
      if (!contactId) return null;
      if (contactCache.has(contactId)) return contactCache.get(contactId);
      try {
        const token = getAnyToken();
        const clean = token.replace(/^"|"$/g, '');
        const res = await fetch(`${API_URL}/contacts/${contactId}`, { headers: { Authorization: `Bearer ${clean}` } });
        if (!res.ok) return null;
        const data = await res.json();
        contactCache.set(contactId, data);
        return data;
      } catch { return null; }
    }

    async function fetchBooking(bookingId) {
      if (!bookingId) return null;
      if (bookingCache.has(bookingId)) return bookingCache.get(bookingId);
      try {
        const token = getAnyToken();
        const clean = token.replace(/^"|"$/g, '');
        const res = await fetch(`${API_URL}/bookings/${bookingId}`, { headers: { Authorization: `Bearer ${clean}` } });
        if (!res.ok) return null;
        const data = await res.json();
        bookingCache.set(bookingId, data);
        return data;
      } catch { return null; }
    }

    async function refreshRuns(limit = 50) {
      const id = localStorage.getItem('calendarify-current-workflow');
      if (!id) return [];
      try {
        const token = getAnyToken();
        if (!token) return [];
        const clean = token.replace(/^"|"$/g, '');
        const res = await fetch(`${API_URL}/workflows/${id}/runs?limit=${limit}`, { headers: { Authorization: `Bearer ${clean}` } });
        if (!res.ok) return [];
        const items = await res.json();
        await renderRuns(items || []);
        return items;
      } catch { return []; }
    }

    function toggleRunsPanel() {
      if (!runsDrawer) return;
      const isOpen = runsDrawer.style.display !== 'none';
      runsDrawer.style.display = isOpen ? 'none' : 'block';
      if (!isOpen) refreshRuns();
    }

    async function renderRuns(items) {
      if (!runsActive || !runsHistory) return;
      runsActive.innerHTML = '';
      runsHistory.innerHTML = '';
      const active = items.filter(r => r.status === 'running');
      const past = items.filter(r => r.status !== 'running');

      const section = async (list, container, title) => {
        const header = document.createElement('div');
        header.style.color = '#9ca3af';
        header.style.fontWeight = '600';
        header.style.margin = '0.25rem 0 0.5rem';
        header.textContent = title;
        container.appendChild(header);
        if (list.length === 0) {
          const empty = document.createElement('div');
          empty.style.color = '#9ca3af';
          empty.textContent = 'None';
          container.appendChild(empty);
          return;
        }
        for (const run of list) {
          const row = document.createElement('div');
          row.style.border = '1px solid #263a35';
          row.style.borderRadius = '.5rem';
          row.style.padding = '.75rem';
          row.style.background = '#10231f';
          row.style.cursor = 'pointer';

          const whoEl = document.createElement('div');
          whoEl.style.color = '#E0E0E0';
          whoEl.style.fontWeight = '600';
          whoEl.textContent = 'Resolving participant';

          // Resolve participant
          const ctx = run.context || {};
          let who = 'Unknown participant';
          try {
            if (ctx.contactId) {
              const c = await fetchContact(ctx.contactId);
              if (c) who = `${c.name || c.email} (${c.email})`;
            } else if (ctx.bookingId) {
              const b = await fetchBooking(ctx.bookingId);
              if (b) who = `${b.name || b.email} (${b.email})`;
            }
          } catch {}
          whoEl.textContent = who;

          const meta = document.createElement('div');
          meta.style.color = '#9ca3af';
          meta.style.fontSize = '.85rem';
          const start = new Date(run.started_at || run.startedAt || run.startedAtUtc || Date.now());
          const end = run.finished_at ? new Date(run.finished_at) : null;
          const dur = end ? `  ${Math.max(0, Math.round((+end - +start)/1000))}s` : '';
          meta.textContent = `${run.status.toUpperCase()}  ${formatTime(start)}${dur}`;

          row.appendChild(whoEl);
          row.appendChild(meta);

          row.addEventListener('click', async () => {
            await showRunDetails(run.id);
          });

          container.appendChild(row);
        }
      };

      await section(active, runsActive, 'Currently Active');
      await section(past, runsHistory, 'History');
    }

    async function showRunDetails(runId) {
      const id = localStorage.getItem('calendarify-current-workflow');
      if (!id) return;
      try {
        const token = getAnyToken();
        const clean = token.replace(/^"|"$/g, '');
        const res = await fetch(`${API_URL}/workflows/${id}/runs/${runId}`, { headers: { Authorization: `Bearer ${clean}` } });
        if (!res.ok) return;
        const data = await res.json();
        renderRunDetails(data);
      } catch {}
    }

    function renderRunDetails(run) {
      if (!runDetails) return;
      runDetails.style.display = 'block';
      runDetails.innerHTML = '';

      const title = document.createElement('div');
      title.style.color = '#E0E0E0';
      title.style.fontWeight = '700';
      title.style.margin = '0.5rem 0';
      title.textContent = `Run ${run.id}  ${String(run.status).toUpperCase()}`;
      runDetails.appendChild(title);

      const list = document.createElement('div');
      list.style.display = 'flex';
      list.style.flexDirection = 'column';
      list.style.gap = '.5rem';

      (run.steps || []).forEach((step) => {
        const row = document.createElement('div');
        row.style.border = '1px solid #263a35';
        row.style.borderRadius = '.5rem';
        row.style.padding = '.5rem .75rem';
        row.style.background = '#0e201c';
        row.innerHTML = `
          <div style="display:flex;align-items:center;gap:.5rem;">
            <div style="color:#E0E0E0;font-weight:600;">Step ${Number(step.index)+1}: ${escapeHtml(step.type)}</div>
            <div style="margin-left:auto;color:#9ca3af; font-size:.85rem;">${(step.status || '').toUpperCase()}</div>
          </div>
          ${step.message ? `<div style=\"margin-top:.25rem;color:#d1d5db;white-space:pre-wrap;\">${escapeHtml(step.message)}</div>` : ''}
        `;
        row.addEventListener('click', () => highlightStep(Number(step.index)));
        list.appendChild(row);
      });
      runDetails.appendChild(list);
    }

    function toggleErrorsPanel() {
      if (!errorsDrawer) return;
      const isOpen = errorsDrawer.style.display !== 'none';
      errorsDrawer.style.display = isOpen ? 'none' : 'block';
      if (!isOpen) refreshErrors();
    }

    function renderErrors(items) {
      if (!errorsList) return;
      errorsList.innerHTML = '';
      if (!items || items.length === 0) {
        const empty = document.createElement('div');
        empty.style.color = '#9ca3af';
        empty.textContent = 'No recent errors.';
        errorsList.appendChild(empty);
        return;
      }
      const sorted = items.sort((a,b)=>b.ts-a.ts);
      sorted.forEach(err => {
        const row = document.createElement('div');
        row.style.border = '1px solid #263a35';
        row.style.borderRadius = '.5rem';
        row.style.padding = '.75rem';
        row.style.background = '#10231f';
        row.style.cursor = 'pointer';
        row.innerHTML = `
          <div style="display:flex;align-items:center;gap:.5rem;">
            <span class="material-icons-outlined" style="color:#F87171;font-size:18px">error</span>
            <div style="color:#E0E0E0;font-weight:600;">Step ${Number(err.stepIndex)+1}: ${escapeHtml(err.stepType || 'Unknown')}</div>
            <div style="margin-left:auto;color:#9ca3af;font-size:.85rem;">${formatTime(err.ts)}</div>
          </div>
          <div style="margin-top:.5rem;color:#d1d5db; white-space:pre-wrap;">${escapeHtml(err.message || '')}</div>
        `;
        row.addEventListener('click', () => {
          try { highlightStep(Number(err.stepIndex)); } catch {}
        });
        errorsList.appendChild(row);
      });
    }

    function highlightStep(stepIndex) {
      if (isNaN(stepIndex)) return;
      // Steps do not include the trigger; find action nodes in order
      const actionNodes = nodes.filter(n => n.type !== 'trigger');
      if (stepIndex < 0 || stepIndex >= actionNodes.length) return;
      const node = actionNodes[stepIndex]?.element;
      if (!node) return;
      // Select and scroll into view
      container.querySelectorAll('.flowchart-node').forEach(n => n.classList.remove('selected'));
      node.classList.add('selected');
      node.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    function formatTime(ts) {
      try { return new Date(ts).toLocaleString(); } catch { return String(ts); }
    }

    function escapeHtml(s) {
      return String(s)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    // Autosave on name changes (debounced)
    (function initNameAutosave(){
      try {
        const el = document.getElementById('workflow-name');
        if (!el) return;
        let t = null;
        el.addEventListener('input', () => {
          clearTimeout(t);
          t = setTimeout(() => { try { HistoryManager.recordSnapshot('name-change'); } catch {} }, 300);
        });
      } catch {}
    })();
  </script>
</body>
</html>
