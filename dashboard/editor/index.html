<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Workflow Editor - Calendarify</title>
  <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined" rel="stylesheet" />
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #1A2E29;
      color: #E0E0E0;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    .workflow-editor {
      display: flex;
      height: 100vh;
      width: 100vw;
    }

    .toolbar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      background: #1E3A34;
      border-bottom: 1px solid #2C4A43;
      padding: 1rem;
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .workflow-name-input {
      background: #1E3A34 !important;
      border: 1px solid #2C4A43 !important;
      border-radius: 0.5rem;
      padding: 0.75rem 1rem;
      color: #E0E0E0 !important;
      width: 300px;
      font-size: 0.875rem;
      transition: all 0.2s;
    }
    
    .workflow-name-input:focus {
      outline: none;
      border-color: #34D399;
      box-shadow: 0 0 0 3px rgba(52, 211, 153, 0.1);
    }
    
    .workflow-name-input::placeholder {
      color: #A3B3AF;
    }

    .save-btn {
      background: #34D399;
      color: #ffffff;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      font-weight: 600;
      border: none;
      cursor: pointer;
      transition: all 0.2s;
    }

    .save-btn:hover {
      background: #10b981;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(52, 211, 153, 0.3);
    }

    .context-btn {
      background: #111827;
      color: #E0E0E0;
      padding: 0.5rem 0.875rem;
      border-radius: 0.5rem;
      font-weight: 500;
      border: 1px solid #374151;
      cursor: pointer;
      transition: all 0.2s;
    }

    .context-btn:hover {
      background: #1f2937;
      border-color: #4b5563;
    }

    .flowchart-canvas {
      flex: 1;
      background: #1a1a1a;
      position: relative;
      overflow: auto;
      cursor: grab;
      margin-top: 80px;
      scrollbar-width: thin;
      scrollbar-color: #374151 #1a1a1a;
    }
    
    .flowchart-canvas::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    
    .flowchart-canvas::-webkit-scrollbar-track {
      background: #1a1a1a;
    }
    
    .flowchart-canvas::-webkit-scrollbar-thumb {
      background: #374151;
      border-radius: 4px;
    }
    
    .flowchart-canvas::-webkit-scrollbar-thumb:hover {
      background: #34D399;
    }

    .flowchart-canvas:active {
      cursor: grabbing;
    }

    .flowchart-container {
      min-width: 100%;
      min-height: 100%;
      padding: 2rem;
      position: relative;
    }

    .flowchart-node {
      position: absolute;
      background: #1E3A34;
      border: 2px solid #2C4A43;
      border-radius: 0.75rem;
      padding: 1rem;
      width: 320px;
      box-sizing: border-box;
      cursor: pointer;
      transition: all 0.2s;
      z-index: 10;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);
    }

    .flowchart-node:hover {
      border-color: #34D399;
      box-shadow: 0 10px 15px -3px rgba(52, 211, 153, 0.3), 0 4px 6px -2px rgba(52, 211, 153, 0.2);
      /* Preserve horizontal centering while adding subtle vertical lift */
      transform: translate(-50%, -2px);
    }

    .flowchart-node.trigger {
      background: linear-gradient(135deg, #1E3A34 0%, #19342e 100%);
      border-color: #34D399;
      border-width: 3px;
    }
    
    .flowchart-node.trigger::after {
      content: 'Click to configure';
      position: absolute;
      bottom: -25px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.75rem;
      color: #34D399;
      font-weight: 500;
      white-space: nowrap;
    }
    
    .flowchart-node.trigger.configured::after {
      display: none;
    }

    .flowchart-node.action {
      background: linear-gradient(135deg, #1E3A34 0%, #223c36 100%);
      border-color: #2C4A43;
    }

    .flowchart-node.selected {
      border-color: #34D399;
      box-shadow: 0 0 25px rgba(52, 211, 153, 0.5);
    }

    .node-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
      position: relative;
    }
    
    .node-actions {
      display: flex;
      gap: 0.25rem;
      margin-left: auto;
    }
    
    .node-action-btn {
      background: none;
      border: none;
      color: #A3B3AF;
      cursor: pointer;
      padding: 0.25rem;
      border-radius: 0.25rem;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .node-action-btn:hover {
      background: rgba(52, 211, 153, 0.1);
      color: #34D399;
    }
    
    .node-action-btn .material-icons-outlined {
      font-size: 1rem;
    }

    .node-icon {
      color: #34D399;
      font-size: 1.25rem;
    }

    .node-title {
      font-weight: 600;
      color: #E0E0E0;
      font-size: 0.9rem;
    }

    .node-content {
      color: #A3B3AF;
      font-size: 0.8rem;
      line-height: 1.4;
    }

    .connection-line {
      position: absolute;
      background: #2C4A43;
      z-index: 5;
      height: 2px;
      transform-origin: 0 0;
    }

    .connection-line:hover {
      background: #34D399;
      box-shadow: 0 0 10px rgba(52, 211, 153, 0.5);
    }

    .add-action-orb {
      position: absolute;
      width: 40px;
      height: 40px;
      background: #34D399;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 15;
      box-shadow: 0 4px 12px rgba(52, 211, 153, 0.3);
    }

    .add-action-orb:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 20px rgba(52, 211, 153, 0.5);
    }

    .add-action-orb .material-icons-outlined {
      color: #1A2E29;
      font-size: 1.25rem;
    }

    .insert-action-orb {
      position: absolute;
      width: 32px;
      height: 32px;
      background: linear-gradient(135deg, #34D399 0%, #10B981 100%);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 25;
      box-shadow: 0 3px 8px rgba(52, 211, 153, 0.3);
      border: 2px solid rgba(255, 255, 255, 0.1);
    }

    .insert-action-orb:hover {
      transform: scale(1.1);
      box-shadow: 0 4px 12px rgba(52, 211, 153, 0.5);
    }

    .insert-action-orb .material-icons-outlined {
      color: #1A2E29;
      font-size: 1rem;
    }

    .modal-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .workflow-loading-screen {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #1a1a1a;
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1rem;
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid #374151;
      border-top: 3px solid #34D399;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .loading-text {
      color: #A3B3AF;
      font-size: 0.875rem;
      font-weight: 500;
    }

    .modal {
      background: #374151;
      border: 1px solid #4b5563;
      border-radius: 0.75rem;
      padding: 1.5rem;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
    }

    .modal-header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid #4b5563;
    }

    .modal-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: #E0E0E0;
    }

    .modal-close {
      margin-left: auto;
      background: none;
      border: none;
      color: #A3B3AF;
      cursor: pointer;
      padding: 0.25rem;
      border-radius: 0.25rem;
      transition: all 0.2s;
    }

    .modal-close:hover {
      color: #E0E0E0;
      background: #19342e;
    }

    .form-group {
      margin-bottom: 1rem;
    }

    .form-label {
      display: block;
      color: #A3B3AF;
      font-size: 0.875rem;
      margin-bottom: 0.5rem;
    }

    .form-select {
      width: 100%;
      background: #1E3A34 !important;
      border: 1px solid #2C4A43 !important;
      border-radius: 0.5rem;
      padding: 0.75rem;
      color: #E0E0E0 !important;
      font-size: 0.875rem;
      transition: all 0.2s;
    }

    .form-select:focus {
      outline: none;
      border-color: #34D399;
      box-shadow: 0 0 0 3px rgba(52, 211, 153, 0.1);
    }
    
    .form-select option {
      background: #1E3A34;
      color: #E0E0E0;
    }
    
    /* Ensure all form elements use dark theme */
    select.form-select {
      background: #1E3A34 !important;
      color: #E0E0E0 !important;
    }
    
    select.form-select option {
      background: #1E3A34 !important;
      color: #E0E0E0 !important;
    }
    
    /* Override browser defaults for select elements */
    select {
      background: #1E3A34 !important;
      color: #E0E0E0 !important;
    }
    
    select option {
      background: #1E3A34 !important;
      color: #E0E0E0 !important;
    }

    .multi-select {
      position: relative;
      width: 100%;
    }

    .multi-select-button {
      background: #1E3A34;
      border: 1px solid #2C4A43;
      border-radius: 0.5rem;
      padding: 0.75rem;
      color: #E0E0E0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      cursor: pointer;
      transition: all 0.2s;
    }

    .multi-select-button:hover {
      border-color: #34D399;
      background: #2C4A43;
    }

    .multi-select-options {
      position: absolute;
      left: 0;
      top: 100%;
      margin-top: 0.25rem;
      width: 100%;
      background: #1E3A34;
      border: 1px solid #2C4A43;
      border-radius: 0.5rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.2);
      z-index: 50;
      max-height: 200px;
      overflow-y: auto;
      display: none;
      padding: 0.5rem 0;
    }

    .multi-select-options.show {
      display: block;
    }

    .multi-select-option {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem;
      color: #E0E0E0;
      cursor: pointer;
      transition: all 0.2s;
      border-radius: 0.25rem;
      margin: 0 0.5rem;
    }

    .multi-select-option:hover {
      background: #2C4A43;
    }

    .multi-select-option input[type="checkbox"] {
      width: 1rem;
      height: 1rem;
      accent-color: #34D399;
    }

    .select-all-btn {
      background: #34D399;
      color: #ffffff;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      font-size: 0.875rem;
      font-weight: 500;
      border: none;
      cursor: pointer;
      transition: all 0.2s;
      margin: 0.5rem;
    }

    .select-all-btn:hover {
      background: #10b981;
      transform: translateY(-1px);
    }

    .modal-actions {
      display: flex;
      gap: 1rem;
      justify-content: flex-end;
      margin-top: 2rem;
      padding-top: 1rem;
      border-top: 1px solid #4b5563;
    }

    .btn-secondary {
      background: #6b7280;
      color: #E0E0E0;
      padding: 0.75rem 1.5rem;
      border-radius: 0.5rem;
      font-weight: 500;
      border: 1px solid #6b7280;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-secondary:hover {
      background: #4b5563;
      color: #E0E0E0;
    }

    .btn-primary {
      background: #34D399;
      color: #ffffff;
      padding: 0.75rem 1.5rem;
      border-radius: 0.5rem;
      font-weight: 600;
      border: none;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-primary:hover {
      background: #10b981;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(52, 211, 153, 0.3);
    }

    .btn-primary:disabled {
      background: #94a3b8;
      cursor: not-allowed;
      opacity: 0.6;
    }

    .coming-soon {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .coming-soon .form-select {
      cursor: not-allowed;
    }

    .coming-soon-badge {
      background: #f59e0b;
      color: white;
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.75rem;
      margin-left: 0.5rem;
      font-weight: 500;
    }

    /* Notification styles */
    .notification {
      position: fixed;
      top: 1rem;
      right: 1rem;
      z-index: 9999;
      padding: 1rem;
      border-radius: 0.5rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
      min-width: 300px;
      transform: translateX(100%);
      transition: transform 0.3s ease-in-out;
    }

    .notification.show {
      transform: translateX(0);
    }

    .notification.success {
      background: #34D399;
      color: white;
    }

    .notification.error {
      background: #EF4444;
      color: white;
    }
  </style>
</head>
<body>
  <div class="workflow-editor">
    <!-- Toolbar -->
    <div class="toolbar">
      <input type="text" id="workflow-name" class="workflow-name-input" placeholder="Enter workflow name...">
      <div style="display:flex;gap:.5rem;align-items:center">
        <a href="/editor/guide" target="_blank" class="save-btn" style="background:#12221E;border:1px solid #2C4A43;color:#E0E0E0;text-decoration:none;display:inline-flex;align-items:center;gap:.35rem">
          <span class="material-icons-outlined" style="font-size:18px;color:#A3B3AF">menu_book</span>
          Guide
        </a>
        <button id="save-workflow" class="save-btn" onclick="saveWorkflow()">Save Workflow</button>
      </div>
      <button id="open-context" class="context-btn" onclick="openContextModal()">Context</button>
      <button id="open-errors" class="context-btn" onclick="toggleErrorsPanel()">Errors</button>
      <button id="open-runs" class="context-btn" onclick="toggleRunsPanel()">Runs</button>
    </div>

    <!-- Flowchart Canvas -->
    <div class="flowchart-canvas" id="flowchart-canvas">
      <div class="workflow-loading-screen" id="workflow-loading-screen">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading workflow...</div>
        </div>
      <div class="flowchart-container" id="flowchart-container">
        <!-- Trigger node will be added here -->
      </div>
      
      <!-- Errors Drawer -->
      <div id="errors-drawer" style="position:absolute; right:0; top:0; bottom:0; width:420px; background:#0b1715; border-left:1px solid #2C4A43; display:none; z-index:200; padding:1rem; overflow:auto;">
        <div style="display:flex;align-items:center;gap:.5rem; margin-bottom:.75rem;">
          <span class="material-icons-outlined" style="color:#F87171">error</span>
          <div style="font-weight:600;color:#E0E0E0">Latest Workflow Errors</div>
          <div style="margin-left:auto; display:flex; gap:.5rem;">
            <button class="context-btn" onclick="refreshErrors()">Refresh</button>
            <button class="context-btn" onclick="toggleErrorsPanel()">Close</button>
          </div>
        </div>
        <div id="errors-list" style="display:flex; flex-direction:column; gap:.75rem;"></div>
      </div>
      
      <!-- Runs Drawer -->
      <div id="runs-drawer" style="position:absolute; right:0; top:0; bottom:0; width:480px; background:#0b1715; border-left:1px solid #2C4A43; display:none; z-index:200; padding:1rem; overflow:auto;">
        <div style="display:flex;align-items:center;gap:.5rem; margin-bottom:.75rem;">
          <span class="material-icons-outlined" style="color:#60A5FA">timeline</span>
          <div style="font-weight:600;color:#E0E0E0">Workflow Runs</div>
          <div style="margin-left:auto; display:flex; gap:.5rem;">
            <button class="context-btn" onclick="refreshRuns()">Refresh</button>
            <button class="context-btn" onclick="toggleRunsPanel()">Close</button>
          </div>
        </div>
        <div id="runs-active" style="margin-bottom:1rem;"></div>
        <div id="runs-history"></div>
        <div id="run-details" style="margin-top:1rem; display:none;"></div>
      </div>
    </div>
  </div>

  <!-- Trigger Modal -->
  <div id="trigger-modal" class="modal-backdrop hidden">
    <div class="modal">
      <div class="modal-header">
        <span class="material-icons-outlined node-icon">play_circle</span>
        <h3 class="modal-title">Configure Trigger</h3>
        <button class="modal-close" onclick="closeTriggerModal()">
          <span class="material-icons-outlined">close</span>
        </button>
      </div>
      
      <div class="form-group">
        <label class="form-label">Trigger Type</label>
        <select id="trigger-select" class="form-select">
          <option value="Meeting Scheduled">Meeting Scheduled</option>
          <option value="Tag Added">Tag Added</option>
          <option value="Attendee Rescheduled" disabled class="coming-soon">Attendee Rescheduled <span class="coming-soon-badge">Coming Soon</span></option>
          <option value="Host Rescheduled" disabled class="coming-soon">Host Rescheduled <span class="coming-soon-badge">Coming Soon</span></option>
          <option value="Attendee Canceled" disabled class="coming-soon">Attendee Canceled <span class="coming-soon-badge">Coming Soon</span></option>
          <option value="Host Canceled" disabled class="coming-soon">Host Canceled <span class="coming-soon-badge">Coming Soon</span></option>
          <option value="Meeting Ended" disabled class="coming-soon">Meeting Ended <span class="coming-soon-badge">Coming Soon</span></option>
        </select>
      </div>

      <div id="trigger-properties"></div>

      <div class="modal-actions">
        <button class="btn-secondary" onclick="closeTriggerModal()">Cancel</button>
        <button class="btn-primary" onclick="saveTrigger()">Save Trigger</button>
      </div>
    </div>
  </div>

  <!-- Action Modal -->
  <div id="action-modal" class="modal-backdrop hidden">
    <div class="modal">
      <div class="modal-header">
        <span class="material-icons-outlined node-icon">settings</span>
        <h3 class="modal-title">Add Action</h3>
        <button class="modal-close" onclick="closeActionModal()">
          <span class="material-icons-outlined">close</span>
        </button>
      </div>
      
      <div class="form-group">
        <label class="form-label">Action Type</label>
        <select id="action-select" class="form-select">
          <option value="Add Tag">Add Tag</option>
          <option value="Send Email">Send Email</option>
          <option value="If">If</option>
          <option value="Create Meeting" disabled class="coming-soon">Create Meeting <span class="coming-soon-badge">Coming Soon</span></option>
        </select>
      </div>

      <div id="action-properties"></div>

      <div class="modal-actions">
        <button class="btn-secondary" onclick="closeActionModal()">Cancel</button>
        <button class="btn-primary" onclick="saveAction()" id="action-save-btn">Add Action</button>
      </div>
    </div>
  </div>

  <!-- Context Modal -->
  <div id="context-modal" class="modal-backdrop hidden">
    <div class="modal" style="max-width: 760px; width: 95%">
      <div class="modal-header">
        <span class="material-icons-outlined node-icon">integration_instructions</span>
        <h3 class="modal-title">Execution Context</h3>
        <button class="modal-close" onclick="closeContextModal()">
          <span class="material-icons-outlined">close</span>
        </button>
      </div>

      <div class="form-group">
        <label class="form-label">Attach full contact/booking context to workflow runs</label>
        <label style="display:flex;align-items:center;gap:.5rem;color:#E0E0E0">
          <input type="checkbox" id="context-attach-full" />
          <span>Enable full context (contact + booking)</span>
        </label>
      </div>

      <div class="form-group">
        <label class="form-label">Schema Preview</label>
        <pre id="context-schema" style="background:#111827;border:1px solid #374151;border-radius:.5rem;padding:1rem;white-space:pre-wrap;max-height:240px;overflow:auto;color:#d1d5db"></pre>
        <div style="margin-top:.5rem;display:flex;gap:.5rem">
          <button class="context-btn" onclick="copyContextSchema()">Copy Schema</button>
          <span id="context-schema-copy-status" style="color:#A3B3AF"></span>
        </div>
      </div>

      <div class="form-group">
        <label class="form-label">Optional Sample Payload (JSON)</label>
        <textarea id="context-sample"
          placeholder='{"contact": {"id":"..."}, "booking": {"id":"..."}}'
          style="width:100%;min-height:140px;background:#111827;border:1px solid #374151;border-radius:.5rem;padding:.75rem;color:#E0E0E0;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace"></textarea>
        <div style="margin-top:.25rem;color:#9ca3af;font-size:.85rem">Saved with the workflow for testing and future evaluation. Optional.</div>
      </div>

      <div class="modal-actions">
        <button class="btn-secondary" onclick="closeContextModal()">Cancel</button>
        <button class="btn-primary" onclick="saveContextSpec()">Save Context</button>
      </div>
    </div>
  </div>

  <script defer>
    // Constants and utilities
    const API_URL = 'http://localhost:3001/api';
    const NODE_WIDTH = 320;          // px, matches .flowchart-node width
    const VERTICAL_SPACING = 120;    // px vertical spacing between nodes
    const ORB_SIZE = 40;             // px, action orb size
    const INSERT_ORB_SIZE = 32;      // px, insert orb size

    // Context spec (versioned) persisted with workflows for future engine use
    let contextSpec = null;

    function getDefaultContextSchema() {
      return {
        contact: {
          id: 'string',
          firstName: 'string',
          lastName: 'string',
          fullName: 'string',
          email: 'string',
          phone: 'string',
          timezone: 'string',
          locale: 'string',
          tags: ['string'],
          company: 'string',
          title: 'string',
          notes: 'string',
          createdAt: 'string',
          updatedAt: 'string',
          customFields: 'object'
        },
        booking: {
          id: 'string',
          title: 'string',
          status: 'string',
          eventType: 'string',
          startTime: 'string',
          endTime: 'string',
          durationMinutes: 'number',
          timezone: 'string',
          location: 'string',
          meetingLink: 'string',
          attendees: [
            {
              name: 'string',
              email: 'string',
              role: 'string'
            }
          ],
          rescheduleCount: 'number',
          answers: 'object',
          metadata: 'object',
          createdAt: 'string',
          updatedAt: 'string'
        }
      };
    }

    function getDefaultContextSpec() {
      return {
        version: 1,
        attachFullContext: true,
        scope: 'full', // future: 'subset'
        schema: getDefaultContextSchema(),
        sample: null
      };
    }
    
    function getAnyToken() {
      return sessionStorage.getItem('calendarify-token') || localStorage.getItem('calendarify-token');
    }
    
    // Global variables
    let currentWorkflow = null;
    let currentNodeId = 0;
    let nodes = [];
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let canvasOffset = { x: 0, y: 0 };
    let selectedNode = null;
    let didFirstPanRefresh = false;

    // Production-grade Connection and Orb Management System
    const WorkflowManager = {
      connections: new Map(), // connectionId -> connection object
      orbs: new Map(), // nodeId -> orb element
      insertOrbs: new Map(), // connectionId -> insert orb element
      connectionCounter: 0,
      svg: null,
      // Helper: create midpoint insert orbs for all valid connections
      addInsertOrbsForConnections() {
        try {
          for (const connection of this.connections.values()) {
            const fromNode = connection.from;
            const toNode = connection.to;
            // Determine types
            const fromType = (fromNode.__nodeData && fromNode.__nodeData.data?.type) || nodes.find(n=>n.element===fromNode)?.data?.type || '';
            const toType = (toNode.__nodeData && toNode.__nodeData.data?.type) || nodes.find(n=>n.element===toNode)?.data?.type || '';
            // Skip orbs between If and its True/False headers
            if (fromType === 'If' && (toType === 'True' || toType === 'False')) continue;
            // Otherwise add midpoint insert orb
            this.createInsertOrb(connection);
          }
        } catch (e) { console.warn('addInsertOrbsForConnections failed:', e); }
      },
      
      // Initialize the system
      init() {
        this.connections.clear();
        this.orbs.clear();
        this.insertOrbs.clear();
        this.connectionCounter = 0;
        // Ensure an SVG overlay exists for pretty paths
        let svg = container.querySelector('#connections-svg');
        if (!svg) {
          svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          svg.setAttribute('id', 'connections-svg');
          svg.setAttribute('width', '100%');
          svg.setAttribute('height', '100%');
          svg.style.position = 'absolute';
          svg.style.left = '0';
          svg.style.top = '0';
          svg.style.pointerEvents = 'none';
          svg.style.zIndex = '4';
          container.appendChild(svg);
        }
        this.svg = svg;
        console.log('WorkflowManager initialized');
      },
      
      // Create a connection between two nodes
      createConnection(fromNode, toNode, createInsertOrb = true) {
        if (!this.isValidConnection(fromNode, toNode)) {
          console.warn('Invalid connection attempt:', fromNode?.id, '->', toNode?.id);
          return null;
        }
        
        const connectionId = `conn-${++this.connectionCounter}`;
        
        // Remove any existing connection between these nodes
        this.removeConnectionBetween(fromNode, toNode);
        
        const line = this.createConnectionLine(connectionId);
        const connection = {
          id: connectionId,
          from: fromNode,
          to: toNode,
          line: line,
          created: Date.now()
        };
        
        this.connections.set(connectionId, connection);
        this.updateConnectionPosition(connection);
        
        // Make the line visible after positioning
        connection.line.style.opacity = '1';
        
        // Create insert orb in the middle of the connection (only if requested)
        if (createInsertOrb) {
          this.createInsertOrb(connection);
        }
        
        console.log('Created connection:', connectionId);
        return connection;
      },
      
      // Create the visual connection line element
      createConnectionLine(id) {
        // Use SVG path for smoother, orthogonal lines with rounded corners
        if (!this.svg) this.init();
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('id', id);
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke', '#34D399');
        path.setAttribute('stroke-width', '3');
        path.setAttribute('stroke-linecap', 'round');
        path.setAttribute('stroke-linejoin', 'round');
        path.style.opacity = '0';
        this.svg.appendChild(path);
        requestAnimationFrame(() => { path.style.opacity = '1'; });
        return path;
      },
      
      // Create insert orb in the middle of a connection
      createInsertOrb(connection) {
        if (!connection || !connection.from || !connection.to) {
          return;
        }
        
        const insertOrb = document.createElement('div');
        insertOrb.className = 'insert-action-orb';
        insertOrb.dataset.connectionId = connection.id;
        insertOrb.style.cssText = `
          position: absolute;
          width: 32px;
          height: 32px;
          background: linear-gradient(135deg, #34D399 0%, #10B981 100%);
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          z-index: 25;
          opacity: 0;
          transform: scale(0.8);
          transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
          box-shadow: 0 3px 8px rgba(52, 211, 153, 0.3);
          border: 2px solid rgba(255, 255, 255, 0.1);
        `;
        
        insertOrb.innerHTML = `
          <span class="material-icons-outlined" style="color: #1A2E29; font-size: 1rem;">add</span>
        `;
        
        // Add click handler
        insertOrb.addEventListener('click', (e) => {
          e.stopPropagation();
          this.handleInsertOrbClick(connection);
        });
        
        // Add hover effects
        insertOrb.addEventListener('mouseenter', () => {
          insertOrb.style.transform = 'scale(1.1)';
          insertOrb.style.boxShadow = '0 4px 12px rgba(52, 211, 153, 0.5)';
        });
        
        insertOrb.addEventListener('mouseleave', () => {
          insertOrb.style.transform = 'scale(1)';
          insertOrb.style.boxShadow = '0 3px 8px rgba(52, 211, 153, 0.3)';
        });
        
        container.appendChild(insertOrb);
        this.insertOrbs.set(connection.id, insertOrb);
        
        // Position the insert orb
        this.updateInsertOrbPosition(connection);
        
        // Animate in
        requestAnimationFrame(() => {
          insertOrb.style.opacity = '1';
          insertOrb.style.transform = 'scale(1)';
        });
        
        console.log('Created insert orb for connection:', connection.id);
      },
      
      // Update insert orb position
      updateInsertOrbPosition(connection) {
        const insertOrb = this.insertOrbs.get(connection.id);
        if (!insertOrb || !connection.from || !connection.to) {
          return;
        }
        
        try {
          const fromRect = connection.from.getBoundingClientRect();
          const toRect = connection.to.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          
          if (!fromRect || !toRect || !containerRect) {
            return;
          }
          
          // Calculate middle point of the connection
          const fromX = fromRect.left - containerRect.left + fromRect.width / 2;
          const fromY = fromRect.bottom - containerRect.top;
          const toX = toRect.left - containerRect.left + toRect.width / 2;
          const toY = toRect.top - containerRect.top;
          
          const middleX = (fromX + toX) / 2;
          const middleY = (fromY + toY) / 2;
          
          // Position the insert orb
          insertOrb.style.left = `${middleX - 16}px`; // 16 is half of orb width
          insertOrb.style.top = `${middleY - 16}px`; // 16 is half of orb height
          
        } catch (error) {
          console.error('Error updating insert orb position:', error);
        }
      },
      
      // Handle insert orb click
      handleInsertOrbClick(connection) {
        console.log('Insert orb clicked for connection:', connection.id);
        // Store the connection info for insertion
        window.insertConnection = connection;
        openActionModal('insert');
      },
      
      // Update connection position
      updateConnectionPosition(connection) {
        if (!connection || !connection.line || !connection.from || !connection.to) {
          return;
        }
        
        try {
          const fromRect = connection.from.getBoundingClientRect();
          const toRect = connection.to.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          
          if (!fromRect || !toRect || !containerRect) {
            return;
          }
          
          // Calculate anchor points: center bottom of from, center top of to
          const fromX = Math.round(fromRect.left - containerRect.left + fromRect.width / 2);
          const fromY = Math.round(fromRect.bottom - containerRect.top - 1);
          const toX = Math.round(toRect.left - containerRect.left + toRect.width / 2);
          const toY = Math.round(toRect.top - containerRect.top + 1);

          // Determine orthogonal path for branch headers; smooth curve for others
          const fromType = (connection.from.__nodeData && connection.from.__nodeData.data?.type) || nodes.find(n=>n.element===connection.from)?.data?.type || '';
          const toType = (connection.to.__nodeData && connection.to.__nodeData.data?.type) || nodes.find(n=>n.element===connection.to)?.data?.type || '';

          // Attach node data refs to DOM once for quicker lookup
          connection.from.__nodeData = nodes.find(n => n.element === connection.from) || connection.from.__nodeData || null;
          connection.to.__nodeData = nodes.find(n => n.element === connection.to) || connection.to.__nodeData || null;

          let d = '';
          const vDrop = 30; // vertical drop from source
          const r = 12; // corner radius
          if (fromType === 'If' && (toType === 'True' || toType === 'False')) {
            const midY = fromY + vDrop;
            // Horizontal toward destination x
            const hx1 = fromX;
            const hy1 = midY;
            const hx2 = toX;
            const hy2 = midY;
            // Build path with rounded corners using quadratic curves
            // Start
            d += `M ${fromX} ${fromY}`;
            // Vertical down to just before corner
            d += ` L ${fromX} ${hy1 - r}`;
            // Corner: down->right (or down->left)
            const dir = (toX >= fromX) ? 1 : -1;
            d += ` Q ${fromX} ${hy1} ${fromX + dir * r} ${hy1}`;
            // Horizontal toward near the destination x
            d += ` L ${hx2 - dir * r} ${hy2}`;
            // Corner: right/left -> down
            d += ` Q ${hx2} ${hy2} ${hx2} ${hy2 + r}`;
            // Vertical down to target
            d += ` L ${toX} ${toY}`;
          } else if ((fromType === 'True' || fromType === 'False') && !(toType === 'True' || toType === 'False')) {
            // From branch header to first branch node: straight with slight curve
            const ctrlY = fromY + 20;
            d = `M ${fromX} ${fromY} Q ${fromX} ${ctrlY} ${fromX} ${ctrlY} L ${toX} ${ctrlY} Q ${toX} ${ctrlY} ${toX} ${toY}`;
          } else {
            // Generic smooth curve from from to to
            const mx = Math.round((fromX + toX) / 2);
            d = `M ${fromX} ${fromY} C ${mx} ${fromY}, ${mx} ${toY}, ${toX} ${toY}`;
          }

          connection.line.setAttribute('d', d);
          connection.line.style.display = 'block';

          
          // Update insert orb position
          this.updateInsertOrbPosition(connection);
          
        } catch (error) {
          console.error('Error updating connection position:', error);
        }
      },
      
      // Remove a specific connection
      removeConnection(connectionId) {
        const connection = this.connections.get(connectionId);
        if (connection) {
          if (connection.line && connection.line.parentNode) {
            connection.line.style.opacity = '0';
            setTimeout(() => {
              if (connection.line.parentNode) {
                connection.line.remove();
              }
            }, 300);
          }
          
          // Remove insert orb
          const insertOrb = this.insertOrbs.get(connectionId);
          if (insertOrb) {
            insertOrb.style.opacity = '0';
            insertOrb.style.transform = 'scale(0.8)';
            setTimeout(() => {
              if (insertOrb.parentNode) {
                insertOrb.remove();
              }
            }, 300);
            this.insertOrbs.delete(connectionId);
          }
          
          this.connections.delete(connectionId);
          console.log('Removed connection:', connectionId);
        }
      },
      
      // Remove connection between two specific nodes
      removeConnectionBetween(fromNode, toNode) {
        for (const [id, connection] of this.connections) {
          if ((connection.from === fromNode && connection.to === toNode) ||
              (connection.from === toNode && connection.to === fromNode)) {
            this.removeConnection(id);
            break;
          }
        }
      },
      
      // Remove all connections involving a node
      removeNodeConnections(node) {
        const connectionsToRemove = [];
        for (const [id, connection] of this.connections) {
          if (connection.from === node || connection.to === node) {
            connectionsToRemove.push(id);
          }
        }
        
        connectionsToRemove.forEach(id => this.removeConnection(id));
        console.log(`Removed ${connectionsToRemove.length} connections for node:`, node.id);
      },
      
      // Update all connection positions
      updateAllConnections() {
        for (const connection of this.connections.values()) {
          this.updateConnectionPosition(connection);
        }
      },
      
      // Validate if a connection is valid
      isValidConnection(fromNode, toNode) {
        if (!fromNode || !toNode) return false;
        if (!fromNode.parentNode || !toNode.parentNode) return false;
        if (fromNode === toNode) return false;
        
        // Check if connection already exists
        for (const connection of this.connections.values()) {
          if ((connection.from === fromNode && connection.to === toNode) ||
              (connection.from === toNode && connection.to === fromNode)) {
            return false;
          }
        }
        
        return true;
      },
      
      // Get connections for a specific node
      getNodeConnections(node) {
        const nodeConnections = [];
        for (const connection of this.connections.values()) {
          if (connection.from === node || connection.to === node) {
            nodeConnections.push(connection);
          }
        }
        return nodeConnections;
      },
      
      // Clean up all connections
      cleanup() {
        for (const connection of this.connections.values()) {
          if (connection.line && connection.line.parentNode) {
            connection.line.remove();
          }
        }
        
        for (const insertOrb of this.insertOrbs.values()) {
          if (insertOrb.parentNode) {
            insertOrb.remove();
          }
        }
        
        this.connections.clear();
        this.insertOrbs.clear();
        // Clear SVG paths
        if (this.svg) {
          while (this.svg.firstChild) this.svg.removeChild(this.svg.firstChild);
        }
        console.log('WorkflowManager connections and insert orbs cleaned up');
      }
    };
    
    // Production-grade Action Orb Management System
    const OrbManager = {
      orbs: new Map(), // key -> orb element; keys for regular: `${nodeId}:${position}`, for midpoints: `orb-${from}-${to}`
      
      // Initialize the orb system
      init() {
        this.orbs.clear();
        console.log('OrbManager initialized');
      },
      
      // Add an orb to a node
      addOrb(node, position = 'bottom') {
        if (!this.isValidNode(node)) {
          console.warn('Invalid node for orb:', node?.id);
          return null;
        }
        
        console.log(`OrbManager.addOrb called for node: ${node.id}, position: ${position}`);
        // Never add a bottom orb under an If node
        try {
          const domElement = node.element || node;
          const stepType = (nodes.find(n => n.element === domElement)?.data?.type) || domElement?.dataset?.stepType || '';
          if (stepType === 'If' && position === 'bottom') {
            console.log('Skipping bottom orb for If node:', node.id);
            return null;
          }
        } catch {}
        
        // Remove existing orb at same position if present
        const key = `${node.id}:${position}`;
        this.removeOrbById(key);
        
        const orb = this.createOrbElement(node.id, position);
        this.orbs.set(key, orb);
        
        // Pass the DOM element to positionOrb (handle both node objects and DOM elements)
        const domElement = node.element || node;
        this.positionOrb(orb, domElement, position);
        container.appendChild(orb);
        
        console.log('Added orb to node:', node.id);
        return orb;
      },
      
      // Add orb at the exact midpoint between two nodes
      addOrbAtMidpoint(fromNode, toNode) {
        if (!this.isValidNode(fromNode) || !this.isValidNode(toNode)) {
          console.warn('OrbManager.addOrbAtMidpoint: Invalid nodes provided');
          return null;
        }
        
        const orbId = `orb-${fromNode.id}-${toNode.id}`;
        console.log(`OrbManager.addOrbAtMidpoint called between: ${fromNode.id} and ${toNode.id}`);
        
        // Remove existing orb if it exists
        this.removeOrbById(orbId);
        
        const orb = this.createOrbElement(orbId, 'midpoint');
        this.orbs.set(orbId, orb);
        
        // Pass the DOM elements to positionOrbAtMidpoint (handle both node objects and DOM elements)
        const fromDomElement = fromNode.element || fromNode;
        const toDomElement = toNode.element || toNode;
        this.positionOrbAtMidpoint(orb, fromDomElement, toDomElement);
        container.appendChild(orb);
        
        return orb;
      },
      
      // Create the orb element
      createOrbElement(nodeId, position) {
        const orb = document.createElement('div');
        orb.className = 'add-action-orb';
        orb.dataset.nodeId = nodeId;
        orb.dataset.position = position;
        orb.style.cssText = `
          position: absolute;
          width: 40px;
          height: 40px;
          background: linear-gradient(135deg, #34D399 0%, #10B981 100%);
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          z-index: 20;
          opacity: 0;
          transform: scale(1);
          transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
          box-shadow: 0 4px 12px rgba(52, 211, 153, 0.3);
          border: 2px solid rgba(255, 255, 255, 0.1);
        `;
        
        orb.innerHTML = `
          <span class="material-icons-outlined" style="color: #1A2E29; font-size: 1.25rem;">add</span>
        `;
        
        // Add click handler
        orb.addEventListener('click', (e) => {
          e.stopPropagation();
          this.handleOrbClick(nodeId, position);
        });
        
        // Add hover effects
        orb.addEventListener('mouseenter', () => {
          if (position === 'midpoint') {
            orb.style.transform = 'translate(-50%, -50%) scale(1.1)';
      } else {
            orb.style.transform = 'scale(1.1)';
          }
          orb.style.boxShadow = '0 6px 20px rgba(52, 211, 153, 0.5)';
        });
        
        orb.addEventListener('mouseleave', () => {
          if (position === 'midpoint') {
            orb.style.transform = 'translate(-50%, -50%) scale(1)';
          } else {
            orb.style.transform = 'scale(1)';
          }
          orb.style.boxShadow = '0 4px 12px rgba(52, 211, 153, 0.3)';
        });
        
        // Animate in
        requestAnimationFrame(() => {
          orb.style.opacity = '1';
          // Only apply translate for midpoint orbs, regular orbs use normal positioning
          if (position === 'midpoint') {
            orb.style.transform = 'translate(-50%, -50%) scale(1)';
          } else {
            orb.style.transform = 'scale(1)';
          }
        });
        
        return orb;
      },
      
      // Position the orb relative to its node with robust positioning
      positionOrb(orb, node, position) {
        if (!orb || !node) {
          console.warn('OrbManager.positionOrb: Missing orb or node');
          return;
        }
        
        try {
          // Get node position relative to container
          const nodeRect = node.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          
          if (!nodeRect || !containerRect) {
            console.warn('OrbManager.positionOrb: Could not get bounding rects');
            return;
          }
          
          // Calculate relative positions
          const nodeLeft = nodeRect.left - containerRect.left;
          const nodeTop = nodeRect.top - containerRect.top;
          const nodeWidth = nodeRect.width;
          const nodeHeight = nodeRect.height;
          
          // Orb dimensions
          const orbSize = 40;
          const orbHalfSize = orbSize / 2;
          
          // Calculate position based on placement
          let left, top;
          
          switch (position) {
            case 'bottom':
              // Center horizontally, place below node with proper spacing
              left = nodeLeft + (nodeWidth / 2) - orbHalfSize;
              top = nodeTop + nodeHeight + 20; // 20px spacing below node
              break;
              
            case 'top':
              // Center horizontally, place above node with proper spacing
              left = nodeLeft + (nodeWidth / 2) - orbHalfSize;
              top = nodeTop - orbSize - 20; // 20px spacing above node
              break;
              
            case 'right':
              // Center vertically, place to the right with proper spacing
              left = nodeLeft + nodeWidth + 20; // 20px spacing to the right
              top = nodeTop + (nodeHeight / 2) - orbHalfSize;
              break;
              
            case 'left':
              // Center vertically, place to the left with proper spacing
              left = nodeLeft - orbSize - 20; // 20px spacing to the left
              top = nodeTop + (nodeHeight / 2) - orbHalfSize;
              break;
              
            default:
              console.warn('OrbManager.positionOrb: Unknown position:', position);
              // Default to bottom
              left = nodeLeft + (nodeWidth / 2) - orbHalfSize;
              top = nodeTop + nodeHeight + 20;
          }
          
          // Ensure orb stays within container bounds (with padding)
          const containerPadding = 20;
          const maxLeft = containerRect.width - orbSize - containerPadding;
          const maxTop = containerRect.height - orbSize - containerPadding;
          
          left = Math.max(containerPadding, Math.min(left, maxLeft));
          top = Math.max(containerPadding, Math.min(top, maxTop));
          
          // Apply positioning
          orb.style.left = `${left}px`;
          orb.style.top = `${top}px`;
          
          // Debug logging
          console.log(`Orb positioned: ${position} at (${left}, ${top}) for node ${node.id}`);
          
        } catch (error) {
          console.error('OrbManager.positionOrb: Error positioning orb:', error);
          // Fallback positioning
          orb.style.left = '50%';
          orb.style.top = '50%';
          orb.style.transform = 'translate(-50%, -50%)';
        }
      },
      
      // Position orb at the exact midpoint of the connection line
      positionOrbAtMidpoint(orb, fromNode, toNode) {
        if (!orb || !fromNode || !toNode) {
          return;
        }
        
        try {
          // Get node positions relative to container (same logic as connection lines)
          const fromRect = fromNode.getBoundingClientRect();
          const toRect = toNode.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          
          if (!fromRect || !toRect || !containerRect) {
            return;
          }
          
          // Calculate connection points (exactly like connection lines)
          // Use Math.round to prevent sub-pixel positioning that can cause shifting
          const fromX = Math.round(fromRect.left - containerRect.left + fromRect.width / 2);
          const fromY = Math.round(fromRect.bottom - containerRect.top - 1);
          const toX = Math.round(toRect.left - containerRect.left + toRect.width / 2);
          const toY = Math.round(toRect.top - containerRect.top + 1);
          
          // Calculate midpoint of the connection line
          const midpointX = (fromX + toX) / 2;
          const midpointY = (fromY + toY) / 2;
          
          // Orb dimensions
          const orbSize = 40;
          const orbHalfSize = orbSize / 2;
          
          // Position orb at midpoint (centered on the connection line)
          // Use the exact midpoint coordinates and center the orb using transform
          // Add small visual offset to account for CSS rendering differences
          const finalLeft = midpointX - 1; // 1px left offset for visual centering
          const finalTop = midpointY;
          
          // Apply positioning - orb will be centered on these coordinates
          orb.style.left = `${finalLeft}px`;
          orb.style.top = `${finalTop}px`;
          orb.style.transform = 'translate(-50%, -50%)';
          
          
        } catch (error) {
          console.error('OrbManager.positionOrbAtMidpoint: Error positioning orb:', error);
          // Fallback positioning
          orb.style.left = '50%';
          orb.style.top = '50%';
          orb.style.transform = 'translate(-50%, -50%)';
        }
      },
      
      // Remove orb by ID
      removeOrbById(orbId) {
        const orb = this.orbs.get(orbId);
        if (orb) {
          orb.remove();
          this.orbs.delete(orbId);
        }
      },
      
      // Remove orb from a node
      removeOrb(node) {
        if (!node || !node.id) return;
        const keys = Array.from(this.orbs.keys()).filter(k => String(k).startsWith(`${node.id}:`));
        keys.forEach(k => {
          const orb = this.orbs.get(k);
          if (orb) {
            orb.style.opacity = '0';
            orb.style.transform = 'scale(0.8)';
            setTimeout(() => { if (orb.parentNode) orb.remove(); }, 300);
          }
          this.orbs.delete(k);
        });
        if (keys.length) console.log('Removed orbs from node:', node.id, keys);
      },
      
      // Remove all orbs
      removeAllOrbs() {
        for (const orb of this.orbs.values()) {
          if (orb.parentNode) {
            orb.remove();
          }
        }
        this.orbs.clear();
        console.log('Removed all orbs');
      },
      
      // Update orb positions for all nodes (handled comprehensively below)
      
      // Handle orb click
      handleOrbClick(nodeId, position) {
        console.log('Orb clicked for node:', nodeId, 'pos:', position);
        // For IF nodes, left orb = true path, right orb = false path
        try {
          const node = nodes.find(n => n.id === nodeId);
          if (node && node.data && node.data.type === 'If' && (position === 'left' || position === 'right')) {
            const prefix = position === 'left' ? 'branch-true-' : 'branch-false-';
            openActionModal(`${prefix}${nodeId}`);
            return;
          }
        } catch {}
        // Default: add after
        openActionModal(`add-after-${nodeId}`);
      },
      
      // Check if node is valid for orb
      isValidNode(node) {
        return node && node.id && (node.element || node.parentNode);
      },
      
      // Get orb for a node
      getOrb(node) {
        if (!node) return null;
        const key = Array.from(this.orbs.keys()).find(k => String(k).startsWith(`${node.id}:`));
        return key ? this.orbs.get(key) : null;
      },
      
      // Check if node has an orb
      hasOrb(node) {
        if (!node) return false;
        return Array.from(this.orbs.keys()).some(k => String(k).startsWith(`${node.id}:`));
      },
      
      // Update all orb positions (handles both regular and midpoint orbs)
      updateAllOrbPositions() {
        console.log('OrbManager: Updating all orb positions...');
        
        this.orbs.forEach((orb, orbId) => {
          const position = orb.dataset.position;
          
          if (position === 'midpoint') {
            // Handle midpoint orbs
            // orbId format: "orb-node-4-node-5"
            const nodeIdPart = orbId.replace('orb-', ''); // "node-4-node-5"
            const parts = nodeIdPart.split('-'); // ["node", "4", "node", "5"]
            
            if (parts.length >= 4) {
              // Reconstruct node IDs: "node-4" and "node-5"
              const fromNodeId = `${parts[0]}-${parts[1]}`;
              const toNodeId = `${parts[2]}-${parts[3]}`;
              const fromNode = document.getElementById(fromNodeId);
              const toNode = document.getElementById(toNodeId);
              
              if (fromNode && toNode) {
                this.positionOrbAtMidpoint(orb, fromNode, toNode);
            } else {
                console.warn(`OrbManager: Could not update midpoint orb ${orbId} - missing nodes: ${fromNodeId}(${!!fromNode}), ${toNodeId}(${!!toNode})`);
              }
            }
          } else {
            // Handle regular orbs
            const nodeId = String(orbId).includes(':') ? String(orbId).split(':')[0] : String(orbId);
            const node = document.getElementById(nodeId);
            if (node && position) {
              this.positionOrb(orb, node, position);
            } else {
              console.warn(`OrbManager: Could not update orb for key ${orbId}`);
            }
          }
        });

      },
      
      // Clean up all orbs
      cleanup() {
        this.removeAllOrbs();
      }
    };
    
    // Workflow Structure Manager - orchestrates connections and orbs
    const StructureManager = {
      rebuildTimeout: null,
      layoutApplied: false,
      
      // Rebuild the entire workflow structure with debouncing
      rebuild(callback = null) {
        // Clear any pending rebuild
        if (this.rebuildTimeout) {
          clearTimeout(this.rebuildTimeout);
        }
        
        // Debounce rebuilds to prevent multiple rapid calls
        this.rebuildTimeout = setTimeout(() => {
          this.performRebuild(callback);
        }, 50);
      },
      
      // Perform the actual rebuild
      performRebuild(callback = null) {
        console.log('Performing workflow structure rebuild...');
        
        // Don't rebuild if there are no nodes
        if (nodes.length === 0) {
          console.log('Skipping rebuild - no nodes');
          if (callback) callback();
          return;
        }

        // Apply deterministic layout before wiring connections/orbs
        LayoutManager.apply();

        // If there's only a trigger, just add an orb below it
        if (nodes.length === 1) {
          console.log('Only trigger node found, adding orb below it');
          
          // Clean up existing orbs first to prevent duplicates
          OrbManager.cleanup();
          
          const triggerNode = nodes[0];
          if (triggerNode && triggerNode.element) {
            OrbManager.addOrb(triggerNode, 'bottom');
          }
          if (callback) callback();
          return;
        }
        
        // Clean up existing structure
        WorkflowManager.cleanup();
        OrbManager.cleanup();
        
        // Sort nodes by vertical position to ensure proper order
        const sortedNodes = [...nodes].sort((a, b) => {
          const aRect = a.element.getBoundingClientRect();
          const bRect = b.element.getBoundingClientRect();
          return aRect.top - bRect.top;
        });
        
        console.log('Sorted nodes:', sortedNodes.map(n => ({ id: n.id, type: n.type })));
        
        // Rebuild connections honoring If branching with True/False headers
        const isControl = (n) => !!(n && n.data && (n.data.type === 'True' || n.data.type === 'False'));
        const findIfHeaders = (startIdx) => {
          let trueIdx = -1, falseIdx = -1;
          for (let j = startIdx + 1; j < sortedNodes.length; j++) {
            const t = sortedNodes[j]?.data?.type;
            if (t === 'If') break; // stop at next IF block
            if (t === 'True' && trueIdx === -1) trueIdx = j;
            if (t === 'False' && falseIdx === -1) falseIdx = j;
            if (trueIdx !== -1 && falseIdx !== -1) break;
          }
          return { trueIdx, falseIdx };
        };

        const visited = new Set();
        for (let i = 0; i < sortedNodes.length; i++) {
          if (visited.has(i)) continue;
          const node = sortedNodes[i];
          const type = node?.data?.type || '';
          // Handle If block with two branches
          if (type === 'If') {
            const { trueIdx, falseIdx } = findIfHeaders(i);
            // Connect If -> True/False headers when present
            if (trueIdx !== -1) WorkflowManager.createConnection(node.element, sortedNodes[trueIdx].element, false);
            if (falseIdx !== -1) WorkflowManager.createConnection(node.element, sortedNodes[falseIdx].element, false);

            // Chain within branches: find actions tagged with this IF
            const ifId = node.data?.properties?.ifId;
            if (ifId) {
              const trueBranch = [];
              const falseBranch = [];
              for (let j = i + 1; j < sortedNodes.length; j++) {
                const d = sortedNodes[j]?.data;
                if (!d) continue;
                if (d.type === 'If') break; // stop at next IF
                if (d.type === 'True' || d.type === 'False') continue;
                if (d.properties && d.properties.parentIfId === ifId) {
                  if (d.properties.branch === 'true') trueBranch.push(j);
                  if (d.properties.branch === 'false') falseBranch.push(j);
                }
              }
              // Connect headers to first branch node
              if (trueIdx !== -1 && trueBranch.length > 0) WorkflowManager.createConnection(sortedNodes[trueIdx].element, sortedNodes[trueBranch[0]].element, false);
              if (falseIdx !== -1 && falseBranch.length > 0) WorkflowManager.createConnection(sortedNodes[falseIdx].element, sortedNodes[falseBranch[0]].element, false);
              // Chain within
              for (let k = 0; k < trueBranch.length - 1; k++) WorkflowManager.createConnection(sortedNodes[trueBranch[k]].element, sortedNodes[trueBranch[k + 1]].element, false);
              for (let k = 0; k < falseBranch.length - 1; k++) WorkflowManager.createConnection(sortedNodes[falseBranch[k]].element, sortedNodes[falseBranch[k + 1]].element, false);
            }
            continue;
          }

          // Skip branch headers here (handled by If)
          if (type === 'True' || type === 'False') continue;

          // Default linear connection to the next non-control node
          let nextIdx = i + 1;
          while (nextIdx < sortedNodes.length && (sortedNodes[nextIdx].data?.type === 'True' || sortedNodes[nextIdx].data?.type === 'False')) {
            nextIdx++;
          }
          if (nextIdx < sortedNodes.length) {
            WorkflowManager.createConnection(node.element, sortedNodes[nextIdx].element, false);
          }
        }
        
        // Add orbs at connection midpoints (excluding If -> True/False)
        try { WorkflowManager.addInsertOrbsForConnections(); } catch {}

        // Add orbs after the last node
        for (let i = 0; i < sortedNodes.length; i++) {
          const node = sortedNodes[i];
          const isLastNode = i === sortedNodes.length - 1;
          
          console.log(`Node ${i}: ${node.id} (${node.type}), isLast: ${isLastNode}`);

          // Add branch orbs for IF and branch header nodes
          if (node.data && node.data.type === 'If') {
            // Ensure no stray bottom orb remains
            try { OrbManager.removeOrbById(`${node.element.id}:bottom`); } catch {}
            OrbManager.addOrb(node.element, 'left');
            OrbManager.addOrb(node.element, 'right');
          }
          if (node.data && (node.data.type === 'True' || node.data.type === 'False')) {
            OrbManager.addOrb(node.element, 'bottom');
          }
          
          if (!isLastNode) {
            // handled above using connections
        } else {
            // Add orb below the last node
            console.log(`Adding orb below last node: ${node.id}`);
            // Never add a bottom orb under an If node
            if (node && node.data && node.data.type === 'If') {
              try { OrbManager.removeOrbById(`${node.element.id}:bottom`); } catch {}
              continue;
            }
            const stepType = (node.data && node.data.type) || node.element?.dataset?.stepType || '';
            if (!(stepType === 'If' || stepType === 'True' || stepType === 'False')) {
              OrbManager.addOrb(node.element, 'bottom');
            }
          }
        }

        // Final safety: ensure no bottom orbs remain on any If nodes
        try {
          sortedNodes.forEach(n => {
            if (n && n.data && n.data.type === 'If' && n.element && n.element.id) {
              OrbManager.removeOrbById(`${n.element.id}:bottom`);
            }
          });
        } catch {}
        
        // Extra cleanup: remove any stray DOM orbs that might still appear under If nodes
        try {
          const strayOrbs = container.querySelectorAll('.add-action-orb');
          strayOrbs.forEach(orb => {
            const pos = orb.dataset.position;
            const nid = orb.dataset.nodeId;
            if (pos === 'bottom' && nid) {
              const el = document.getElementById(nid);
              const isIf = !!(el && (el.dataset?.stepType === 'If' || (nodes.find(n => n.element === el)?.data?.type === 'If')));
              if (isIf) {
                // Remove from manager map if present, then remove DOM
                try { OrbManager.removeOrbById(`${nid}:bottom`); } catch {}
                if (orb.parentNode) orb.remove();
              }
            }
          });
        } catch {}
        
        // Update all orb positions to ensure proper alignment
        OrbManager.updateAllOrbPositions();
        
        // Final alignment pass to ensure no initial jitter
        try {
          LayoutManager.apply();
          WorkflowManager.updateAllConnections();
          OrbManager.updateAllOrbPositions();
        } catch (e) {
          console.warn('Post-rebuild alignment warning:', e);
        }
        
        console.log('Workflow structure rebuilt with', WorkflowManager.connections.size, 'connections and', OrbManager.orbs.size, 'orbs');
        
        // Call callback if provided
        if (callback) {
          callback();
        }
      },
      
      // Initialize the structure
      init() {
        WorkflowManager.init();
        OrbManager.init();
        console.log('StructureManager initialized');
      },
      
      // Clean up everything
      cleanup() {
        // Clear any pending rebuild
        if (this.rebuildTimeout) {
          clearTimeout(this.rebuildTimeout);
          this.rebuildTimeout = null;
        }
        
        WorkflowManager.cleanup();
        OrbManager.cleanup();
        console.log('StructureManager cleaned up');
      }
    };

    // Deterministic layout manager for nodes (centers X and enforces vertical spacing)
    const LayoutManager = {
      apply() {
        try {
          if (!container) return;
          const containerRect = container.getBoundingClientRect();
          if (!containerRect) return;

          // Place trigger node (keep its configured top, center X)
          const trigger = nodes.find(n => n.type === 'trigger');
          if (!trigger || !trigger.element) return;

          const triggerEl = trigger.element;
          triggerEl.style.left = '50%';
          triggerEl.style.transform = 'translateX(-50%)';

          // Read trigger rect after possible CSS/layout changes
          const trigRect = triggerEl.getBoundingClientRect();

          // Position action nodes with support for horizontal If branching
          const actions = nodes.filter(n => n.type !== 'trigger');
          let currentTop = Math.round(trigRect.bottom - containerRect.top + VERTICAL_SPACING);

          const CONTROL_TYPES = new Set(['True', 'False']);
          const idxOf = (el) => nodes.findIndex(n => n.element === el);
          const getHeight = (el) => {
            const r = el.getBoundingClientRect();
            return Math.max(1, Math.round(r.height));
          };

          // Helper: determine if a global index lies within any IF block
          const inIfBlock = (gIndex) => {
            const d = nodes[gIndex]?.data;
            if (!d) return false;
            if (d.type === 'True' || d.type === 'False') return true;
            if (d.properties && d.properties.parentIfId) return true;
            return false;
          };

          for (let i = 0; i < actions.length; i++) {
            const n = actions[i];
            const el = n.element;
            if (!el) continue;
            const t = n.data?.type || '';

            if (t === 'If') {
              // Place IF centered
              el.style.left = '50%';
              el.style.transform = 'translateX(-50%)';
              el.style.top = `${currentTop}px`;
              const ifHeight = getHeight(el);
              const startY = currentTop + ifHeight + 80; // lower branch headers a bit

              // Locate True/False headers for this IF
              const globalIfIdx = idxOf(el);
              let trueIdx = -1, falseIdx = -1;
              for (let j = globalIfIdx + 1; j < nodes.length; j++) {
                const jt = nodes[j]?.data?.type;
                if (jt === 'If') break;
                if (jt === 'True' && trueIdx === -1) trueIdx = j;
                if (jt === 'False' && falseIdx === -1) falseIdx = j;
                if (trueIdx !== -1 && falseIdx !== -1) break;
              }

              // Layout branches: left column for TRUE, right column for FALSE
              let yTrue = startY;
              let yFalse = startY;
              const COLUMN_OFFSET = 280; // px from center
              const centerX = Math.round(containerRect.width / 2);
              const place = (node, side, y) => {
                const e = node.element;
                const cx = side === 'left' ? (centerX - COLUMN_OFFSET) : (centerX + COLUMN_OFFSET);
                e.style.left = `${cx}px`;
                e.style.transform = 'translateX(-50%)';
                e.style.top = `${y}px`;
                return y + getHeight(e) + VERTICAL_SPACING;
              };
              // Place headers if present
              if (trueIdx !== -1) yTrue = place(nodes[trueIdx], 'left', yTrue);
              if (falseIdx !== -1) yFalse = place(nodes[falseIdx], 'right', yFalse);

              // Place branch actions by matching parentIfId
              const ifId = nodes[globalIfIdx]?.data?.properties?.ifId;
              if (ifId) {
                for (let j = globalIfIdx + 1; j < nodes.length; j++) {
                  const d = nodes[j]?.data;
                  if (!d) continue;
                  if (d.type === 'If') break; // next block
                  if (d.type === 'True' || d.type === 'False') continue;
                  if (d.properties && d.properties.parentIfId === ifId) {
                    if (d.properties.branch === 'true') {
                      yTrue = place(nodes[j], 'left', yTrue);
                    } else if (d.properties.branch === 'false') {
                      yFalse = place(nodes[j], 'right', yFalse);
                    }
                  }
                }
              }

              // Advance currentTop to below the deeper branch end
              currentTop = Math.max(yTrue, yFalse) + 20;
              
              continue;
            }

            // Non-IF nodes: if already inside an IF block, don't override branch placement
            const gIdx = idxOf(el);
            if (inIfBlock(gIdx)) {
              // Move currentTop down to not overlap whatever was positioned by branches
              currentTop = Math.max(currentTop, Math.round(el.getBoundingClientRect().bottom - containerRect.top) + VERTICAL_SPACING);
            } else {
              // Centered linear placement
              el.style.left = '50%';
              el.style.transform = 'translateX(-50%)';
              el.style.top = `${currentTop}px`;
              currentTop += getHeight(el) + VERTICAL_SPACING;
            }
          }
        } catch (e) {
          console.warn('LayoutManager.apply error:', e);
        }
      }
    };

    
    
    // Notification function
    function showNotification(message, type = 'success') {
      // Create notification element
      const notification = document.createElement('div');
      notification.className = `fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg transition-all duration-300 transform translate-x-full`;
      notification.style.background = type === 'success' ? '#34D399' : '#EF4444';
      notification.style.color = '#ffffff';
      notification.style.minWidth = '300px';
      
      notification.innerHTML = `
        <div class="flex items-center justify-between">
          <span>${message}</span>
          <button onclick="this.parentElement.parentElement.remove()" class="button ml-4 text-white hover:text-gray-200">
            <span class="material-icons-outlined">close</span>
          </button>
        </div>
      `;
      
      document.body.appendChild(notification);
      
      // Animate in
      setTimeout(() => {
        notification.style.transform = 'translateX(0)';
      }, 100);
      
      // Auto remove after 5 seconds
      setTimeout(() => {
        notification.style.transform = 'translateX(full)';
        setTimeout(() => {
          if (notification.parentElement) {
            notification.remove();
          }
        }, 300);
      }, 5000);
    }

    // DOM elements
    const canvas = document.getElementById('flowchart-canvas');
    const container = document.getElementById('flowchart-container');
    const workflowNameInput = document.getElementById('workflow-name');
    const saveBtn = document.getElementById('save-workflow');
    const triggerModal = document.getElementById('trigger-modal');
    const actionModal = document.getElementById('action-modal');
    const contextModal = document.getElementById('context-modal');
    const errorsDrawer = document.getElementById('errors-drawer');
    const errorsList = document.getElementById('errors-list');
    const runsDrawer = document.getElementById('runs-drawer');
    const runsActive = document.getElementById('runs-active');
    const runsHistory = document.getElementById('runs-history');
    const runDetails = document.getElementById('run-details');

    

    function initializeCanvas() {
      // Canvas dragging functionality
      canvas.addEventListener('mousedown', (e) => {
        if (e.target === canvas || e.target === container) {
          // Ensure structure is fully aligned before first pan to avoid any jump
          if (!didFirstPanRefresh) {
            refreshStructure();
            didFirstPanRefresh = true;
          }
          isDragging = true;
          dragStart = { x: e.clientX, y: e.clientY };
          canvas.style.cursor = 'grabbing';
        }
      });

      canvas.addEventListener('mousemove', (e) => {
        if (isDragging) {
          const deltaX = e.clientX - dragStart.x;
          const deltaY = e.clientY - dragStart.y;
          
          canvasOffset.x += deltaX;
          canvasOffset.y += deltaY;
          
          container.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px)`;
          
          dragStart = { x: e.clientX, y: e.clientY };
        }
      });

      canvas.addEventListener('mouseup', () => {
        isDragging = false;
        canvas.style.cursor = 'grab';
      });

      canvas.addEventListener('mouseleave', () => {
        isDragging = false;
        canvas.style.cursor = 'grab';
      });

      // Save button event
              // saveBtn.addEventListener('click', saveWorkflow); // Removed duplicate - onclick already handles this
    }

    // Force-align nodes, connections and orbs based on current DOM metrics
    function refreshStructure() {
      try {
        LayoutManager.apply();
        WorkflowManager.updateAllConnections();
        OrbManager.updateAllOrbPositions();
      } catch (e) {
        console.warn('refreshStructure error:', e);
      }
    }

    async function loadWorkflow() {
      const id = localStorage.getItem('calendarify-current-workflow');
      if (id) {
        try {
          const token = getAnyToken();
          if (!token) return;
          
          const clean = token.replace(/^"|"$/g, '');
          const res = await fetch(`${API_URL}/workflows/${id}`, { 
            headers: { Authorization: `Bearer ${clean}` } 
          });
          
          if (res.ok) {
            currentWorkflow = await res.json();
            console.log('Loaded workflow:', currentWorkflow);
            
            const workflowData = currentWorkflow.data || currentWorkflow;
            console.log('Workflow data to load:', workflowData);
            
            if (workflowData.name || currentWorkflow.name) {
              const name = workflowData.name || currentWorkflow.name;
              workflowNameInput.value = name;
              console.log('Set workflow name input to:', name);
            }
            
            // Load existing nodes and connections
            if (workflowData.steps && Array.isArray(workflowData.steps)) {
              console.log('Loading steps:', workflowData.steps);
              
              // Clear existing nodes first - more thorough cleanup
              nodes.forEach(node => {
                if (node.element) {
                  node.element.remove();
                }
              });
              nodes = [];
              
              // Clear all orbs
              const existingOrbs = container.querySelectorAll('.add-action-orb, .insert-action-orb');
              existingOrbs.forEach(orb => orb.remove());
              
              // Clear all connection lines
              const existingLines = container.querySelectorAll('.connection-line');
              existingLines.forEach(line => line.remove());
              
              // Check if we have trigger data at the top level (for existing workflows)
              if (workflowData.trigger) {
                console.log('Found trigger at top level:', workflowData.trigger);
                const triggerData = {
                  type: workflowData.trigger,
                  properties: {
                    eventTypes: workflowData.triggerEventTypes || [],
                    tags: workflowData.triggerTags || []
                  }
                };
                updateTriggerNode(triggerData);
                
                // Remove guide text when loading existing workflow with configured trigger
                const helpText = container.querySelector('div[style*="Configure your trigger above"]');
                if (helpText) {
                  helpText.remove();
        } else {
                  // Try alternative selectors
                  const allDivs = container.querySelectorAll('div');
                  allDivs.forEach((div) => {
                    if (div.innerHTML && div.innerHTML.includes('Configure your trigger above')) {
                      div.remove();
                    }
                  });
                }
                
                // Also remove the CSS pseudo-element guide text by updating the trigger node
                const triggerNode = container.querySelector('.flowchart-node.trigger');
                if (triggerNode) {
                  triggerNode.classList.add('configured');
                }
                
                // Restore selected tags/event types for editing
                if (workflowData.trigger === 'Tag Added' && workflowData.triggerTags) {
                  window.selectedTags = [...workflowData.triggerTags];
                }
                if (workflowData.trigger === 'Meeting Scheduled') {
                  if (workflowData.triggerEventTypes) window.selectedEventTypes = [...workflowData.triggerEventTypes];
                  if (workflowData.triggerEventTypeIds) window.selectedEventTypeIds = [...workflowData.triggerEventTypeIds];
                }
        } else {
                // Try to find trigger in steps (for new format)
                const triggerStep = workflowData.steps.find(step => step.type === 'trigger');
                
                if (triggerStep) {
                  updateTriggerNode(triggerStep);
                  
                  // Restore selected tags/event types for editing
                  if (triggerStep.type === 'Tag Added' && triggerStep.properties?.tags) {
                    window.selectedTags = [...triggerStep.properties.tags];
                    console.log('Restored selected tags:', window.selectedTags);
                  }
                  if (triggerStep.type === 'Meeting Scheduled' && triggerStep.properties?.eventTypes) {
                    window.selectedEventTypes = [...triggerStep.properties.eventTypes];
                    if (triggerStep.properties?.eventTypeIds) window.selectedEventTypeIds = [...triggerStep.properties.eventTypeIds];
                    console.log('Restored selected event types:', window.selectedEventTypes);
                  }
                }
              }

              // Load actions (skip trigger since it's already loaded)
              workflowData.steps.forEach((step, index) => {
                if (step.type !== 'trigger') {
                  console.log('Loading action step:', step);
                  addActionNode(step, index);
                } else {
                  console.log('Skipping trigger step in actions loop:', step);
                }
              });
              
              // Load context spec if available, otherwise apply default
              if (workflowData.contextSpec) {
                contextSpec = workflowData.contextSpec;
              } else {
                contextSpec = getDefaultContextSpec();
              }

              // Rebuild the workflow structure after loading all nodes
              setTimeout(() => {
                StructureManager.rebuild(() => {
                  // Hide loading screen after orbs are loaded and positioned
                  hideLoadingScreen();
                });
              }, 100);
              }
            }
          } catch (error) {
          console.error('Error loading workflow:', error);
        }
      }
    }

    function createInitialTriggerNode() {
      const triggerNode = createNode('trigger', 'Click to configure trigger', 'play_circle', 'Click to configure trigger');
      triggerNode.style.left = '50%';
      triggerNode.style.top = '50px';
      triggerNode.style.transform = 'translateX(-50%)';
      
      // Override the click handler for the trigger node specifically
      triggerNode.removeEventListener('click', (e) => selectNode(triggerNode));
      triggerNode.addEventListener('click', (e) => {
        e.stopPropagation();
        openTriggerModal();
      });
      
      container.appendChild(triggerNode);
      nodes.push({ id: triggerNode.id, type: 'trigger', element: triggerNode });
      
      // Rebuild to add the orb below the trigger and hide loading screen
      StructureManager.rebuild(() => {
        hideLoadingScreen();
      });
      
      // Add movement listeners
      addNodeMovementListeners();
      
      // Add helpful text
      const helpText = document.createElement('div');
      helpText.style.position = 'absolute';
      helpText.style.left = '50%';
      helpText.style.top = '200px';
      helpText.style.transform = 'translateX(-50%)';
                  helpText.style.color = '#9ca3af';
      helpText.style.fontSize = '0.875rem';
      helpText.style.textAlign = 'center';
      helpText.innerHTML = 'Configure your trigger above, then add actions below to build your workflow';
      container.appendChild(helpText);
    }

    function createNode(type, title, icon, content) {
      const node = document.createElement('div');
      node.className = `flowchart-node ${type}`;
      node.id = `node-${++currentNodeId}`;
      node.dataset.stepType = type;
      // Consistent horizontal centering for all nodes
      node.style.left = '50%';
      node.style.transform = 'translateX(-50%)';
      
      if (type !== 'trigger') {
        node.innerHTML = `
          <div class="node-header">
            <span class="material-icons-outlined node-icon">${icon}</span>
            <div class="node-title">${title}</div>
            ${(['True','False'].includes(type)) ? '' : `
            <div class="node-actions">
              <button class="node-action-btn edit-btn" title="Edit Action">
                <span class="material-icons-outlined">edit</span>
              </button>
              <button class="node-action-btn delete-btn" title="Delete Action">
                <span class="material-icons-outlined">delete</span>
              </button>
            </div>`}
          </div>
          <div class="node-content">${content}</div>
        `;
        
        // Add edit and delete handlers unless True/False header
        if (!(['True','False'].includes(type))) {
          const editBtn = node.querySelector('.edit-btn');
          const deleteBtn = node.querySelector('.delete-btn');
          if (editBtn) editBtn.addEventListener('click', (e) => { e.stopPropagation(); editAction(node); });
          if (deleteBtn) deleteBtn.addEventListener('click', (e) => { e.stopPropagation(); deleteAction(node); });
        }
      } else {
        node.innerHTML = `
          <div class="node-header">
            <span class="material-icons-outlined node-icon">${icon}</span>
            <div class="node-title">${title}</div>
          </div>
          <div class="node-content">${content}</div>
        `;
      }
      
      // Add click handler for selection
      node.addEventListener('click', (e) => {
        e.stopPropagation();
        selectNode(node);
      });
      
      return node;
    }
    
    function selectNode(node) {
      // Deselect previously selected node
      if (selectedNode) {
        selectedNode.classList.remove('selected');
      }
      
      // Select new node
      selectedNode = node;
      node.classList.add('selected');
    }
    
    // Deselect when clicking on canvas
    container.addEventListener('click', (e) => {
      if (e.target === container) {
        if (selectedNode) {
          selectedNode.classList.remove('selected');
          selectedNode = null;
              }
            }
          });


    function openTriggerModal() {
      triggerModal.classList.remove('hidden');
      
      // Check if we're editing an existing trigger
      const triggerNode = nodes.find(n => n.type === 'trigger');
      if (triggerNode && triggerNode.data) {
        // Pre-populate the trigger type
        const triggerSelect = document.getElementById('trigger-select');
        if (triggerSelect) {
          triggerSelect.value = triggerNode.data.type;
        }
        
        // Restore selected tags if it's a Tag Added trigger
        if (triggerNode.data.type === 'Tag Added' && triggerNode.data.properties?.tags) {
          window.selectedTags = [...triggerNode.data.properties.tags];
        }
        
        // Restore selected event types if it's a Meeting Scheduled trigger
        if (triggerNode.data.type === 'Meeting Scheduled' && triggerNode.data.properties?.eventTypes) {
          window.selectedEventTypes = [...triggerNode.data.properties.eventTypes];
        }
      } else {
        // Reset for new trigger
        window.selectedTags = [];
      }
      
      renderTriggerProperties();
    }

    function closeTriggerModal() {
      triggerModal.classList.add('hidden');
    }

    function openActionModal(parentNodeId) {
      actionModal.classList.remove('hidden');
      selectedNode = parentNodeId;
      
      // Check if this is an insert operation
      if (parentNodeId === 'insert') {
        const modalTitle = actionModal.querySelector('.modal-title');
        if (modalTitle) {
          modalTitle.textContent = 'Insert Action';
        }
        
        const actionSaveBtn = document.getElementById('action-save-btn');
        if (actionSaveBtn) {
          actionSaveBtn.textContent = 'Insert Action';
        }
      }
      
      // Check if this is an "add after" operation
      if (parentNodeId && parentNodeId.startsWith('add-after-')) {
        const modalTitle = actionModal.querySelector('.modal-title');
        if (modalTitle) {
          modalTitle.textContent = 'Add Action';
        }
        
        const actionSaveBtn = document.getElementById('action-save-btn');
        if (actionSaveBtn) {
          actionSaveBtn.textContent = 'Add Action';
        }
      }
      
      // Check if we're editing an existing action
      const existingNode = nodes.find(n => n.id === parentNodeId);
      if (existingNode && existingNode.type !== 'trigger') {
        // Set the modal title to indicate editing
        const modalTitle = actionModal.querySelector('.modal-title');
        if (modalTitle) {
          modalTitle.textContent = 'Edit Action';
        }
        
        // Update button text
        const actionSaveBtn = document.getElementById('action-save-btn');
        if (actionSaveBtn) {
          actionSaveBtn.textContent = 'Update Action';
        }
        
        // Pre-populate the action type
        const actionSelect = document.getElementById('action-select');
        if (actionSelect) {
          actionSelect.value = existingNode.data.type;
        }
      } else {
        // Reset modal title for new actions
        const modalTitle = actionModal.querySelector('.modal-title');
        if (modalTitle) {
          modalTitle.textContent = 'Add Action';
        }
        
        // Reset button text
        const actionSaveBtn = document.getElementById('action-save-btn');
        if (actionSaveBtn) {
          actionSaveBtn.textContent = 'Add Action';
        }
      }
      
      // Reset selected action tag
      window.selectedActionTag = '';
      renderActionProperties();
    }

    function closeActionModal() {
      actionModal.classList.add('hidden');
      selectedNode = null;
      
      // Reset insert state
      window.insertConnection = null;
      
      // Reset modal title
      const modalTitle = actionModal.querySelector('.modal-title');
      if (modalTitle) {
        modalTitle.textContent = 'Add Action';
      }
      
      // Reset button text
      const actionSaveBtn = document.getElementById('action-save-btn');
      if (actionSaveBtn) {
        actionSaveBtn.textContent = 'Add Action';
      }
    }

    // Context modal handlers
    function openContextModal() {
      try {
        if (!contextSpec) contextSpec = getDefaultContextSpec();
        document.getElementById('context-attach-full').checked = !!contextSpec.attachFullContext;
        const schemaEl = document.getElementById('context-schema');
        schemaEl.textContent = JSON.stringify(contextSpec.schema || getDefaultContextSchema(), null, 2);
        const sampleEl = document.getElementById('context-sample');
        sampleEl.value = contextSpec.sample ? JSON.stringify(contextSpec.sample, null, 2) : '';
      } catch (e) {
        console.warn('Error opening context modal:', e);
      }
      contextModal.classList.remove('hidden');
    }

    function closeContextModal() {
      contextModal.classList.add('hidden');
    }

    function saveContextSpec() {
      const attachFull = document.getElementById('context-attach-full').checked;
      const sampleText = document.getElementById('context-sample').value.trim();
      let sample = null;
      if (sampleText) {
        try {
          sample = JSON.parse(sampleText);
        } catch (e) {
          showNotification('Invalid JSON in sample payload', 'error');
          return;
        }
      }
      contextSpec = {
        ...(contextSpec || {}),
        version: 1,
        attachFullContext: attachFull,
        scope: attachFull ? 'full' : (contextSpec?.scope || 'full'),
        schema: contextSpec?.schema || getDefaultContextSchema(),
        sample: sample || null
      };
      closeContextModal();
      showNotification('Context settings saved');
    }

    async function copyContextSchema() {
      try {
        const schema = (contextSpec && contextSpec.schema) ? contextSpec.schema : getDefaultContextSchema();
        await navigator.clipboard.writeText(JSON.stringify(schema, null, 2));
        const s = document.getElementById('context-schema-copy-status');
        if (s) {
          s.textContent = 'Copied';
          setTimeout(() => { s.textContent = ''; }, 1500);
        }
      } catch (e) {
        console.warn('Copy schema failed:', e);
        showNotification('Failed to copy schema', 'error');
      }
    }

    function renderTriggerProperties() {
      const container = document.getElementById('trigger-properties');
      const triggerType = document.getElementById('trigger-select').value;
      
      let html = '';
      
      if (triggerType === 'Meeting Scheduled') {
        html = `
          <div class="form-group">
            <label class="form-label">Event Types</label>
            <div class="multi-select">
              <button type="button" class="multi-select-button" onclick="toggleMultiSelect('event-type')">
                <span>Select event types...</span>
                <span class="material-icons-outlined">expand_more</span>
                    </button>
              <div class="multi-select-options" id="event-type-options">
                <!-- Event types will be populated here -->
                  </div>
              <button type="button" class="select-all-btn" onclick="selectAllEventTypes()">Select All</button>
                  </div>
                </div>
        `;
      } else if (triggerType === 'Tag Added') {
        html = `
          <div class="form-group">
            <label class="form-label">Tags</label>
            <div class="multi-select">
              <button type="button" class="multi-select-button" onclick="toggleMultiSelect('tag')">
                <span id="tag-display">Select tags...</span>
                <span class="material-icons-outlined">expand_more</span>
              </button>
              <div class="multi-select-options" id="tag-options">
                <!-- Tags will be populated here -->
                  </div>
              <button type="button" class="select-all-btn" onclick="selectAllTags()">Select All</button>
                </div>
            <div class="mt-3" id="tag-confirm" style="display: none;">
              <button type="button" class="btn-primary w-full" onclick="confirmTagSelection()">
                Confirm Tag Selection
              </button>
              </div>
            </div>
        `;
      }
      
      container.innerHTML = html;
      
      // Reset selected tags when changing trigger type
      if (triggerType === 'Tag Added') {
        window.selectedTags = [];
        // Hide confirm button initially
        setTimeout(() => {
          const confirmBtn = document.getElementById('tag-confirm');
          if (confirmBtn) {
            confirmBtn.style.display = 'none';
          }
        }, 100);
      }
      
      // Populate options
      if (triggerType === 'Meeting Scheduled') {
        populateEventTypes();
      } else if (triggerType === 'Tag Added') {
        populateTags();
      }
      
      // Reset selected arrays when changing trigger type
      if (triggerType === 'Tag Added') {
        // Don't reset if we're editing and have existing tags
        if (!window.selectedTags || window.selectedTags.length === 0) {
          window.selectedTags = [];
        }
        window.selectedEventTypes = [];
      } else if (triggerType === 'Meeting Scheduled') {
        // Don't reset if we're editing and have existing event types
        if (!window.selectedEventTypes || window.selectedEventTypes.length === 0) {
          window.selectedEventTypes = [];
        }
        window.selectedTags = [];
      } else {
        window.selectedTags = [];
        window.selectedEventTypes = [];
      }
    }

    function renderActionProperties() {
      const container = document.getElementById('action-properties');
      const actionType = document.getElementById('action-select').value;
      
      let html = '';
      
      if (actionType === 'Add Tag') {
        html = `
          <div class="form-group">
            <label class="form-label">Tag to Add</label>
              <div class="multi-select">
              <button type="button" class="multi-select-button" onclick="toggleMultiSelect('action-tag')">
                <span id="action-tag-display">Select tag...</span>
                <span class="material-icons-outlined">expand_more</span>
                </button>
              <div class="multi-select-options" id="action-tag-options">
                <!-- Available tags will be populated here -->
                </div>
              </div>
            <div class="mt-3" id="action-tag-confirm" style="display: none;">
              <button type="button" class="btn-primary w-full" onclick="confirmActionTag()">
                Confirm Tag Selection
              </button>
            </div>
          </div>
        `;
        
        // Reset selected tag when changing action type
        window.selectedActionTag = '';
        
        // Hide confirm button initially
        setTimeout(() => {
          const confirmBtn = document.getElementById('action-tag-confirm');
          if (confirmBtn) {
            confirmBtn.style.display = 'none';
          }
        }, 100);
        
        // Populate the action tag options after rendering
        setTimeout(() => populateActionTags(), 100);
      }
      
      if (actionType === 'Send Email') {
        html = `
          <div class="form-group">
            <label class="form-label" style="display:flex;align-items:center;gap:.5rem">
              <input type="checkbox" id="email-manual-recipient" /> Specify recipient manually
            </label>
            <div id="email-to-wrapper" style="margin-top:.5rem;display:none">
              <label class="form-label">To</label>
              <input id="email-to" class="form-select" placeholder="email1@example.com, email2@example.com" />
            </div>
            <div style="margin-top:.25rem;color:#9ca3af;font-size:.85rem">When unchecked, the email is sent to the contact who triggered the workflow.</div>
          </div>
          <div class="form-group">
            <label class="form-label">CC</label>
            <input id="email-cc" class="form-select" placeholder="Optional: comma-separated" />
          </div>
          <div class="form-group">
            <label class="form-label">BCC</label>
            <input id="email-bcc" class="form-select" placeholder="Optional: comma-separated" />
          </div>
          <div class="form-group">
            <label class="form-label">Subject</label>
            <input id="email-subject" class="form-select" placeholder="Subject line" />
          </div>
          <div class="form-group">
            <label class="form-label" style="display:flex;align-items:center;gap:.5rem">
              <input type="checkbox" id="email-is-html" /> Use HTML body
            </label>
          </div>
          <div class="form-group">
            <label class="form-label">Body</label>
            <textarea id="email-body" style="width:100%;min-height:160px;background:#1E3A34;border:1px solid #2C4A43;border-radius:.5rem;padding:.75rem;color:#E0E0E0"></textarea>
            <div style="margin-top:.25rem;color:#9ca3af;font-size:.85rem">Tip: Future versions support tokens like {{contact.fullName}}.</div>
          </div>
        `;
      }

      if (actionType === 'If') {
        const triggerNode = nodes.find(n => n.type === 'trigger');
        const triggerType = triggerNode?.data?.type || 'Meeting Scheduled';
        const contactFields = [
          ['contact.id','ID'],
          ['contact.firstName','First name'],
          ['contact.lastName','Last name'],
          ['contact.fullName','Full name'],
          ['contact.email','Email'],
          ['contact.phone','Phone'],
          ['contact.timezone','Timezone'],
          ['contact.locale','Locale'],
          ['contact.company','Company'],
          ['contact.title','Title'],
          ['contact.tags','Tags'],
          ['contact.notes','Notes'],
          ['contact.createdAt','Created at'],
          ['contact.updatedAt','Updated at']
        ];
        const bookingFields = [
          ['booking.id','ID'],
          ['booking.title','Title'],
          ['booking.status','Status'],
          ['booking.eventType','Event type'],
          ['booking.startTime','Start time'],
          ['booking.endTime','End time'],
          ['booking.durationMinutes','Duration (minutes)'],
          ['booking.timezone','Timezone'],
          ['booking.location','Location'],
          ['booking.meetingLink','Meeting link'],
          ['booking.rescheduleCount','Reschedule count'],
          ['booking.createdAt','Created at'],
          ['booking.updatedAt','Updated at']
        ];
        const defaultField = 'contact.email';
        // Build event-type-aware answer keys for the selected trigger configuration
        let dynamicAnswersOptions = '';
        try {
          const cache = Array.isArray(window.eventTypesCache) ? window.eventTypesCache : [];
          const slugifyKey = (s) => (s || '').toString().trim().toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '').substring(0,64);
          let subset = [];
          if (triggerType === 'Meeting Scheduled') {
            const ids = (window.selectedEventTypeIds && window.selectedEventTypeIds.length)
              ? window.selectedEventTypeIds
              : (triggerNode?.data?.properties?.eventTypeIds || []);
            if (Array.isArray(ids) && ids.length > 0) subset = cache.filter(et => ids.includes(et.id));
          } else if (triggerType === 'Tag Added') {
            subset = cache;
          }
          const seen = new Set();
          const list = [];
          subset.forEach(et => {
            if (Array.isArray(et?.questions)) {
              et.questions.forEach(q => {
                const label = (q && (q.text || q.label)) ? (q.text || q.label) : null;
                if (!label) return;
                const key = slugifyKey(label);
                if (key && !seen.has(key)) {
                  seen.add(key);
                  list.push({ key, label, etTitle: et.title });
                }
              });
            }
          });
          if (list.length > 0) {
            dynamicAnswersOptions += list.map(q => `
              <label class="multi-select-option" data-category="answers" data-text="${('booking.answers.'+q.key).toLowerCase()} ${q.label.toLowerCase()} ${q.etTitle.toLowerCase()}" onclick="selectIfField('booking.answers.${q.key}')">
                <span>${q.label} <span style=\"color:#6b7280\">(${q.etTitle})</span></span>
              </label>
            `).join('');
          }
        } catch (e) {
          // Non-fatal: fall back to manual entry only
        }
        if (!window.eventTypesCache) {
          // Lazy-load event types and re-render the If form once ready
          try {
            populateEventTypes().then(() => {
              const sel = document.getElementById('action-select');
              if (sel && sel.value === 'If') {
                renderActionProperties();
              }
            });
          } catch (_) {}
        }

        html = `
          ${triggerType === 'Tag Added' ? `
          <div style="background:#2c1f1f;border:1px solid #7f1d1d;color:#fca5a5;padding:.75rem;border-radius:.5rem;margin-bottom:.75rem">
            Warning: For Tag Added triggers, this condition can reference any event type's data. If the contact lacks the required data, evaluation will error and default to the false path.
          </div>` : ''}

          <div class="form-group">
            <label class="form-label">Field</label>
            <div class="multi-select">
              <button type="button" class="multi-select-button" onclick="toggleMultiSelect('if-field')">
                <span id="if-field-display">${defaultField}</span>
                <span class="material-icons-outlined">expand_more</span>
              </button>
              <div class="multi-select-options" id="if-field-options" style="max-height:340px;overflow:auto">
                <div style="padding:.5rem .75rem;border-bottom:1px solid #2C4A43;position:sticky;top:0;background:#0b1916;z-index:1">
                  <input id="if-field-search" class="form-select" placeholder="Search fields..." oninput="filterIfFieldOptions()" />
                  <div id="if-field-categories" style="display:flex;gap:.5rem;margin-top:.5rem;flex-wrap:wrap">
                    <button type="button" class="context-btn" data-cat="all" onclick="setIfFieldCategory('all')">All</button>
                    <button type="button" class="context-btn" data-cat="contact" onclick="setIfFieldCategory('contact')">Contact</button>
                    <button type="button" class="context-btn" data-cat="booking" onclick="setIfFieldCategory('booking')">Booking</button>
                    <button type="button" class="context-btn" data-cat="answers" onclick="setIfFieldCategory('answers')">Answers</button>
                    <button type="button" class="context-btn" data-cat="custom" onclick="setIfFieldCategory('custom')">Custom</button>
                  </div>
                </div>
                <div id="if-field-list" style="padding-top:.5rem">
                  <div class="if-cat-header" data-category="contact" style="padding:.5rem .75rem;color:#9ca3af;font-size:.8rem">Contact</div>
                  ${contactFields.map(([f,label]) => `<label class=\"multi-select-option\" data-category=\"contact\" data-text=\"${(label+' '+f).toLowerCase()}\" onclick=\"selectIfField('${f}')\"><span>${label} <span style=\\"color:#6b7280\\">(${f})</span></span></label>`).join('')}
                  <div class="if-cat-header" data-category="booking" style="padding:.5rem .75rem;color:#9ca3af;font-size:.8rem">Booking</div>
                  ${bookingFields.map(([f,label]) => `<label class=\"multi-select-option\" data-category=\"booking\" data-text=\"${(label+' '+f).toLowerCase()}\" onclick=\"selectIfField('${f}')\"><span>${label} <span style=\\"color:#6b7280\\">(${f})</span></span></label>`).join('')}
                  <div class="if-cat-header" data-category="answers" style="padding:.5rem .75rem;color:#9ca3af;font-size:.8rem">Available Answers</div>
                  ${dynamicAnswersOptions}
                  <div class="if-cat-header" data-category="custom" style="padding:.5rem .75rem;color:#9ca3af;font-size:.8rem">Custom Answers</div>
                  <div id="if-custom-answers-container" data-category="custom" style="padding:.5rem .75rem">
                    <input id="if-custom-answer-key" class="form-select" placeholder="answers.<questionKey> or booking.answers.<key>" />
                    <div style="margin-top:.25rem;text-align:right">
                      <button type="button" class="context-btn" onclick="applyIfCustomAnswer()">Use</button>
                    </div>
                    <div style="margin-top:.35rem;color:#9ca3af;font-size:.85rem">
                      Not sure which key to use? See the <a href="/editor/guide#custom-keys" target="_blank" style="color:#34D399;text-decoration:none">Custom Keys guide</a>.
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="form-group">
            <label class="form-label">Operator</label>
            <select id="if-operator" class="form-select">
              <option value="equals">Equals</option>
              <option value="not_equals">Does not equal</option>
              <option value="contains">Contains</option>
              <option value="not_contains">Does not contain</option>
              <option value="gt">Greater than</option>
              <option value="lt">Less than</option>
              <option value="exists">Exists</option>
              <option value="not_exists">Does not exist</option>
              <option value="in">In list (comma separated)</option>
            </select>
          </div>

          <div class="form-group" id="if-value-group">
            <label class="form-label">Value</label>
            <input id="if-value" class="form-select" placeholder="Value or CSV for 'in'" />
            <div style="margin-top:.25rem;color:#9ca3af;font-size:.85rem">Numbers compare numerically; others compare as strings. Use ISO dates for lexicographic comparisons.</div>
          </div>

          <input type="hidden" id="if-field" value="${defaultField}" />
        `;
      }
      
      container.innerHTML = html;

      // If editing, prefill Send Email fields
      if (actionType === 'Send Email' && selectedNode) {
        const existingNode = nodes.find(n => n.id === selectedNode);
        if (existingNode && existingNode.data && existingNode.data.type === 'Send Email') {
          const p = existingNode.data.properties || {};
          const set = (id, val) => { const el = document.getElementById(id); if (el && val !== undefined && val !== null) el.value = val; };
          const manualEl = document.getElementById('email-manual-recipient');
          const toWrap = document.getElementById('email-to-wrapper');
          const manual = !(p.useTriggerRecipient === true || (!p.to || (Array.isArray(p.to) && p.to.length === 0)));
          if (manualEl) manualEl.checked = manual;
          if (toWrap) toWrap.style.display = manual ? 'block' : 'none';
          set('email-to', Array.isArray(p.to) ? p.to.join(', ') : (p.to || ''));
          set('email-cc', Array.isArray(p.cc) ? p.cc.join(', ') : (p.cc || ''));
          set('email-bcc', Array.isArray(p.bcc) ? p.bcc.join(', ') : (p.bcc || ''));
          set('email-subject', p.subject || '');
          const bodyEl = document.getElementById('email-body');
          if (bodyEl) bodyEl.value = p.body || '';
          const htmlEl = document.getElementById('email-is-html');
          if (htmlEl) htmlEl.checked = !!p.isHtml;
        }
      }

      // Wire up manual recipient toggle (for create/edit)
      if (actionType === 'Send Email') {
        const manualEl = document.getElementById('email-manual-recipient');
        const toWrap = document.getElementById('email-to-wrapper');
        if (manualEl && toWrap) {
          const sync = () => { toWrap.style.display = manualEl.checked ? 'block' : 'none'; };
          manualEl.addEventListener('change', sync);
          sync();
        }
      }

      if (actionType === 'If') {
        // Toggle visibility of value field for exists/not_exists
        const opEl = document.getElementById('if-operator');
        const valueGroup = document.getElementById('if-value-group');
        if (opEl && valueGroup) {
          const sync = () => {
            const op = opEl.value;
            valueGroup.style.display = ['exists','not_exists'].includes(op) ? 'none' : 'block';
          };
          opEl.addEventListener('change', sync);
          sync();
        }

        // Prefill If when editing
        if (selectedNode) {
          const nodeData = nodes.find(n => n.id === selectedNode);
          if (nodeData && nodeData.data && nodeData.data.type === 'If') {
            const p = nodeData.data.properties || {};
            const field = p.field || 'contact.email';
            const operator = p.operator || 'equals';
            const value = p.value ?? '';
            const fieldDisplay = document.getElementById('if-field-display');
            const fieldHidden = document.getElementById('if-field');
            const opSelect = document.getElementById('if-operator');
            const valueEl = document.getElementById('if-value');
            if (fieldDisplay) fieldDisplay.textContent = field;
            if (fieldHidden) fieldHidden.value = field;
            if (opSelect) opSelect.value = operator;
            if (valueEl && value !== undefined) valueEl.value = Array.isArray(value) ? value.join(', ') : value;
          }
        }

        // Initialize category and search state
        setIfFieldCategory('all');
        filterIfFieldOptions();
      }
    }

    async function populateEventTypes() {
      try {
        const token = getAnyToken();
        if (!token) return;
        
        const clean = token.replace(/^"|"$/g, '');
        const res = await fetch(`${API_URL}/event-types`, { 
          headers: { Authorization: `Bearer ${clean}` } 
        });
        
        if (res.ok) {
          const eventTypes = await res.json();
          // Cache event types for conditional builder (If action)
          window.eventTypesCache = Array.isArray(eventTypes) ? eventTypes : [];
          const container = document.getElementById('event-type-options');
          
          container.innerHTML = eventTypes.map(et => `
            <label class="multi-select-option" onclick="selectEventType('${et.id}', '${et.title.replace(/'/g, "&#39;")}')">
              <span>${et.title}</span>
            </label>
          `).join('');
          
          // Restore selected event types if they exist
          if (window.selectedEventTypes && window.selectedEventTypes.length > 0) {
            const display = document.querySelector('#event-type-options').previousElementSibling.querySelector('span');
            if (display) {
              display.textContent = window.selectedEventTypes.join(', ');
            }
          }
        }
      } catch (error) {
        console.error('Error fetching event types:', error);
      }
    }

    async function populateTags() {
      try {
        const token = getAnyToken();
        if (!token) return;
        
        const clean = token.replace(/^"|"$/g, '');
        const res = await fetch(`${API_URL}/tags`, { 
          headers: { Authorization: `Bearer ${clean}` } 
        });
        
        if (res.ok) {
          const tags = await res.json();
          const container = document.getElementById('tag-options');
          
          container.innerHTML = tags.map(tag => `
            <label class="multi-select-option" onclick="selectTag('${tag.name}')">
              <span>${tag.name}</span>
            </label>
          `).join('');
          
          // Restore selected tags if they exist
          if (window.selectedTags && window.selectedTags.length > 0) {
            const display = document.getElementById('tag-display');
            if (display) {
              display.textContent = window.selectedTags.join(', ');
              display.style.color = '#34D399';
            }
            
            // Show confirm button if tags are selected
            const confirmBtn = document.getElementById('tag-confirm');
            if (confirmBtn) {
              confirmBtn.style.display = 'block';
            }
          }
        }
      } catch (error) {
        console.error('Error fetching tags:', error);
      }
    }

    async function populateActionTags() {
      try {
        const token = getAnyToken();
        if (!token) return;
        
        const clean = token.replace(/^"|"$/g, '');
        const res = await fetch(`${API_URL}/tags`, { 
          headers: { Authorization: `Bearer ${clean}` } 
        });
        
        if (res.ok) {
          const tags = await res.json();
          const container = document.getElementById('action-tag-options');
          
          container.innerHTML = tags.map(tag => `
            <label class="multi-select-option" onclick="selectActionTag('${tag.name}')">
              <span>${tag.name}</span>
            </label>
          `).join('');
        }
      } catch (error) {
        console.error('Error fetching action tags:', error);
      }
    }

    function toggleMultiSelect(type) {
      const options = document.getElementById(`${type}-options`);
      if (options) {
        options.classList.toggle('show');
        
        // Close other open dropdowns
        document.querySelectorAll('.multi-select-options').forEach(other => {
          if (other !== options) {
            other.classList.remove('show');
          }
        });
      }
    }
    
    // Close dropdowns when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.multi-select')) {
        document.querySelectorAll('.multi-select-options').forEach(dropdown => {
          dropdown.classList.remove('show');
        });
      }
    });

    function selectEventType(eventTypeId, eventTypeName) {
      if (!window.selectedEventTypes) window.selectedEventTypes = [];
      if (!window.selectedEventTypeIds) window.selectedEventTypeIds = [];
      
      const idxName = window.selectedEventTypes.indexOf(eventTypeName);
      const idxId = window.selectedEventTypeIds.indexOf(eventTypeId);
      const isSelected = idxName > -1 || idxId > -1;
      if (isSelected) {
        if (idxName > -1) window.selectedEventTypes.splice(idxName, 1);
        if (idxId > -1) window.selectedEventTypeIds.splice(idxId, 1);
      } else {
        window.selectedEventTypes.push(eventTypeName);
        window.selectedEventTypeIds.push(eventTypeId);
      }
      
      // Update display
      const display = document.querySelector('#event-type-options').previousElementSibling.querySelector('span');
      if (display) {
        if (window.selectedEventTypes.length > 0) {
          display.textContent = window.selectedEventTypes.join(', ');
        } else {
          display.textContent = 'Select event types...';
        }
      }
      
      // Close the dropdown
      const options = document.getElementById('event-type-options');
      if (options) {
        options.classList.remove('show');
      }
    }
    
    function selectAllEventTypes() {
      // Get all available event types from the options
      const eventTypeOptions = document.querySelectorAll('#event-type-options .multi-select-option span');
      if (eventTypeOptions.length > 0) {
        window.selectedEventTypes = Array.from(eventTypeOptions).map(span => span.textContent);
        
        // Update display
        const display = document.querySelector('#event-type-options').previousElementSibling.querySelector('span');
        if (display) {
          display.textContent = window.selectedEventTypes.join(', ');
        }
      }
    }

    function selectAllTags() {
      // Get all available tags from the options
      const tagOptions = document.querySelectorAll('#tag-options .multi-select-option span');
      if (tagOptions.length > 0) {
        window.selectedTags = Array.from(tagOptions).map(span => span.textContent);
        
        // Update display
        const display = document.getElementById('tag-display');
        if (display) {
          display.textContent = window.selectedTags.join(', ');
        }
        
        // Show confirm button
        const confirmBtn = document.getElementById('tag-confirm');
        if (confirmBtn) {
          confirmBtn.style.display = 'block';
        }
      }
    }

        function selectActionTag(tagName) {
      const display = document.getElementById('action-tag-display');
      if (display) {
        display.textContent = tagName;
      }
      
      // Close the dropdown
      const options = document.getElementById('action-tag-options');
      if (options) {
        options.classList.remove('show');
      }
      
      // Store the selected tag for later use
      window.selectedActionTag = tagName;

      // Show confirm button
      const confirmBtn = document.getElementById('action-tag-confirm');
      if (confirmBtn) {
        confirmBtn.style.display = 'block';
      }
    }
    
    function confirmTagSelection() {
      // Hide confirm button after confirmation
      const confirmBtn = document.getElementById('tag-confirm');
      if (confirmBtn) {
        confirmBtn.style.display = 'none';
      }
      
      // Update display to show confirmed selection
      const display = document.getElementById('tag-display');
      if (display && window.selectedTags && window.selectedTags.length > 0) {
        display.textContent = `✓ ${window.selectedTags.join(', ')}`;
        display.style.color = '#34D399';
      }
    }
    
    function selectTag(tagName) {
      // Initialize selectedTags array if it doesn't exist
      if (!window.selectedTags) {
        window.selectedTags = [];
      }
      
      // Toggle tag selection
      const index = window.selectedTags.indexOf(tagName);
      if (index > -1) {
        window.selectedTags.splice(index, 1);
      } else {
        window.selectedTags.push(tagName);
      }
      
      // Update display
      const display = document.getElementById('tag-display');
      if (display) {
        if (window.selectedTags.length > 0) {
          display.textContent = window.selectedTags.join(', ');
          // Show confirm button
          const confirmBtn = document.getElementById('tag-confirm');
          if (confirmBtn) {
            confirmBtn.style.display = 'block';
          }
          } else {
          display.textContent = 'Select tags...';
          // Hide confirm button
          const confirmBtn = document.getElementById('tag-confirm');
          if (confirmBtn) {
            confirmBtn.style.display = 'none';
          }
        }
      }
      
      // Close the dropdown
      const options = document.getElementById('tag-options');
      if (options) {
        options.classList.remove('show');
      }
    }

    function confirmActionTag() {
      // Hide confirm button after confirmation
      const confirmBtn = document.getElementById('action-tag-confirm');
      if (confirmBtn) {
        confirmBtn.style.display = 'none';
      }
      
      // Update display to show confirmed selection
      const display = document.getElementById('action-tag-display');
      if (display && window.selectedActionTag) {
        display.textContent = `✓ ${window.selectedActionTag}`;
        display.style.color = '#34D399';
      }
    }

    // IF action helpers
    function selectIfField(fieldPath) {
      const display = document.getElementById('if-field-display');
      const hidden = document.getElementById('if-field');
      if (display) display.textContent = fieldPath;
      if (hidden) hidden.value = fieldPath;
      const options = document.getElementById('if-field-options');
      if (options) options.classList.remove('show');
    }

    function applyIfCustomAnswer() {
      const input = document.getElementById('if-custom-answer-key');
      if (!input) return;
      let key = input.value.trim();
      if (!key) return;
      // Normalize to booking.answers.<key> if user typed shorthand answers.<key>
      if (key.startsWith('answers.')) key = `booking.${key}`;
      if (!key.startsWith('booking.answers.')) key = `booking.answers.${key}`;
      selectIfField(key);
    }

    // Category + search for IF field dropdown
    window.currentIfFieldCategory = 'all';
    function setIfFieldCategory(cat) {
      window.currentIfFieldCategory = cat;
      // Update button active styles
      const btns = document.querySelectorAll('#if-field-categories .context-btn');
      btns.forEach(b => {
        if (b.getAttribute('data-cat') === cat) {
          b.style.background = '#34D399';
          b.style.color = '#1A2E29';
        } else {
          b.style.background = '';
          b.style.color = '';
        }
      });
      filterIfFieldOptions();
    }

    function filterIfFieldOptions() {
      const searchEl = document.getElementById('if-field-search');
      const q = (searchEl ? searchEl.value : '').toLowerCase().trim();
      const cat = window.currentIfFieldCategory || 'all';
      const list = document.getElementById('if-field-options');
      if (!list) return;
      const items = list.querySelectorAll('label.multi-select-option, .if-cat-header, #if-custom-answers-container');

      // First pass: show/hide by category
      items.forEach(el => {
        const elCat = el.getAttribute('data-category');
        let showByCat = cat === 'all' || (elCat ? elCat === cat : true);
        // Always keep sticky header (search/categories wrapper) visible
        if (el.id === 'if-field-categories' || el.id === 'if-field-search') showByCat = true;
        el.style.display = showByCat ? '' : 'none';
      });

      // Second pass: apply search filter within visible category
      if (q) {
        items.forEach(el => {
          if (el.tagName.toLowerCase() === 'label') {
            if (el.style.display === 'none') return; // already hidden by category
            const text = (el.getAttribute('data-text') || el.textContent || '').toLowerCase();
            el.style.display = text.includes(q) ? '' : 'none';
          }
        });
        // Hide headers with no following visible items of same category
        const headers = list.querySelectorAll('.if-cat-header');
        headers.forEach(h => {
          if (h.style.display === 'none') return;
          const hCat = h.getAttribute('data-category');
          let hasVisible = false;
          let next = h.nextElementSibling;
          while (next && !next.classList.contains('if-cat-header')) {
            if (next.style.display !== 'none') { hasVisible = true; break; }
            next = next.nextElementSibling;
          }
          h.style.display = hasVisible ? '' : 'none';
        });
      } else {
        // No search: show headers relevant to selected category
        const headers = list.querySelectorAll('.if-cat-header');
        headers.forEach(h => {
          const hCat = h.getAttribute('data-category');
          h.style.display = (cat === 'all' || hCat === cat) ? '' : 'none';
        });
      }
    }

    function saveTrigger() {
      const triggerType = document.getElementById('trigger-select').value;
      const triggerNode = nodes.find(n => n.type === 'trigger');
      
      if (!triggerNode) return;
      
      let properties = {};
      
      if (triggerType === 'Meeting Scheduled') {
        properties.eventTypes = window.selectedEventTypes || [];
        properties.eventTypeIds = window.selectedEventTypeIds || [];
        console.log('Saving trigger with event types:', properties.eventTypes, properties.eventTypeIds);
      } else if (triggerType === 'Tag Added') {
        properties.tags = window.selectedTags || [];
        console.log('Saving trigger with tags:', properties.tags);
      }
      
      // Update trigger node
      updateTriggerNode({ type: triggerType, properties });
      
      // Remove guide text when trigger is configured
      const helpText = container.querySelector('div[style*="Configure your trigger above"]');
      if (helpText) {
        helpText.remove();
      } else {
        // Try alternative selectors
        const allDivs = container.querySelectorAll('div');
        allDivs.forEach((div) => {
          if (div.innerHTML && div.innerHTML.includes('Configure your trigger above')) {
            div.remove();
          }
        });
      }
      
      // Also remove the CSS pseudo-element guide text by updating the trigger node
      const triggerNodeElement = container.querySelector('.flowchart-node.trigger');
      if (triggerNodeElement) {
        triggerNodeElement.classList.add('configured');
      }
      
      closeTriggerModal();
    }

    function saveAction() {
      const actionType = document.getElementById('action-select').value;
      const parentNodeId = selectedNode;
      
      if (!parentNodeId) return;
      
      let properties = {};
      
      if (actionType === 'Add Tag') {
        properties.tag = window.selectedActionTag || '';
      }
      if (actionType === 'Send Email') {
        const val = id => {
          const el = document.getElementById(id);
          return el ? el.value.trim() : '';
        };
        const csv = s => s ? s.split(',').map(x => x.trim()).filter(Boolean) : [];
        const manual = !!(document.getElementById('email-manual-recipient')?.checked);
        const toList = csv(val('email-to'));
        properties = {
          useTriggerRecipient: !manual,
          to: manual ? toList : [],
          cc: csv(val('email-cc')),
          bcc: csv(val('email-bcc')),
          subject: val('email-subject'),
          body: val('email-body'),
          isHtml: !!(document.getElementById('email-is-html')?.checked)
        };
        if (manual && !toList.length) {
          alert('Please provide at least one recipient in To');
          return;
        }
        if (!properties.subject) {
          alert('Please provide an email subject');
          return;
        }
        if (!properties.body) {
          alert('Please provide an email body');
          return;
        }
      }
      if (actionType === 'If') {
        const field = document.getElementById('if-field')?.value?.trim();
        const operator = document.getElementById('if-operator')?.value;
        const rawValue = document.getElementById('if-value')?.value ?? '';
        if (!field || !operator) {
          alert('Please select a field and operator for the If condition');
          return;
        }
        let value = rawValue;
        if (['gt','lt'].includes(operator)) {
          const n = Number(rawValue);
          if (!Number.isFinite(n)) {
            alert('Please enter a valid number for the comparison');
            return;
          }
          value = n;
        } else if (operator === 'in') {
          value = (rawValue || '').split(',').map(s => s.trim()).filter(Boolean);
          if (value.length === 0) {
            alert('Please provide at least one list item for the "in" operator');
            return;
          }
        }
        const triggerType = nodes.find(n => n.type === 'trigger')?.data?.type || 'Meeting Scheduled';
        properties = { field, operator };
        if (!['exists','not_exists'].includes(operator)) properties.value = value;
        properties.triggerType = triggerType;
        if (triggerType === 'Tag Added') properties.missingDataBehavior = 'default_false_path_on_error';
      }
      
      if (actionType === 'Add Tag' && !properties.tag) {
        alert('Please select a tag');
        return;
      }
      
      // Check if this is an insert operation
      if (parentNodeId === 'insert' && window.insertConnection) {
        const inserted = insertActionBetween({ type: actionType, properties }, window.insertConnection);
        // If IF, auto-create True/False headers
        if (actionType === 'If' && inserted && inserted.element) {
          if (!inserted.data.properties) inserted.data.properties = {};
          if (!inserted.data.properties.ifId) inserted.data.properties.ifId = `if_${Date.now()}_${Math.random().toString(36).slice(2)}`;
          const trueNode = addControlNodeAfterElement(inserted.element, 'True');
          const falseNode = addControlNodeAfterElement(inserted.element, 'False');
          if (trueNode && trueNode.element) trueNode.data = { type: 'True', properties: { parentIfId: inserted.data.properties.ifId, ifDomId: inserted.element.id, branch: 'true' } };
          if (falseNode && falseNode.element) falseNode.data = { type: 'False', properties: { parentIfId: inserted.data.properties.ifId, ifDomId: inserted.element.id, branch: 'false' } };
        }
        window.insertConnection = null;
        closeActionModal();
        return;
      }
      // Branch insertions from IF node (True / False columns)
      if (parentNodeId && parentNodeId.startsWith('branch-true-')) {
        const ifId = parentNodeId.replace('branch-true-', '');
        const { ifIndex, trueIndex } = findIfHeaders(ifId);
        if (ifIndex === -1 || trueIndex === -1) { closeActionModal(); return; }
        const actionNode = createNode(actionType, actionType, 'settings', getActionContent({ type: actionType, properties }));
        actionNode.style.left = 'calc(50% - 280px)';
        actionNode.style.transform = 'translateX(-50%)';
        const trueEl = nodes[trueIndex].element;
        const containerRect = container.getBoundingClientRect();
        let y = trueEl.getBoundingClientRect().bottom - containerRect.top + 60;
        const ifStepId = nodes[ifIndex]?.data?.properties?.ifId;
        for (let i = 0; i < nodes.length; i++) {
          const d = nodes[i]?.data;
          if (d && d.properties && d.properties.parentIfId === ifStepId && d.properties.branch === 'true') {
            const r = nodes[i].element.getBoundingClientRect();
            y = Math.max(y, r.bottom - containerRect.top + 60);
          }
        }
        actionNode.style.top = `${y}px`;
        container.appendChild(actionNode);
        const nodeData = { id: actionNode.id, type: 'action', element: actionNode, data: { type: actionType, properties: { ...properties, parentIfId: ifStepId, ifDomId: ifId, branch: 'true' } } };
        nodes.push(nodeData);
        StructureManager.rebuild();
        closeActionModal();
        return;
      }
      if (parentNodeId && parentNodeId.startsWith('branch-false-')) {
        const ifId = parentNodeId.replace('branch-false-', '');
        const { ifIndex, falseIndex } = findIfHeaders(ifId);
        if (ifIndex === -1 || falseIndex === -1) { closeActionModal(); return; }
        const actionNode = createNode(actionType, actionType, 'settings', getActionContent({ type: actionType, properties }));
        actionNode.style.left = 'calc(50% + 280px)';
        actionNode.style.transform = 'translateX(-50%)';
        const falseEl = nodes[falseIndex].element;
        const containerRect = container.getBoundingClientRect();
        let y = falseEl.getBoundingClientRect().bottom - containerRect.top + 60;
        const ifStepId = nodes[ifIndex]?.data?.properties?.ifId;
        for (let i = 0; i < nodes.length; i++) {
          const d = nodes[i]?.data;
          if (d && d.properties && d.properties.parentIfId === ifStepId && d.properties.branch === 'false') {
            const r = nodes[i].element.getBoundingClientRect();
            y = Math.max(y, r.bottom - containerRect.top + 60);
          }
        }
        actionNode.style.top = `${y}px`;
        container.appendChild(actionNode);
        const nodeData = { id: actionNode.id, type: 'action', element: actionNode, data: { type: actionType, properties: { ...properties, parentIfId: ifStepId, ifDomId: ifId, branch: 'false' } } };
        nodes.push(nodeData);
        StructureManager.rebuild();
        closeActionModal();
        return;
      }
      
      // Check if this is an "add after" operation
      if (parentNodeId && parentNodeId.startsWith('add-after-')) {
        const afterNodeId = parentNodeId.replace('add-after-', '');
        
        // Create the action node
        const actionNode = createNode(actionType, actionType, 'settings', getActionContent({ type: actionType, properties }));
        
        // Find the node to add after
        const afterNode = nodes.find(n => n.id === afterNodeId);
        if (!afterNode) {
          console.error('Could not find node to add after:', afterNodeId);
          closeActionModal();
          return;
        }
        
        // Position the new action below the "after" node, centered horizontally
        const afterRect = afterNode.element.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();
        
        // Position below the "after" node
        const topPosition = afterRect.bottom - containerRect.top + 120;
        
        // Horizontal centering is handled by translateX(-50%) on the node
        actionNode.style.left = '50%';
        actionNode.style.top = `${topPosition}px`;
        actionNode.style.transform = 'translateX(-50%)';
        
        container.appendChild(actionNode);
        
        // Add to nodes array
        const nodeData = { 
          id: actionNode.id, 
          type: 'action', 
          element: actionNode, 
          data: { type: actionType, properties } 
        };
        nodes.push(nodeData);
        
        // Rebuild the entire workflow structure to ensure all connections are created
        StructureManager.rebuild();

        // If IF, auto-create True/False headers
        if (actionType === 'If') {
          if (!properties) properties = {};
          if (!properties.ifId) properties.ifId = `if_${Date.now()}_${Math.random().toString(36).slice(2)}`;
          // Update node data to include ifId
          nodeData.data = { type: actionType, properties };
          const trueNode = addControlNodeAfterElement(actionNode, 'True');
          const falseNode = addControlNodeAfterElement(actionNode, 'False');
          if (trueNode && trueNode.element) trueNode.data = { type: 'True', properties: { parentIfId: properties.ifId, ifDomId: actionNode.id, branch: 'true' } };
          if (falseNode && falseNode.element) falseNode.data = { type: 'False', properties: { parentIfId: properties.ifId, ifDomId: actionNode.id, branch: 'false' } };
        }
        
        // Add movement listeners to the new node
        addNodeMovementListeners();
        
        closeActionModal();
        return;
      }
      
      // Check if we're editing an existing action
      const existingNode = nodes.find(n => n.id === parentNodeId);
      if (existingNode && existingNode.type !== 'trigger') {
        // Update existing action
        existingNode.data = { type: actionType, properties };
        existingNode.element.querySelector('.node-title').textContent = actionType;
        existingNode.element.querySelector('.node-content').textContent = getActionContent({ type: actionType, properties });
        updateWorkflowFromNodes();
      } else {
        // Add new action node
        addActionNode({ type: actionType, properties }, nodes.length);
      }
      
      closeActionModal();
    }

    function updateTriggerNode(triggerData) {
      console.log('Updating trigger node with data:', triggerData);
      
      let triggerNode = nodes.find(n => n.type === 'trigger');
      
      if (!triggerNode) {
        console.log('Creating new trigger node');
        // Create new trigger node if it doesn't exist
        const node = createNode('trigger', triggerData.type, 'play_circle', 'Click to configure trigger');
        node.style.left = '50%';
        node.style.top = '50px';
        node.style.transform = 'translateX(-50%)';
        
        // Override the click handler for the trigger node specifically
        node.removeEventListener('click', (e) => selectNode(node));
        node.addEventListener('click', (e) => {
          e.stopPropagation();
          openTriggerModal();
        });
        
        container.appendChild(node);
        
        triggerNode = { 
          id: node.id, 
          type: 'trigger', 
          element: node 
        };
        nodes.push(triggerNode);
        
      // Rebuild workflow structure to ensure proper connections
      StructureManager.rebuild();
      
      // Add movement listeners
      addNodeMovementListeners();
      }
      
      const node = triggerNode.element;
      const title = triggerData.type;
      let content = '';
      
      if (triggerData.type === 'Meeting Scheduled' && triggerData.properties?.eventTypes) {
        content = `Triggers when meetings are scheduled for: ${triggerData.properties.eventTypes.join(', ')}`;
      } else if (triggerData.type === 'Tag Added' && triggerData.properties?.tags) {
        content = `Triggers when tags are added: ${triggerData.properties.tags.join(', ')}`;
      } else {
        content = `Triggers on: ${triggerData.type}`;
      }
      
      node.querySelector('.node-title').textContent = title;
      node.querySelector('.node-content').textContent = content;
      
      // Store trigger data
      triggerNode.data = triggerData;
    }

    function addActionNode(actionData, index) {
      console.log('Adding action node:', actionData);
      
      // Check if this action already exists to prevent duplicates
      const existingAction = nodes.find(n => 
        n.type !== 'trigger' && 
        n.data && 
        n.data.type === actionData.type &&
        JSON.stringify(n.data.properties) === JSON.stringify(actionData.properties)
      );
      
      if (existingAction) {
        console.log('Action already exists, skipping:', actionData);
        return;
      }
      
      // Find the trigger node (should be the first one)
      const triggerNode = nodes.find(n => n.type === 'trigger');
      if (!triggerNode) {
        console.error('No trigger node found when adding action');
        return;
      }
      
      const actionNode = createNode(actionData.type, actionData.type, 'settings', getActionContent(actionData));
      
      // Position the action node below the trigger or last action
      let parentNode = triggerNode;
      const lastActionNode = nodes.filter(n => n.type !== 'trigger').pop();
      if (lastActionNode) {
        parentNode = lastActionNode;
      }
      
      const parentRect = parentNode.element.getBoundingClientRect();
      const containerRect = container.getBoundingClientRect();
      
      // Position below the parent node
      const topPosition = parentRect.bottom - containerRect.top + 120;
      
      // Horizontal centering is handled by translateX(-50%) on the node
      actionNode.style.left = '50%';
      actionNode.style.top = `${topPosition}px`;
      actionNode.style.transform = 'translateX(-50%)';
      
      container.appendChild(actionNode);
      
      const nodeData = { 
        id: actionNode.id, 
        type: 'action', 
        element: actionNode, 
        data: actionData 
      };
      nodes.push(nodeData);
      
      // Rebuild the entire workflow structure to ensure consistency
      StructureManager.rebuild();

      // If we just added an IF, auto-create True/False headers
      if (actionData.type === 'If') {
        if (!actionData.properties) actionData.properties = {};
        if (!actionData.properties.ifId) actionData.properties.ifId = `if_${Date.now()}_${Math.random().toString(36).slice(2)}`;
        nodeData.data = actionData;
        const trueNode = addControlNodeAfterElement(actionNode, 'True');
        const falseNode = addControlNodeAfterElement(actionNode, 'False');
        if (trueNode && trueNode.element) trueNode.data = { type: 'True', properties: { parentIfId: actionData.properties.ifId, ifDomId: actionNode.id, branch: 'true' } };
        if (falseNode && falseNode.element) falseNode.data = { type: 'False', properties: { parentIfId: actionData.properties.ifId, ifDomId: actionNode.id, branch: 'false' } };
      }
      
      // Add movement listeners to the new node
      addNodeMovementListeners();
    }

    function insertActionBetween(actionData, connection) {
      console.log('Inserting action between nodes:', connection.from.id, 'and', connection.to.id);
      
      // Create the new action node
      const actionNode = createNode(actionData.type, actionData.type, 'settings', getActionContent(actionData));
      
      // Position the action node in the middle of the connection
      const fromRect = connection.from.getBoundingClientRect();
      const toRect = connection.to.getBoundingClientRect();
      const containerRect = container.getBoundingClientRect();
      
      const middleX = (fromRect.left + toRect.left) / 2 - containerRect.left;
      const middleY = (fromRect.bottom + toRect.top) / 2 - containerRect.top;
      
      actionNode.style.left = `${middleX - 100}px`; // 100 is half of node width
      actionNode.style.top = `${middleY - 25}px`; // 25 is half of node height
      
      container.appendChild(actionNode);
      
      const nodeData = { 
        id: actionNode.id, 
        type: 'action', 
        element: actionNode, 
        data: actionData 
      };
      
      // Insert the node into the nodes array at the correct position
      const fromNodeIndex = nodes.findIndex(n => n.element === connection.from);
      const toNodeIndex = nodes.findIndex(n => n.element === connection.to);
      
      if (fromNodeIndex !== -1 && toNodeIndex !== -1) {
        // Insert between the two nodes
        const insertIndex = Math.min(fromNodeIndex, toNodeIndex) + 1;
        nodes.splice(insertIndex, 0, nodeData);
      } else {
        // Fallback: add to end
        nodes.push(nodeData);
      }
      
      // Rebuild the entire workflow structure
      StructureManager.rebuild();
      
      // Add movement listeners
      addNodeMovementListeners();
      
      console.log('Action inserted successfully');
      return nodeData;
    }

    // Helper: add a lightweight branch header node (True/False) immediately after a given node element
    function addControlNodeAfterElement(afterNodeElement, type) {
      const content = type;
      const actionNode = createNode(type, type, 'settings', content);
      const afterRect = afterNodeElement.getBoundingClientRect();
      const containerRect = container.getBoundingClientRect();
      const topPosition = afterRect.bottom - containerRect.top + 80;
      actionNode.style.left = '50%';
      actionNode.style.top = `${topPosition}px`;
      actionNode.style.transform = 'translateX(-50%)';
      container.appendChild(actionNode);
      const afterIndex = nodes.findIndex(n => n.element === afterNodeElement);
      const nodeData = { id: actionNode.id, type: 'action', element: actionNode, data: { type, properties: {} } };
      if (afterIndex >= 0) {
        nodes.splice(afterIndex + 1, 0, nodeData);
      } else {
        nodes.push(nodeData);
      }
      StructureManager.rebuild();
      addNodeMovementListeners();
      return nodeData;
    }

    function getActionContent(actionData) {
      if (actionData.type === 'Add Tag') {
        return `Adds tag: ${actionData.properties.tag}`;
      }
      if (actionData.type === 'Send Email') {
        const p = actionData.properties || {};
        const auto = p.useTriggerRecipient === true || (!p.to || (Array.isArray(p.to) && p.to.length === 0));
        const to = auto ? 'Contact' : (Array.isArray(p.to) ? p.to.join(', ') : (p.to || ''));
        const subj = p.subject || '';
        const mode = p.isHtml ? 'HTML' : 'Text';
        return `Email (${mode}) to ${to} — Subject: ${subj}`;
      }
      if (actionData.type === 'If') {
        const p = actionData.properties || {};
        const needsValue = !['exists','not_exists'].includes(p.operator);
        const val = Array.isArray(p.value) ? p.value.join(', ') : (p.value ?? '');
        const core = `If ${p.field} ${p.operator}${needsValue ? ' ' : ''}${needsValue ? val : ''}`;
        const warn = p.triggerType === 'Tag Added' ? ' — missing data -> false path' : '';
        return core + warn + '  •  Use buttons to add to True/False paths';
      }
      if (actionData.type === 'True') return 'True — actions in this branch run when the If condition evaluates to TRUE.';
      if (actionData.type === 'False') return 'False — actions in this branch run when the If condition evaluates to FALSE.';
      return `Action: ${actionData.type}`;
    }
    
    function editAction(actionNode) {
      const nodeData = nodes.find(n => n.element === actionNode);
      if (!nodeData) return;
      
      // If IF node: present branch controls instead of opening modal
      if (nodeData.data && nodeData.data.type === 'If') {
        try { decorateIfNodeForBranches(actionNode); } catch {}
        // Do not open modal for IF itself on click; let user choose branch buttons
        return;
      }

      // Open action modal with existing data
      selectedNode = actionNode.id;
      openActionModal(actionNode.id);
      
      // Pre-populate the form
      const actionSelect = document.getElementById('action-select');
      if (actionSelect) {
        actionSelect.value = nodeData.data.type;
        renderActionProperties();
        
        // Set the selected tag if it's an Add Tag action
        if (nodeData.data.type === 'Add Tag' && nodeData.data.properties?.tag) {
          window.selectedActionTag = nodeData.data.properties.tag;
          const display = document.getElementById('action-tag-display');
          if (display) {
            display.textContent = `✓ ${nodeData.data.properties.tag}`;
            display.style.color = '#34D399';
          }
        }

        // Prefill Send Email fields when editing
        if (nodeData.data.type === 'Send Email' && nodeData.data.properties) {
          const p = nodeData.data.properties;
          const set = (id, val) => { const el = document.getElementById(id); if (el && val !== undefined && val !== null) el.value = val; };
          const manualEl = document.getElementById('email-manual-recipient');
          const toWrap = document.getElementById('email-to-wrapper');
          const manual = !(p.useTriggerRecipient === true || (!p.to || (Array.isArray(p.to) && p.to.length === 0)));
          if (manualEl) manualEl.checked = manual;
          if (toWrap) toWrap.style.display = manual ? 'block' : 'none';
          set('email-to', Array.isArray(p.to) ? p.to.join(', ') : (p.to || ''));
          set('email-cc', Array.isArray(p.cc) ? p.cc.join(', ') : (p.cc || ''));
          set('email-bcc', Array.isArray(p.bcc) ? p.bcc.join(', ') : (p.bcc || ''));
          set('email-subject', p.subject || '');
          const bodyEl = document.getElementById('email-body');
          if (bodyEl) bodyEl.value = p.body || '';
          const htmlEl = document.getElementById('email-is-html');
          if (htmlEl) htmlEl.checked = !!p.isHtml;
        }
      }
    }
    
    function deleteAction(actionNode) {
      if (!confirm('Are you sure you want to delete this action?')) return;
      
      const nodeData = nodes.find(n => n.element === actionNode);
      if (!nodeData) return;
      
      console.log('Deleting action node:', nodeData);
      
      // Remove all connections involving this node
      WorkflowManager.removeNodeConnections(actionNode);
      
      // Remove the node's orb
      OrbManager.removeOrb(actionNode);
      
      // Remove the node from the DOM
      if (actionNode.parentNode) {
        actionNode.remove();
      }
      
      // Remove from nodes array
      const index = nodes.findIndex(n => n.element === actionNode);
      if (index > -1) {
        nodes.splice(index, 1);
        console.log('Removed node from array, remaining nodes:', nodes.length);
      }
      
      // Rebuild the entire workflow structure
      StructureManager.rebuild();
      
      // Update the workflow data
      updateWorkflowFromNodes();
      
      console.log('After delete - remaining nodes:', nodes.length);
      console.log('After delete - currentWorkflow.data:', currentWorkflow?.data);
    }
    
    
    function validateWorkflowStructure() {
      try {
        // Check if we have a valid trigger
        const triggerNode = nodes.find(n => n.type === 'trigger');
        if (!triggerNode || !triggerNode.data || !triggerNode.data.type) {
          console.error('Invalid trigger node');
          return false;
        }
        
        // Check if trigger has required properties
        if (triggerNode.data.type === 'Meeting Scheduled' && (!triggerNode.data.properties?.eventTypes || triggerNode.data.properties.eventTypes.length === 0)) {
          console.error('Meeting Scheduled trigger requires event types');
          return false;
        }
        
        if (triggerNode.data.type === 'Tag Added' && (!triggerNode.data.properties?.tags || triggerNode.data.properties.tags.length === 0)) {
          console.error('Tag Added trigger requires tags');
          return false;
        }
        
        // Check if all action nodes have valid data
        const actionNodes = nodes.filter(n => n.type !== 'trigger');
        for (const actionNode of actionNodes) {
          if (!actionNode.data || !actionNode.data.type) {
            console.error('Invalid action node:', actionNode);
            return false;
          }
          
          // Check if Add Tag action has required properties
          if (actionNode.data.type === 'Add Tag' && (!actionNode.data.properties?.tag || actionNode.data.properties.tag === '')) {
            console.error('Add Tag action requires a tag');
            return false;
          }
        }
        // No End If/Else validation needed in True/False branching model

        console.log('Workflow structure validation passed');
        return true;
      } catch (error) {
        console.error('Error validating workflow structure:', error);
        return false;
      }
    }
    
    function updateWorkflowFromNodes() {
      // Rebuild the workflow steps array from current nodes
      const steps = [];
      
      nodes.forEach(node => {
        // Only add non-trigger nodes to steps array
        if (node.type !== 'trigger' && node.data) {
          steps.push(node.data);
        }
      });
      
      console.log('Updated workflow steps:', steps);
      console.log('Current nodes count:', nodes.length);
      console.log('Nodes:', nodes.map(n => ({ type: n.type, id: n.id })));
      
      // Update the current workflow data structure
      if (currentWorkflow) {
        const triggerNode = nodes.find(n => n.type === 'trigger');
        if (triggerNode && triggerNode.data) {
          currentWorkflow.data = {
            trigger: triggerNode.data.type,
            triggerEventTypes: triggerNode.data.properties?.eventTypes || [],
            triggerEventTypeIds: triggerNode.data.properties?.eventTypeIds || [],
            triggerTags: triggerNode.data.properties?.tags || [],
            steps: steps,
            status: true
          };
          console.log('Updated currentWorkflow.data:', currentWorkflow.data);
          } else {
          console.log('No trigger node found or no trigger data');
        }
      } else {
        console.log('No currentWorkflow to update');
      }
    }


    async function saveWorkflow() {
      console.log('=== SAVE WORKFLOW CALLED ===');
      const workflowNameInput = document.getElementById('workflow-name');
      const name = workflowNameInput.value.trim() || 'Untitled Workflow';
      
      if (nodes.length === 0) {
        alert('Please configure at least a trigger for your workflow');
        return;
      }
      
      const triggerNode = nodes.find(n => n.type === 'trigger');
      if (!triggerNode || !triggerNode.data) {
        alert('Please configure the trigger for your workflow');
        return;
      }
      
      // Validate workflow structure before saving
      if (!validateWorkflowStructure()) {
        alert('Workflow structure is invalid. Please check your configuration.');
        return;
      }
      
      // Always rebuild the workflow data from current nodes to ensure accuracy
      // Only include non-trigger nodes in steps array
      const steps = nodes
        .filter(node => node.type !== 'trigger')
        .map(node => node.data);
      
      console.log('Current nodes:', nodes);
      console.log('Mapped steps:', steps);
      
      // Prepare the workflow data structure - always use current node state
      const workflowData = {
        trigger: triggerNode.data.type,
        triggerEventTypes: triggerNode.data.properties?.eventTypes || [],
        triggerEventTypeIds: triggerNode.data.properties?.eventTypeIds || [],
        triggerTags: triggerNode.data.properties?.tags || [],
        steps: steps, // Include trigger in steps for consistency
        status: true,
        contextSpec: contextSpec || getDefaultContextSpec()
      };
      
      // Update currentWorkflow.data to match what we're saving
      if (currentWorkflow) {
        currentWorkflow.data = workflowData;
        console.log('Updated currentWorkflow.data before saving:', currentWorkflow.data);
      }
      
      console.log('Prepared workflow data for saving:', workflowData);
      
      console.log('Saving workflow with data:', workflowData);
      console.log('Trigger node data:', triggerNode.data);
      
      try {
                const token = getAnyToken();
      if (!token) {
          console.error('No token found');
          alert('Please log in to save workflows');
        return;
      }
      
        console.log('Token found, cleaning...');
        const clean = token.replace(/^"|"$/g, '');
        console.log('Token cleaned, length:', clean.length);
        
        if (currentWorkflow) {
          console.log('Updating existing workflow:', currentWorkflow.id);
          // Update existing workflow
          const updateData = {
            name,
            description: currentWorkflow.description || '',
            data: workflowData
          };
          console.log('Update data:', updateData);
          
          const res = await fetch(`${API_URL}/workflows/${currentWorkflow.id}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${clean}` },
            body: JSON.stringify(updateData)
          });
          
          console.log('Update response status:', res.status);
          
          if (res.ok) {
            console.log('Workflow updated successfully');
            localStorage.removeItem('calendarify-current-workflow');
            localStorage.setItem('calendarify-redirect-to', 'workflows');
            localStorage.setItem('calendarify-notification', 'Workflow updated successfully!');
            window.location.href = '/dashboard';
          } else {
            const errorData = await res.json();
            console.error('Failed to update workflow:', errorData);
            showNotification('Failed to update workflow', 'error');
          }
        } else {
          console.log('Creating new workflow...');
          // Create new workflow
          const createData = {
            name,
            description: '',
            data: workflowData
          };
          console.log('Create data:', createData);
          
          const res = await fetch(`${API_URL}/workflows`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${clean}` },
            body: JSON.stringify(createData)
          });
          
          console.log('Create response status:', res.status);
          
          if (res.ok) {
            const newWorkflow = await res.json();
            console.log('Workflow created successfully:', newWorkflow);
            localStorage.removeItem('calendarify-current-workflow');
            localStorage.setItem('calendarify-redirect-to', 'workflows');
            localStorage.setItem('calendarify-notification', 'Workflow created successfully!');
            window.location.href = '/dashboard';
          } else {
            const errorData = await res.json();
            console.error('Failed to create workflow:', errorData);
            showNotification('Failed to create workflow', 'error');
          }
        }
      } catch (error) {
        console.error('Error saving workflow:', error);
        showNotification('Failed to save workflow', 'error');
      }
    }

    // Close modals when clicking outside
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('modal-backdrop')) {
        e.target.classList.add('hidden');
      }
    });

    // Handle trigger type change
    document.getElementById('trigger-select').addEventListener('change', renderTriggerProperties);
    
    // Handle action type change
    document.getElementById('action-select').addEventListener('change', renderActionProperties);
    
    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Delete' && selectedNode) {
        deleteSelectedNode();
      } else if (e.key === 'Escape') {
        if (triggerModal.classList.contains('hidden') && actionModal.classList.contains('hidden')) {
          // Deselect node
          if (selectedNode) {
            selectedNode.classList.remove('selected');
            selectedNode = null;
          }
        } else {
          // Close modals
          closeTriggerModal();
          closeActionModal();
        }
      }
    });
    
    function deleteSelectedNode() {
      if (!selectedNode || selectedNode.type === 'trigger') return;
      
      if (confirm('Are you sure you want to delete this action?')) {
        const nodeData = nodes.find(n => n.element === selectedNode);
        if (nodeData) {
          // Remove connections
          WorkflowManager.removeNodeConnections(selectedNode);
          
          // Remove action orb
          OrbManager.removeOrb(selectedNode);
          
          // Remove node
          selectedNode.remove();
          nodes = nodes.filter(n => n.id !== nodeData.id);
          
          // Rebuild structure
          StructureManager.rebuild();
          
          selectedNode = null;
        }
      }
    }
    
    // Add movement listeners to all nodes (simplified - no automatic updates)
    function addNodeMovementListeners() {
      const nodes = container.querySelectorAll('.flowchart-node');
      nodes.forEach(node => {
        // Remove any existing transition listeners that might cause issues
        node.removeEventListener('transitionend', () => {});
        // No automatic position updates - PositionManager handles stability
      });
    }
    
    // Loading screen functions
    function showLoadingScreen() {
      const loadingScreen = document.getElementById('workflow-loading-screen');
      if (loadingScreen) {
        loadingScreen.style.display = 'flex';
      }
    }

    function hideLoadingScreen() {
      const loadingScreen = document.getElementById('workflow-loading-screen');
      if (loadingScreen) {
        loadingScreen.style.display = 'none';
      }
    }

    // Production-grade position management system
    const PositionManager = {
      isInitialized: false,
      isUpdating: false,
      
      init() {
        if (this.isInitialized) return;
        this.isInitialized = true;
        
        // Disable all CSS transitions on connection lines and orbs
        this.disableProblematicTransitions();
        
        // Set up stable positioning system
        this.setupStablePositioning();
        
        console.log('PositionManager initialized');
      },
      
      disableProblematicTransitions() {
        // Remove all transitions from connection lines and orbs
        const style = document.createElement('style');
        style.textContent = `
          .connection-line,
          .add-action-orb,
          .insert-action-orb {
            transition: none !important;
            animation: none !important;
          }
          
          .flowchart-node {
            transition: box-shadow 0.2s, transform 0.2s !important;
          }
          
          .flowchart-node * {
            transition: none !important;
          }
        `;
        document.head.appendChild(style);
      },
      
      setupStablePositioning() {
        // Override the connection positioning to be completely stable
        this.originalUpdateConnectionPosition = WorkflowManager.updateConnectionPosition;
        WorkflowManager.updateConnectionPosition = this.stableUpdateConnectionPosition.bind(this);
        
        // Override orb positioning to be completely stable
        this.originalPositionOrbAtMidpoint = OrbManager.positionOrbAtMidpoint;
        OrbManager.positionOrbAtMidpoint = this.stablePositionOrbAtMidpoint.bind(this);
        
        this.originalPositionOrb = OrbManager.positionOrb;
        OrbManager.positionOrb = this.stablePositionOrb.bind(this);
      },
      
      stableUpdateConnectionPosition(connection) {
        if (!connection || !connection.line || !connection.from || !connection.to) {
        return;
      }
        
        try {
          const fromRect = connection.from.getBoundingClientRect();
          const toRect = connection.to.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          
          if (!fromRect || !toRect || !containerRect) {
          return;
        }
        
          // Calculate connection points (center bottom of from, center top of to)
          const fromX = Math.round(fromRect.left - containerRect.left + fromRect.width / 2);
          const fromY = Math.round(fromRect.bottom - containerRect.top - 1);
          const toX = Math.round(toRect.left - containerRect.left + toRect.width / 2);
          const toY = Math.round(toRect.top - containerRect.top + 1);

          // If using SVG path, draw an orthogonal rounded path; otherwise keep legacy div behavior
          const el = connection.line;
          if (el && el.tagName && el.tagName.toLowerCase() === 'path') {
            const fromType = (connection.from.__nodeData && connection.from.__nodeData.data?.type) || nodes.find(n=>n.element===connection.from)?.data?.type || '';
            const toType = (connection.to.__nodeData && connection.to.__nodeData.data?.type) || nodes.find(n=>n.element===connection.to)?.data?.type || '';
            connection.from.__nodeData = nodes.find(n => n.element === connection.from) || connection.from.__nodeData || null;
            connection.to.__nodeData = nodes.find(n => n.element === connection.to) || connection.to.__nodeData || null;

            let d = '';
            const vDrop = 30;
            const r = 12;
            if (fromType === 'If' && (toType === 'True' || toType === 'False')) {
              const midY = fromY + vDrop;
              d += `M ${fromX} ${fromY}`;
              d += ` L ${fromX} ${midY - r}`;
              const dir = (toX >= fromX) ? 1 : -1;
              d += ` Q ${fromX} ${midY} ${fromX + dir * r} ${midY}`;
              d += ` L ${toX - dir * r} ${midY}`;
              d += ` Q ${toX} ${midY} ${toX} ${midY + r}`;
              d += ` L ${toX} ${toY}`;
            } else if ((fromType === 'True' || fromType === 'False') && !(toType === 'True' || toType === 'False')) {
              const ctrlY = fromY + 20;
              d = `M ${fromX} ${fromY} Q ${fromX} ${ctrlY} ${fromX} ${ctrlY} L ${toX} ${ctrlY} Q ${toX} ${ctrlY} ${toX} ${toY}`;
            } else {
              const mx = Math.round((fromX + toX) / 2);
              d = `M ${fromX} ${fromY} C ${mx} ${fromY}, ${mx} ${toY}, ${toX} ${toY}`;
            }
            el.setAttribute('d', d);
            el.style.display = 'block';
          } else {
            // Legacy fallback (div line rotated)
            const deltaX = toX - fromX;
            const deltaY = toY - fromY;
            const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const angle = Math.atan2(deltaY, deltaX);
            el.style.left = `${fromX}px`;
            el.style.top = `${fromY}px`;
            el.style.width = `${length}px`;
            el.style.transform = `rotate(${angle}rad)`;
            el.style.display = 'block';
          }
          connection.line.style.opacity = '1';
          
          // Update insert orb position if it exists
          this.updateInsertOrbPosition(connection);
          
      } catch (error) {
          console.error('Error in stable connection positioning:', error);
        }
      },
      
      stablePositionOrbAtMidpoint(orb, fromNode, toNode) {
        if (!orb || !fromNode || !toNode) {
          return;
        }
        
        try {
          const fromRect = fromNode.getBoundingClientRect();
          const toRect = toNode.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          
          if (!fromRect || !toRect || !containerRect) {
            return;
          }
          
          // Calculate connection points (exactly like connection lines)
          const fromX = Math.round(fromRect.left - containerRect.left + fromRect.width / 2);
          const fromY = Math.round(fromRect.bottom - containerRect.top - 1);
          const toX = Math.round(toRect.left - containerRect.left + toRect.width / 2);
          const toY = Math.round(toRect.top - containerRect.top + 1);
          
          // Calculate midpoint with pixel-perfect precision
          const midpointX = (fromX + toX) / 2;
          const midpointY = (fromY + toY) / 2;
          
          // Position orb at exact midpoint
          const finalLeft = Math.round(midpointX - 1); // 1px offset for visual centering
          const finalTop = Math.round(midpointY);
          
          orb.style.left = `${finalLeft}px`;
          orb.style.top = `${finalTop}px`;
          orb.style.transform = 'translate(-50%, -50%)';
          orb.style.opacity = '1';
          
        } catch (error) {
          // Fallback positioning
          orb.style.left = '50%';
          orb.style.top = '50%';
          orb.style.transform = 'translate(-50%, -50%)';
        }
      },
      
      stablePositionOrb(orb, node, position) {
        if (!orb || !node) {
          return;
        }
        
        try {
          const nodeRect = node.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          
          if (!nodeRect || !containerRect) {
            return;
          }
          
          // Calculate relative positions (same as original approach)
          const nodeLeft = nodeRect.left - containerRect.left;
          const nodeTop = nodeRect.top - containerRect.top;
          const nodeWidth = nodeRect.width;
          const nodeHeight = nodeRect.height;
          
          // Orb dimensions
          const orbSize = 40;
          const orbHalfSize = orbSize / 2;
          
          let finalLeft, finalTop;
          
          if (position === 'bottom') {
            // Center horizontally by subtracting half orb size (original approach)
            finalLeft = Math.round(nodeLeft + (nodeWidth / 2) - orbHalfSize);
            finalTop = Math.round(nodeTop + nodeHeight + 20); // 20px below the node
            orb.style.transform = 'scale(1)'; // No centering transform for bottom orbs
          } else if (position === 'top') {
            // Center horizontally by subtracting half orb size (original approach)
            finalLeft = Math.round(nodeLeft + (nodeWidth / 2) - orbHalfSize);
            finalTop = Math.round(nodeTop - orbSize - 20); // 20px above the node
            orb.style.transform = 'scale(1)'; // No centering transform for top orbs
          } else {
            // Default to bottom positioning
            finalLeft = Math.round(nodeLeft + (nodeWidth / 2) - orbHalfSize);
            finalTop = Math.round(nodeTop + nodeHeight + 20);
            orb.style.transform = 'scale(1)';
          }
          
          orb.style.left = `${finalLeft}px`;
          orb.style.top = `${finalTop}px`;
          orb.style.opacity = '1';
          
        } catch (error) {
          // Fallback positioning
          orb.style.left = '50%';
          orb.style.top = '50%';
          orb.style.transform = 'translate(-50%, -50%)';
        }
      },
      
      updateInsertOrbPosition(connection) {
        if (!connection.insertOrb) return;
        
        try {
          const fromRect = connection.from.getBoundingClientRect();
          const toRect = connection.to.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          
          if (!fromRect || !toRect || !containerRect) {
            return;
          }
          
          const fromX = Math.round(fromRect.left - containerRect.left + fromRect.width / 2);
          const fromY = Math.round(fromRect.bottom - containerRect.top - 1);
          const toX = Math.round(toRect.left - containerRect.left + toRect.width / 2);
          const toY = Math.round(toRect.top - containerRect.top + 1);
          
          const midpointX = (fromX + toX) / 2;
          const midpointY = (fromY + toY) / 2;
          
          connection.insertOrb.style.left = `${Math.round(midpointX)}px`;
          connection.insertOrb.style.top = `${Math.round(midpointY)}px`;
          connection.insertOrb.style.transform = 'translate(-50%, -50%)';
          
        } catch (error) {
          console.error('Error updating insert orb position:', error);
        }
      },
      
      // Clean up and restore original functions
      cleanup() {
        if (this.originalUpdateConnectionPosition) {
          WorkflowManager.updateConnectionPosition = this.originalUpdateConnectionPosition;
        }
        if (this.originalPositionOrbAtMidpoint) {
          OrbManager.positionOrbAtMidpoint = this.originalPositionOrbAtMidpoint;
        }
        if (this.originalPositionOrb) {
          OrbManager.positionOrb = this.originalPositionOrb;
        }
        this.isInitialized = false;
      }
    };

    // Initialize the workflow editor when the page loads
    document.addEventListener('DOMContentLoaded', async () => {
      try {
        console.log('Initializing workflow editor...');
        showLoadingScreen();
        
        // Initialize canvas
        initializeCanvas();
        
        // Load existing workflow if editing
        await loadWorkflow();
        
        // Create initial trigger node if no workflow loaded
        if (nodes.length === 0) {
          createInitialTriggerNode();
        }
        
        // Add movement listeners
        addNodeMovementListeners();
        
        // Initialize production-grade position management system
        PositionManager.init();
        
        // Preload errors if an id is present
        try { await refreshErrors(); } catch {}
        try { await refreshRuns(); } catch {}

        // After fonts and layout settle, do a final alignment pass
        const settle = () => {
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              refreshStructure();
            });
          });
        };
        if (document.fonts && document.fonts.ready) {
          document.fonts.ready.then(settle).catch(settle);
        } else {
          settle();
        }
        
        console.log('Workflow editor initialized successfully');
      } catch (error) {
        console.error('Error initializing workflow editor:', error);
        hideLoadingScreen();
      }
    });

    // Cleanup position manager when page is unloaded
    window.addEventListener('beforeunload', () => {
      PositionManager.cleanup();
    });

    // Keep layout fresh on resize
    window.addEventListener('resize', () => {
      StructureManager.rebuild();
    });

  // Errors panel logic
    async function refreshErrors(limit = 25) {
      const id = localStorage.getItem('calendarify-current-workflow');
      if (!id) return [];
      try {
        const token = getAnyToken();
        if (!token) return [];
        const clean = token.replace(/^"|"$/g, '');
        const res = await fetch(`${API_URL}/workflows/${id}/errors?limit=${limit}`, {
          headers: { Authorization: `Bearer ${clean}` }
        });
        if (!res.ok) return [];
        const items = await res.json();
        renderErrors(items || []);
        return items;
      } catch (e) {
        console.warn('Failed to load workflow errors', e);
        return [];
  }

  // Branch helpers (defined after DOM and utils)
    function findIfHeaders(ifNodeId) {
      const idx = nodes.findIndex(n => n.id === ifNodeId || n.element?.id === ifNodeId);
      let trueIndex = -1, falseIndex = -1;
      if (idx >= 0) {
        for (let i = idx + 1; i < nodes.length; i++) {
          const t = nodes[i]?.data?.type;
          if (t === 'True' && trueIndex === -1) trueIndex = i;
          if (t === 'False') { falseIndex = i; break; }
        }
      }
      return { ifIndex: idx, trueIndex, falseIndex };
    }

  function decorateIfNodeForBranches(actionNodeEl) {
    const content = actionNodeEl.querySelector('.node-content');
    if (!content) return;
    const existing = content.querySelector('.branch-controls');
    if (existing) existing.remove();
    const controls = document.createElement('div');
    controls.className = 'branch-controls';
    controls.style.marginTop = '.5rem';
    controls.style.display = 'flex';
    controls.style.gap = '.5rem';
    controls.innerHTML = `
      <button class="context-btn" title="Add to TRUE path">+ True path</button>
      <button class="context-btn" title="Add to FALSE path">+ False path</button>
    `;
    const [btnTrue, btnFalse] = controls.querySelectorAll('button');
    btnTrue.addEventListener('click', (e) => { e.stopPropagation(); openActionModal(`branch-true-${actionNodeEl.id}`); });
    btnFalse.addEventListener('click', (e) => { e.stopPropagation(); openActionModal(`branch-false-${actionNodeEl.id}`); });
    content.appendChild(controls);
  }
    }

    // Runs panel logic
    const contactCache = new Map();
    const bookingCache = new Map();

    async function fetchContact(contactId) {
      if (!contactId) return null;
      if (contactCache.has(contactId)) return contactCache.get(contactId);
      try {
        const token = getAnyToken();
        const clean = token.replace(/^"|"$/g, '');
        const res = await fetch(`${API_URL}/contacts/${contactId}`, { headers: { Authorization: `Bearer ${clean}` } });
        if (!res.ok) return null;
        const data = await res.json();
        contactCache.set(contactId, data);
        return data;
      } catch { return null; }
    }

    async function fetchBooking(bookingId) {
      if (!bookingId) return null;
      if (bookingCache.has(bookingId)) return bookingCache.get(bookingId);
      try {
        const token = getAnyToken();
        const clean = token.replace(/^"|"$/g, '');
        const res = await fetch(`${API_URL}/bookings/${bookingId}`, { headers: { Authorization: `Bearer ${clean}` } });
        if (!res.ok) return null;
        const data = await res.json();
        bookingCache.set(bookingId, data);
        return data;
      } catch { return null; }
    }

    async function refreshRuns(limit = 50) {
      const id = localStorage.getItem('calendarify-current-workflow');
      if (!id) return [];
      try {
        const token = getAnyToken();
        if (!token) return [];
        const clean = token.replace(/^"|"$/g, '');
        const res = await fetch(`${API_URL}/workflows/${id}/runs?limit=${limit}`, { headers: { Authorization: `Bearer ${clean}` } });
        if (!res.ok) return [];
        const items = await res.json();
        await renderRuns(items || []);
        return items;
      } catch { return []; }
    }

    function toggleRunsPanel() {
      if (!runsDrawer) return;
      const isOpen = runsDrawer.style.display !== 'none';
      runsDrawer.style.display = isOpen ? 'none' : 'block';
      if (!isOpen) refreshRuns();
    }

    async function renderRuns(items) {
      if (!runsActive || !runsHistory) return;
      runsActive.innerHTML = '';
      runsHistory.innerHTML = '';
      const active = items.filter(r => r.status === 'running');
      const past = items.filter(r => r.status !== 'running');

      const section = async (list, container, title) => {
        const header = document.createElement('div');
        header.style.color = '#9ca3af';
        header.style.fontWeight = '600';
        header.style.margin = '0.25rem 0 0.5rem';
        header.textContent = title;
        container.appendChild(header);
        if (list.length === 0) {
          const empty = document.createElement('div');
          empty.style.color = '#9ca3af';
          empty.textContent = 'None';
          container.appendChild(empty);
          return;
        }
        for (const run of list) {
          const row = document.createElement('div');
          row.style.border = '1px solid #263a35';
          row.style.borderRadius = '.5rem';
          row.style.padding = '.75rem';
          row.style.background = '#10231f';
          row.style.cursor = 'pointer';

          const whoEl = document.createElement('div');
          whoEl.style.color = '#E0E0E0';
          whoEl.style.fontWeight = '600';
          whoEl.textContent = 'Resolving participant…';

          // Resolve participant
          const ctx = run.context || {};
          let who = 'Unknown participant';
          try {
            if (ctx.contactId) {
              const c = await fetchContact(ctx.contactId);
              if (c) who = `${c.name || c.email} (${c.email})`;
            } else if (ctx.bookingId) {
              const b = await fetchBooking(ctx.bookingId);
              if (b) who = `${b.name || b.email} (${b.email})`;
            }
          } catch {}
          whoEl.textContent = who;

          const meta = document.createElement('div');
          meta.style.color = '#9ca3af';
          meta.style.fontSize = '.85rem';
          const start = new Date(run.started_at || run.startedAt || run.startedAtUtc || Date.now());
          const end = run.finished_at ? new Date(run.finished_at) : null;
          const dur = end ? ` • ${Math.max(0, Math.round((+end - +start)/1000))}s` : '';
          meta.textContent = `${run.status.toUpperCase()} • ${formatTime(start)}${dur}`;

          row.appendChild(whoEl);
          row.appendChild(meta);

          row.addEventListener('click', async () => {
            await showRunDetails(run.id);
          });

          container.appendChild(row);
        }
      };

      await section(active, runsActive, 'Currently Active');
      await section(past, runsHistory, 'History');
    }

    async function showRunDetails(runId) {
      const id = localStorage.getItem('calendarify-current-workflow');
      if (!id) return;
      try {
        const token = getAnyToken();
        const clean = token.replace(/^"|"$/g, '');
        const res = await fetch(`${API_URL}/workflows/${id}/runs/${runId}`, { headers: { Authorization: `Bearer ${clean}` } });
        if (!res.ok) return;
        const data = await res.json();
        renderRunDetails(data);
      } catch {}
    }

    function renderRunDetails(run) {
      if (!runDetails) return;
      runDetails.style.display = 'block';
      runDetails.innerHTML = '';

      const title = document.createElement('div');
      title.style.color = '#E0E0E0';
      title.style.fontWeight = '700';
      title.style.margin = '0.5rem 0';
      title.textContent = `Run ${run.id} • ${String(run.status).toUpperCase()}`;
      runDetails.appendChild(title);

      const list = document.createElement('div');
      list.style.display = 'flex';
      list.style.flexDirection = 'column';
      list.style.gap = '.5rem';

      (run.steps || []).forEach((step) => {
        const row = document.createElement('div');
        row.style.border = '1px solid #263a35';
        row.style.borderRadius = '.5rem';
        row.style.padding = '.5rem .75rem';
        row.style.background = '#0e201c';
        row.innerHTML = `
          <div style="display:flex;align-items:center;gap:.5rem;">
            <div style="color:#E0E0E0;font-weight:600;">Step ${Number(step.index)+1}: ${escapeHtml(step.type)}</div>
            <div style="margin-left:auto;color:#9ca3af; font-size:.85rem;">${(step.status || '').toUpperCase()}</div>
          </div>
          ${step.message ? `<div style=\"margin-top:.25rem;color:#d1d5db;white-space:pre-wrap;\">${escapeHtml(step.message)}</div>` : ''}
        `;
        row.addEventListener('click', () => highlightStep(Number(step.index)));
        list.appendChild(row);
      });
      runDetails.appendChild(list);
    }

    function toggleErrorsPanel() {
      if (!errorsDrawer) return;
      const isOpen = errorsDrawer.style.display !== 'none';
      errorsDrawer.style.display = isOpen ? 'none' : 'block';
      if (!isOpen) refreshErrors();
    }

    function renderErrors(items) {
      if (!errorsList) return;
      errorsList.innerHTML = '';
      if (!items || items.length === 0) {
        const empty = document.createElement('div');
        empty.style.color = '#9ca3af';
        empty.textContent = 'No recent errors.';
        errorsList.appendChild(empty);
        return;
      }
      const sorted = items.sort((a,b)=>b.ts-a.ts);
      sorted.forEach(err => {
        const row = document.createElement('div');
        row.style.border = '1px solid #263a35';
        row.style.borderRadius = '.5rem';
        row.style.padding = '.75rem';
        row.style.background = '#10231f';
        row.style.cursor = 'pointer';
        row.innerHTML = `
          <div style="display:flex;align-items:center;gap:.5rem;">
            <span class="material-icons-outlined" style="color:#F87171;font-size:18px">error</span>
            <div style="color:#E0E0E0;font-weight:600;">Step ${Number(err.stepIndex)+1}: ${escapeHtml(err.stepType || 'Unknown')}</div>
            <div style="margin-left:auto;color:#9ca3af;font-size:.85rem;">${formatTime(err.ts)}</div>
          </div>
          <div style="margin-top:.5rem;color:#d1d5db; white-space:pre-wrap;">${escapeHtml(err.message || '')}</div>
        `;
        row.addEventListener('click', () => {
          try { highlightStep(Number(err.stepIndex)); } catch {}
        });
        errorsList.appendChild(row);
      });
    }

    function highlightStep(stepIndex) {
      if (isNaN(stepIndex)) return;
      // Steps do not include the trigger; find action nodes in order
      const actionNodes = nodes.filter(n => n.type !== 'trigger');
      if (stepIndex < 0 || stepIndex >= actionNodes.length) return;
      const node = actionNodes[stepIndex]?.element;
      if (!node) return;
      // Select and scroll into view
      container.querySelectorAll('.flowchart-node').forEach(n => n.classList.remove('selected'));
      node.classList.add('selected');
      node.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    function formatTime(ts) {
      try { return new Date(ts).toLocaleString(); } catch { return String(ts); }
    }

    function escapeHtml(s) {
      return String(s)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }
  </script>
</body>
</html>
